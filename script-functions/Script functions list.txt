Специальные отладочные чит-коды:
SEED - вводится на этапе настроек перед запуском новой игры (должны быть включены "тонкие настройки"), позволяет передать игре зерно рандомизатора для генерации Галактики, то есть, по сути, в точности повторить определённую зерном генерацию;
SUDO - код для вызова консоли разработчика, работающий только в тестовых экзешниках (получить такие можно у evilcoward);
EVENTS - код для вывода в лог всех текущих Галактических событий, работающий только в тестовых экзешниках (получить такие можно у evilcoward);
INFOS - код для вывода в лог подробной информации обо всех инфошках на всех кораблях Галактики;
ZAWARUDO - код для "заморозки времени" (полностью останавливает расчёт ходов), однако при перелётах между системами может отрабатывать некорректно;

Особые игровые параметры для кастомных артефактов:
NoWear - полностью отключает износ у указанного кастомного артефакта, делает его неломаемым, а также меняет тип такого предмета с t_Artefact на t_Artefact2:
  1 - данный артефакт становится неломаемым;
CountsAs - заставляет ботов считать данный кастомный арт одним из оригинальных, что позволяет им использовать его автоматически:
  1 - системное название оригинального артефакта, пример: CountsAs=ArtMiniExpl
SharedUse - при указании этого тэга вместе с CountsAs, игра будет считать данный артефакт аналогом оригинала и не позволит установить его в слот, если на кораблей уже и так установлен оригинальный арт или любой другой арт с таким тэгом:
  1 - считать данный артефакт аналогом оригинала при установке в слот;
SharedEffect - при указании этого тэга вместе с CountsAs, игра превратит данный кастомный артефакт в полный аналог оригинального, включая полное повторение всех его активных и пассивных эффектов (но для блокировки слота указать SharedUse всё равно надо). Данный тэг может быть полезен, если вы хотите изменить работу оригинального арта, но вам также нужны переменные под запись данных в артефакт (CustomArtData()), которых у оригинальных артов попросту нет:
  1 - данный артефакт будет иметь тот же эффект, что и оригинальный;

Полезные параметры для графических (и прочих) элементов в Main:
PosAutoCorrection - включает/выключает автокоррекцию позиции конкретного элемента для всех игровых разрешений: True - включить, False - выключить;
PosAutoCorrectionXCoef - коэффициент корректировки позиции по оси X, принимает дробные значения, в обычной ситуации от 0.0 (самая левая часть экрана) до 1.0 (самая правая часть экрана), хотя возможны и отрицательные значения;
PosAutoCorrectionYCoef - коэффициент корректировки позиции по оси Y, принимает дробные значения, в обычной ситуации от 0.0 (самая верхняя часть экрана) до 1.0 (самая нижняя часть экрана), хотя возможны и отрицательные значения;
  Примечание: Сперва настройте желаемую позицию элемента в разрешении 1024x768, а затем "подровняйте" его с помощью PosAutoCorrection на любом другом разрешении до желаемого результата (наиболее часто подходящие значения 0.5 и 1.0). В итоге вы получите полную адаптацию позиции элемента под любые разрешения.
TextColor - устанавливает цвет текста (в формате RGB) для элементов типа Label, пример: TextColor=0,27,50
TextShadow - включает и устанавливает сдвиг тени текста в пикселях для элементов типа Label, пример: TextShadow=1 (тень будет иметь сдвиг в один пиксель вниз и вправо)
TextShadowColor - устанавливает цвет тени (в формате RGB) для текста в элементах типа Label, пример: TextShadowColor=8,136,181
ImageFirst - параметр для объекта типа GAI, в котором указывается опорный кадр в случае, если прикреплённой анимации он необходим;
SoundStart - параметр для объекта типа GAI, проигрывает указанный звук при начале воспроизведения прикреплённой анимации, пример: SoundStart=Sound.Sell
Radius - параметр для звезды, задаёт радиус области в центре системы, в которой будет выводиться информация о звезде при наведении курсора;
SafeRadius - параметр для звезды, задаёт безопасный радиус облёта звезды, в зависимости от которого корабли будут выбирать свою траекторию;
DamageRadius - параметр для звезды, задаёт радиус, в пределах которого кораблям будет наноситься урон от звезды;
DrawLines - параметр для раздела 'Data.StyleConstellation' в Main.dat. Включает и отключает отрисовку линий между группами звёзд на галакарте:
  Yes - включить отрисовку линий созвездий;
  No - выключить отрисовку линий созвездий;
LinesColor - параметр для раздела 'Data.StyleConstellation' в Main.dat. Меняет цвет линий между группами звёзд на галакарте и имеет нестандартную форму записи формата RGB, где каждый цвет задаётся не байтовой переменной (0 - 255), а через float от 0.0 до 1.0 (пример, LinesColor=1.0,1.0,0.0);
WeaponPort1 - параметр для анимации корабля. Устанавливает точку на анимации, из которой будут отрисовываться выстрелы орудий. Всего можно добавить до 10 таких точек (WeaponPort1, WeaponPort2, WeaponPort3 и т.д.). Номер точки, из которой будет произведён следующий выстрел, определяется случайным образом.
  Примечание: Установка орудийных портов работает как для hai, так и для gai анимаций на станциях, но в случае с gai анимациями нулевой точкой отсчёта всегда будет являться центр.
Tail1 - устанавливает точку на анимации, из которой будет отрисован динамический след двигателя корабля. Всего можно установить до 10 таких точек (Tail1, Tail2, Tail3 и т.д.).
  Примечание: Параметры WeaponPort и Tail принимают координаты точки (пикселя) на анимации в формате 'Tail=X,Y'.
SizeSmall - параметр условно минимального визуального размера для данной hai анимации (корабля) в игре;
SizeLarge - параметр условно максимального визуального размера для данной hai анимации (корабля) в игре;
  Базовые значения параметров SizeSmall и SizeLarge для различных видов игровых корпусов:
    Коалиция и пираты:
      Рейнджер: 50 / 80
    Транспорт: 50 / 90
    Лайнер: 50 / 90
    Дипломат: 50 / 90
    Пират: 45 / 80
    Пират фэянин: 55 / 90 (связано с качеством его hai анимации)
    Военный: 45 / 80
    Военный фэянин: 55 / 80 (связано хз с чем)
    Военный флагман: 80 / 130
    Транклюкатор: 40 / 50
    Акриновый корпус (любой): 50 / 80
    Станция: 128 / 128 (все станции по умолчанию используют собственные gai анимации, так что это значение, хотя формально и применяется, особо не актуально)
    По умолчанию для всего остального: 50 / 80
    Доминаторы:
      Клиг: 40 / 60
      Штип: 40 / 60
      Менок: 45 / 65
      Смерш: 60 / 90
      Ургант: 70 / 100
      Эквентор: 110 / 127
      Бертор: 130 / 160
    Босс: 127 / 127 (не используются в игре, т.к. все боссы имеют gai анимации)
  Примечание: При слишком малом или слишком большом размере корпуса возможен выход за указанные диапазоны, условные границы размеров, которые точно соответствуют значениям SizeSmall и SizeLarge по умолчанию это 250 ед. и 2000 ед. соответственно.


Прочие полезные фичи:
  Дополнительные параметры для палитр выстрелов орудий:
    ShotVisual - параметр для акрина в Lang.dat, устанавливает номер палитры (палитра берется из общего списка палитр для оружия данного типа) для оружия, на которое будет наложен данный акрин:
       1 - номер палитры, которую будет устанавливать данный акрин;
    Общие:
    SoundShot - звук выстрела, который заменит стандартный игровой звук для данного орудия, прописывается полным путём в кэше (можно устанавливать отдельно в каждую палитру, а не только в общий раздел с ними);
    SoundExpl - звук разрыва ракеты/торпеды, который заменит стандартный игровой звук для данного орудия, прописывается полным путём в кэше (можно устанавливать отдельно в каждую палитру, а не только в общий раздел с ними);
  Промышленный лазер:
    Width - определяет ширину рисуемого луча (по умолчанию 2, тип int);
    Time - определяет "время жизни" рисуемого луча (по умолчанию 40, тип int);
  Название атрибута для добавления серий корпуса флагманам:
    Flagman - подставляется в раздел конкретной серии в параметр ShipType (не включён в список атрибута Any);
  Дополнительные параметры Main.dat для ракет (раздел 'ML.Missile'):
  Scale - определяет визуальный размер анимации ракеты/торпеды, по умолчанию для всех ракет задан на 1.0;

Различные игровые параметры для бонусов (параметры добавляется в раздел бонуса в Lang, пример: Special=1):
Special - означает, что текущий бонус является акрином (или, по крайней мере, особым ММ), чтобы он не выпадал в списках выдачи ММ на ЦР:
  1 - бонус является акрином или особым ММ;
Color - параметр для указания цвета имени бонуса (ММ или акрина). В отличие от прямого подставления цветовых тэгов в параметр Name, Color полностью меняет имя бонуса во всех подстановках, в т.ч. цвет кавычек ММ после его установки в предмет, пример: Color=41,125,222 (цвета указываются в формате RGB);
Equipments - для акринов обозначает, к какому типу предметов игра будет автоматически применять данный акрин в магазинах, а для ММ, в предметы какого типа может быть установлен данный микромодуль:
  'Any' - аналогичен параметру "по умолчанию" (если Equipments в бонусе не указан) и включает в себя любые типы оборудования и оружия;
     Важно: Если данное значение не занимает всю строку (к примеру записано Equipments=Any,Hull), то в качестве валидного показателя оно засчитано не будет и все необходимые типы предметов придётся указывать вручную.
  'Hull' - бонус может быть применён к любому корпусу;
  'Engine' - бонус может быть применён к любому двигателю;
  'FuelTank' - бонус может быть применён к любому топливному баку;
  'Radar' - бонус может быть применён к любому радару;
  'Scaner' - бонус может быть применён к любому сканеру;
  'Droid' - бонус может быть применён к любому дроиду;
  'Hook' - бонус может быть применён к любому захвату;
  'DefGenerator' - бонус может быть применён к любому ГЗП;
  'WEnergy' - бонус может быть применён к любому энергетическому оружию;
  'WSplinter' - бонус может быть применён к любому осколочному оружию;
  'WMissile' - бонус может быть применён к любому ракетному оружию;
  'W01' - бонус может быть применён к промышленному лазеру;
  'W02' - бонус может быть применён к осколочному орудию;
  'W03' - бонус может быть применён к лезке;
  'W04' - бонус может быть применён к ракетомету;
  'W05' - бонус может быть применён к третону;
  'W06' - бонус может быть применён к волновому фазеру;
  'W07' - бонус может быть применён к потоковому бластеру;
  'W08' - бонус может быть применён к электронному резаку;
  'W09' - бонус может быть применён к мультирезонатору;
  'W10' - бонус может быть применён к атомному визиону;
  'W11' - бонус может быть применён к дезинтегратору;
  'W12' - бонус может быть применён к турбогравиру;
  'W13' - бонус может быть применён к ИМХО-9000;
  'W14' - бонус может быть применён к вертиксу;
  'W15' - бонус может быть применён к торпедному аппарату;
  'W16' - бонус может быть применён к эсодаферу;
  'W17' - бонус может быть применён к кафаситору;
  'W18' - бонус может быть применён к лирекрону;
  'CustomGunTypeName' - бонус может быть применён к указанному кастомному оружию;
Owner - для акринов обозначает, к каким расам игра будет автоматически применять данный акрин в магазинах (актуально только для коалиционных рас и пиратов), а для ММ, в предметы с какой расой может быть установлен данный микромодуль:
  'Any' - аналогичен параметру "по умолчанию" (если Owner в бонусе не указан) и включает в себя все расы, кроме неизвестной;
    Важно: Если данное значение не занимает всю строку (к примеру записано Owner=Any,None), то в качестве валидного показателя оно засчитано не будет и все необходимые расы придётся указывать вручную.
  'Maloc' - добавляет в набор малокскую и доминаторскую расу;
  'Peleng' - добавляет в набор пеленгскую и доминаторскую расу;
  'People' - добавляет в набор человеческую и доминаторскую расу;
  'Fei' - добавляет в набор фэянскую и доминаторскую расу;
  'Gaal' - добавляет в набор гаальскую и доминаторскую расу;
  'PirateClan' - добавляет в набор пиратскую и доминаторскую расу;
  'None' - добавляет в набор неизвестную и доминаторскую расу;
  'Blazer' - ограничивает применение бонусов к доминаторскому оборудованию только блазероидной серией;
  'Keller' - ограничивает применение бонусов к доминаторскому оборудованию только келлероидной серией;
  'Terron' - ограничивает применение бонусов к доминаторскому оборудованию только терроноидной серией;
     Примечание: Ограничительные указатели серий допустимо комбинировать, например как 'Owner=Maloc,Blazer,Terron'.
  'NonKling' - особый указатель, запрещающий установку данного бонуса в любое доминаторское оборудование (как автоматическими скриптовыми функциями, так и вручную игроком);
  Важно: Как бы вы не составляли набор, если в нём отсутствует указатель 'NonKling', доминаторская раса будет неизбежно присутствовать в его составе! Например, строка 'Owner=Maloc' или 'Owner=None' будет фактически расценена игрой как 'Owner=Maloc,Kling' и 'Owner=None,Kling' соответственно. Ограничить же применение бонуса только к доминаторскому оборудованию можно, добавив параметр 'Owner=ewfksdf', где само значение невалидного указателя значения не имеет (с тем же успехом можно писать и 'Owner=Kling'). Если же составить параметр как 'Owner=NonKling', то такой бонус будет запрещён к установке вообще везде.
  Примечание: Строка 'Kling' валидным параметром не является и не проверяется игрой. Вместо неё можно вписывать любой набор букв с точно таким же результатом.
RacialRestriction - блокирует применение бонусов данного крина на представителей иных рас, кроме тех, что указаны в параметре Owner этого же бонуса (использовать такие предметы смогут любые расы, но вот получать от них бонусы будут не все):
  1 - разрешить применение данных бонусов только для представителей определённых рас;
  Примечание: Для ММ этот ограничитель работает иначе, чем для акринов, а именно, запрещает автоматическую установку данного модуля на любые корабли, кроме имеющих указанную в Owner модуля расу (овнера).
BlockMM - запрещает устанавливать микромодуль в предмет с данным акрином (только основным акрином, из спецакрина данный запрет работать не будет):
  1 - установка микромодуля в данное оборудования/корпус запрещена;
BlockImp - запрещает улучшать оборудование/корпус с данным акрином (в том числе в модах EvoSB и ExpTC, из спецакрина этот запрет работать не будет):
  1 - улучшение оборудования/корпуса запрещено;
NamePrefix - параметр только для микромодулей, подменяет имя базовой приставки 'Микромодуль' на любое другое, указанное в строке:
  1 - новое имя приставки;
HullGraphSize - параметр для акрина корпуса в Lang, который меняет визуальный размер этого корпуса (стандартный размер 100, размер флагмана 200);
Fragility - меняет модификатор износа предмета, но имеет обратную зависимость. Fragility=70 (100/70) будет означать замедление скорости износа (предмет получит прочность в 142% от исходной), а Fragility=120 (100/120) - ускорение скорости износа (83% прочности от исходной). При установке бонуса с Fragility в корпус, будет меняться его восприимчивость к урону;
FragilityEnergy - бонус/штраф к восприимчивости к энергетическому урону (только для корпуса);
FragilityMissile - бонус/штраф к восприимчивости к осколочному урону (только для корпуса);
FragilitySplinter - бонус/штраф к восприимчивости к ракетному урону (только для корпуса);
  Примечание: Специализированные Fragility по типам урона записываются в бонус аналогично общему. Если в бонусе для корпуса прописан общий Fragility, то он будет применён сразу на все три типа восприимчивости к урону корпуса. Если в бонусе прописан только специализированный(е) Fragility, то он будет применён только для соответствующего типа сопротивляемости. Если же в бонусе прописан и общий и специализированный Fragility, то для типов урона без указанного специализированного Fragility будет применён общий, а для тех, для которых специализированный указан, специализированный Fragility.
WeaponMods - параметр для добавления дополнительных эффектов в дамагсет оружия через бонусы (ММ или акрины), накладываемые на это орудие (добавлять в виде строки, через запятые и без пробелов):
  'Energy' (1) - энергетический урон;
  'Splinter' (2) - осколочный урон;
  'Missile' (4) - ракетный урон;
  'Decelerate' (8) - снижает скорость цели, технически перегревает её двигатель (эффект Третона);
  'Destruct' (16) - разрушает оборудования цели (эффект Электронного резака);
  'Drain' (32) - восстанавливает по единице структуры за каждую единицу нанесённого урона (100% вампиризм, эффект Третона);
  'Shock' (64) - вешает на цель эффект ионизации (эффект Кафаситора);
  'Acid' (128) - снижает броню цели (эффект Эсодафера);
  'Magnetic' (256) - вешает на цель ЭМ-помехи (которые снижают дальность радара, дальность орудий, мощность сканера и силу ГЗП цели - эффект Лирекрона);
  'DecelerateA' (512) - полный аналог простого замедления 'Decelerate' (эффект артефакта Вжик);
  'DecelerateAEx' (1024) - полный аналог простого замедления 'Decelerate' и 'DecelerateA' (доп. эффект артефакта Вжик в режиме совместимости);
Примечание: Замедления 'Decelerate', 'DecelerateA' и 'DecelerateAEx' полностью идентичны друг другу, однако при совместном использовании кратно увеличивают замедляющий эффект. К примеру, Вжик в режиме совместимости использует одновременно 'DecelerateA' и 'DecelerateAEx', что увеличивает его замедляющий эффект ровно в два раза.
  'Undefendable' (2048) - применяет к цели урон, считающийся отражённым Поляризатором (наносимый урон игнорирует броню и ГЗП, не не резисты);
  'NonLethal' (4096) - применяет эффект, как от непосредственного воздействия ионизации (наносит урон корпусу, но полностью уничтожить корабль не может)
  'ScanBonus' (8192) - повышает урон оружия на 15% (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'BonusToDamaged' (16384) - повышает урон по повреждённой цели вплоть до 33% (если у цели остался 1 HP) в зависимости от степени повреждения цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
    Примечание: kdamage := kdamage * (1 + 0.33 * (1 - FHull.FHitPoints / FHull.FSize));
  'MoreDrop' (32768) - повышает шанс дропа оборудования при уничтожении цели, аналогично ЛВВ (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'DropCargo' (65536) - добавляет 5% шанс дропа товара из трюма при нанесении урона цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'ReduceEngine' (131072) - наносит повреждения двигателю цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'BlockWeapon' (262144) - имеет шанс (обратно пропорционален размеру корпуса цели) блокировки оружия цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'BlockDroid' (524288) - имеет шанс (обратно пропорционален размеру корпуса цели) блокировки дроида цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'NoDelta' (1048576) - отключает разброс урона (оружие с данным эффектом всегда наносит максимальный урон, эффект Эсодафера, не имеет смысла добавлять в дамагсет наносимого урона, т.к. этот эффект применяется только к предмету орудия, а не к самому урону);
Примечание: Эффекты 'Shock', 'Acid' действуют на доминаторов слабее, эффект 'Magnetic' действует сильнее, а эффект 'Destruct' не действует на них совсем.

Кастомные параметры для бонусов:
UniqueMM - параметр, обозначающий, что данный бонус является микромодулем, хотя и имеет тэг Special, необходим исключительно для маркировки уникальных микромодулей:
  1 - данный бонус является уникальным микромодулем и может быть получен лишь единожды раз за всю партию;
  2 - данный бонус является особым микромодулем, но может быть получен неограниченное количество раз (полезно для маркировки особых ММ, которые не должны попадать в стандартную выдачу ЦР);
LockedAcryn - запрещает накладывать/снимать бонус с оборудования в моде ExpScienceRanks:
  1 - запрещено снимать;
  2 - запрещено накладывать;
  3 - запрещено накладывать и снимать;
BlockReacryn - запрещает реакринировать предметы, в которых имеются микромодули с данным маркером в моде ExpScienceRanks:
  1 - запрещено деакринировать;
  2 - запрещено акринировать;
  3 - запрещено акринировать и деакринировать;
ScriptItemIgnore - параметр, снимающий ограничение на извлечение ММ и улучшение (в модах EvoSB и ExpTC) скриптового предмета. По умолчанию из скриптовых предметов нельзя вынимать ММ / улучшать их, дабы исключить возможность их утери, но данный параметр такое ограничение снимает (в теории можно использовать и для других аналогичных проверок, подразумевающих возможную утерю/изменение предмета):
  1 - данный скриптовый предмет с акрином может быть безбоязненно уничтожен/изменён скриптом;
BMSpawnCondition - параметр только для микромодулей, задаёт условие, при котором данный ММ сможет появиться в магазине ЧР, если задать как BMSpawnCondition=0, то данный ММ на ЧР появляться не будет (для мода ExpBlackMarket):
  1 - обязательное условие для появления данного ММ в магазине ЧР (по умолчанию в магазине ЧР может появиться любой ММ в любое время);
NotRemovable - параметр только для микромодулей, запрещает извлечение ММ в моде EvoSB:
  1 - данный микромодуль невозможно извлечь (с помощью этого тэга можно создавать модули-затычки);
NonSearchable - блокирует занесение этого бонуса в список доступных для автопоиска в моде ExpAutoSearch:
  1 - бонус не будет отображаться в списке поиска (имеет смысл блокировать особые акрины, которые в любом случае никак не могут попасть в магазин);
  2 - акрин, имитирующий отсутствие акрина (предмет с ним будет считаться модом ExpAutoSearch как предмет без акрина вовсе);
NonRepairable - блокирует возможность ремонта оборудования/корпуса с данным бонусом на всех базах в моде ExpRepair:
  1 - ремонт запрещён;
NoBridge - параметр только для акринов на корпуса, запрещает добавлять на корпус с данным акрином мостик из мода ExpPilotBridge:
  1 - мостик на корпус с данным акрином добавляться не будет;
BioEquip - параметр, помечающий данное оборудование как биологическое (например, биогенные дроиды), что полезно для блокировки некоторых бонусов:
  1 - оборудование является биологическим объектом;
AcrynSerie - имя, подходящее сразу всей линейке оборудования, имеющего акрины нескольких уровней (I, II, III и т.д.) При установке данного параметра, оборудование будет считаться многоуровневым, что желательно для нормальной работы мода ExpScienceRanks;
SerieLevelN - где N означает номер уровня данного акрина (в разделе бонуса указывать как SerieLevel1, SerieLevel2 и т.д.) SerieLevelN напрямую связан с параметром AcrynSerie. В этом параметре должно быть указано имя раздела Lang, в котором записывается данный бонус.
  Пример: SerieLevel1=374 - соответствует бонусу "Миоплазменный двигатель I";
AcrynLevel - указатель на конкретный уровень акрина в его серии;
LevelsCount - число, обозначающее общее количество уровней данного акрина (2, 3, 4 и т.д.) Все три последних параметра требуются для нормальной работы механики акринации в моде ExpScienceRanks;
  Примечание: Параметр добавляется в общий раздел бонуса, пример: LockedAcryn=3
ForNPCTypes - параметр для индикации типов NPC, которым подходит акриновый корпус с данным параметром (используется в моде ShuRangersAcryns), пример: ForNPCTypes=Ranger,RangerExplorer,RangerPirateExplorer (обозначает акрин для всех стандартных типов рейнджеров);
ForCharacterTypes - параметр для обозначения, каким типам характеров рейнджеров NPC подходит данный корпус (имеет смысл использовать только в связке с ForNPCTypes):
  'Warrior' - корпус подходит для рейнджеров воинов;
  'Trader' - корпус подходит для рейнджеров торговцев;
  'Pirate' - корпус подходит для рейнджеров ренегатов;
  Примечание: Допустимо указывать сразу несколько типов. По умолчанию (при отсутствии параметра) будет считаться, что корпус подходит сразу для всех типов.
ImitatedHullType - тэг для акринов на корпуса, отмечающий, какой оригинальный тип корпуса имитирует данный акрин (если нужна имитация), что имеет значение в запросах автопоиска из мода ExpAutoSearch (можно указать сразу несколько подходящих типов через запятую без пробелов):
  'Ranger' - корпус рейнджера;
  'Warrior' - корпус военного;
  'Pirate' - корпус пирата;
  'Transport' - корпус транспорта;
  'Liner' - корпус лайнера;
  'Diplomat' - корпус дипломата;
  'Flagman' - корпус флагмана;
ImitatedEquipType - параметр, необходимый для подмены предмета в момент его деакринации в моде ExpScienceRanks, а также для изменения вывода поиска в моде ExpAutoSearch. Позволяет указать тип необходимого оружия/оборудования на которое должен быть заменён деакринируемый предмет:
  1 - тип оборудования/оружия строкой вида t_Engine, t_Weapon4 и т.д.;
ActualEquipType - параметр, необходимый для подмены предмета в момент его акринации в моде ExpScienceRanks, а также для изменения вывода поиска в моде ExpAutoSearch (обязательно должен быть поставлен в пару к ImitatedEquipType). Позволяет указать тип необходимого оружия/оборудования на которое должен быть заменён акринируемый предмет:
  1 - тип оборудования/оружия строкой вида t_Engine, t_Weapon4 и т.д.;
  Примечание: Для кастомного оружия типа t_CustomWeapon необходимо через запятую указать имя конкретного типа, пример: ActualEquipType=t_CustomWeapon,MissileLauncherTorpedo


Кастомные функции из мода UtilityFunctionsPack (для использования их в своём скрипте, нужно сперва подключить библиотеку к конкретному скрипту через Main, а для использования в интерфейсном, Act или Use коде, необходимо использовать функцию ImportAll(), либо ImportedFunction()):
UtilityFunctionsLibInit - используется для разовой передачи в либу указателя на объект игровой галактики, и инициализации необходимых для работы ряда функций переменных, но сама по себе не имеет практического применения в скриптах:
  1 - указатель на текущую глобальную переменную игровой галактики (GalaxyPtr());
GetGalaxyGenerationSeed - без аргументов, возвращает зерно, по которому была сгенерирована текущая игровая галактика;
GetSectorAdjacentToDicea - без аргументов, возвращает сектор, смежный с пиратским скрытым сектором (имеется в виду сектор, внутри которого со старта замаскирована Дицея), для возможности возврата этот смежный сектор должен быть закрыт на Галакарте;
RoundTo - округляет любое указанное число к любому другому указанному числу (включая дробные):
  1 - округляемое число;
  2 - к какому числу округлять;
  3 - как именно выполнить округление:
    -1 - к меньшему;
     0 - обычное округление (не банковское);
     1 - к большему;
     2 - банковское округление;
     3 - к ближайшему нечётному при среднем значении (короче как банковское, но наоборот);
Exponent - возводит число X в степень Y (допускаются дробные):
  1 - число X;
  2 - число Y;
TrimNumbers - удаляет все числовые символы из строки:
  1 - строка;
DistCoords - считает и возвращает расстояние между двумя точками по их координатам:
  1 - координата X первой точки;
  2 - координата Y первой точки;
  3 - координата X второй точки;
  4 - координата Y второй точки;
PortionInDiapason - переводит указанное значение из одного диапазона в другой:
  1 - текущее значение (число);
  2 - начало диапазона, в котором находится текущее значение;
  3 - конец диапазона, в котором находится текущее значение;
  4 - начало диапазона, в который нужно перевести значение;
  5 - конец диапазона, в который нужно перевести значение;
  Пример: PortionInDiapason(3, 1, 10, 1, 20); переведёт 3 из диапазона 1-10 в диапазон 1-20 и в итоге вернёт нам 6. А в случае, если текущее значение выйдет за рамки первого диапазона (например, равно 11), вернёт максимальную или минимальную величину второго диапазона (то есть 20, если текущее значение равно 11).
ParsCountFromString - считает и возвращает общее число параметров в строке через указанные разделители (если строка пуста, вернёт 0):
  1 - строка;
  2 - разделитель;
  Пример: Запрос ParsCountFromString('A --B --C ', '--') вернёт 3, а запрос ParsCountFromString('A', '--') вернёт 1.
GetParFromString - разбивает строку через разделители и возвращает отрезок под указанным номером (при выходе номера за диапазон вернёт ''):
  1 - строка;
  2 - разделитель;
  3 - номер отрезка, который необходимо вернуть, начиная с 0;
  4 - маркер очистки пробелов и табуляций в возвращаемой строке:
     0 - не убирать пробелы и табуляции;
     1 - убирать пробелы и табуляции только в начале и в конце строки;
     2 - убирать пробелы и табуляции из всей строки (в т.ч. из середины);
  Пример: Запрос GetParFromString('A --B --C ', '--', 1, 1) вернёт 'B'. При передаче отрицательного номера параметра, минус автоматически отбрасывается.
SetParFromString - меняет параметр в строке с разделителями и возвращает пересобранную строку:
  1 - строка;
  2 - разделитель;
  3 - номер отрезка, который необходимо заменить, начиная с 0;
  4 - новое значение параметра (отрезок);
  Пример: Запрос SetParFromString('A,B,C', ',', 1, 'D') вернёт 'A,D,C'. Если номер отрезка больше общего количества параметров в строке, то переданный параметр будет добавлен в конец. Если в строке вовсе отсутствуют указанные разделители, то переданный параметр будет добавлен в начало (если указан номер 0), либо в конец (если указано что-то кроме 0) строки.
GetParFromTxt - возвращает значение определённого параметра (в виде строки) из указанного txt-файла:
  1 - путь и название txt-файла из корня папки "Мои документы", например: 'SpaceRangersHD\ModsCFG.txt' //или '\..\..\..\..\ModCFG.txt';
  2 - название параметра строкой;
SetParFromTxt - записывает указанный параметр и его значение (если параметр с таким именем в конфиге уже есть, то просто изменит его значение) в указанный txt-файл, который расположен в основной папке пользовательских документов (возвращает старое значение изменяемого параметра, либо '', если параметр пуст, либо отсутствует):
  1 - путь и название txt-файла, начиная из корня папки "Мои документы", например: 'SpaceRangersHD\ModsCFG.txt' //или '\..\..\..\..\ModCFG.txt';
  2 - название параметра строкой (Важно: Не используйте в имени параметра символы '=' и '\n'!);
  3 - значение параметра строкой;
GetStringFromClipboard - без аргументов, возвращает строку из системного буфера обмена (если в буфере не оказалось строки, то вернёт '');
SendStringToClipboard - записывает (удаляя содержимое) указанную строку в системный буфер обмена:
  1 - строка;
  Примечание: Казалось бы, функция не особо полезная, однако если сделать вот так: SendStringToClipboard(GenerateCodeStringFromBlock('ActCodeBlocksList.CodeName')), то можно легко получить в буфер исполняемую строку, в которой можно без проблем найти символ под любым номером, а по нему уже с лёгкостью отследить любой ненавистный Exception Compiler. Error=0,N. Очень намучился с поиском таких ошибок, а оказалось, что искать их всё-таки не сложно.
IsShiftCtrlPressed - без аргументов, проверяет, нажаты ли сейчас обе клавиши Shift+Ctrl и возвращает 1, если нажаты, и 0, если нет;
RndObject - функция, по функционалу аналогичная Rnd(), однако использующая в качестве зерна рандомизации не общее галактическое зерно, а индивидуальное зерно конкретного объекта, что может быть полезно, если вы не хотите, чтобы любая незначительная операция влияла на исход событий во всем игровом мире (при включении ТН на полный рандом будет всегда выдавать случайный результат):
  1 - нижняя граница диапазона;
  2 - верхняя граница диапазона (границы могут быть отрицательными);
  3 - объект, зерно которого будет использовано для данного броска, возможные типы (при передаче неподходящего объекта вернёт 0):
     - Звезда;
     - Планета;
     - Станция;
     - Корабль;
ShipSubrace - возвращает или устанавливает серию доминатора:
  1 - корабль доминатора (при получении не доминатора вернёт -1);
  2 - какую серию установить (вернёт серию до изменения, при получении значения меньше 0 вернёт текущую серию):
     0 - блазероидная;
     1 - келлероидная;
     2 - терроноидная;
     6 - клисане, кастомная серия из мода ShuKlissan;
     3-255 (кроме 6) - все прочие возможные серии, не используемые в ваниле;
ShipNearbyShips - возвращает корабль/станцию на определённом удалении от указанного корабля/станции (если не обнаружит кораблей по указанным категориям поиска - вернёт 0):
  1 - корабль/станция (должен находиться в открытом космосе, иначе вернётся 0);
  2 - на каком удалении от него вернуть другой корабль/станцию (под номером 0 здесь всегда числится исходный корабль, а если указать -1, вернёт общее число кораблей, подходящих по приведенному ниже фильтру, без учёта исходного корабля (хотя, фактически, он всё равно будет стоять в массиве под нулевым номером));
  3 - маркер повторного запроса:
     0 - произвести новый расчёт с перезаполнением массива кораблей по удалённости от указанного;
     1+ (любое значение, кроме 0) - запросить корабль по удалённости от указанного из уже заполненного массива (если массив пуст, либо переданный номер выходит за границы заполненного диапазона, вернёт 0);
  4 - что именно возвращать (можно указать конкретный сет из ShipTypeN() кораблей, либо общие критерии):
    -2 - возвращать только станции;
    -1 - возвращать только корабли;
     0 - возвращать любые корабли и станции;
     1+ - возвращать только корабли и станции с указанными ShipTypeN() (данный фильтр задаётся в виде сета):
        t_Kling - 1
      t_Ranger - 2
      t_Transport - 4
      t_Pirate - 8
      t_Warrior - 16
      t_Tranclucator - 32
      t_RC - 64
      t_PB - 128
      t_WB - 256
      t_SB - 512
      t_BK - 1024
      t_MC - 2048
      t_CB - 4096
      t_UB - 8192
  5 - фильтр кастомных строковых типов с перечислением через запятую, где значение '' расценивается как отключение фильтра (для флагманов здесь используется фильтр 'WarriorBig');
  6 - фильтр кастомных фракций с перечислением через запятую, где значение '' расценивается как отключение фильтра, а значение '!', как необходимость добавления только кораблей без кастомной фракции (корабли со значением фракции 'SubFactionFixedStanding' расцениваются как корабли без фракции), если необходимо добавить в поиск корабли с определённой фракцией и все корабли без неё, фильтр необходимо строить как '!,Klissan';
  Примечание: После каждого нового запроса, в библиотеке создаётся массив с кораблями по номерам удалённости от указанного корабля. При необходимости сделать перебор некоторого числа ближайших к указанному кораблю целей, необязательно пересчитывать их местоположение снова и снова. Маркер повторного запроса просто вернёт корабль под указанным номером из уже построенного массива, что позволяет повысить оптимизацию. При использовании повторного запроса, все прочие аргументы функции, кроме номера удалённости цели, будут игнорироваться.
  Примечание: Корабли на планетах, станциях и в гипере функцией не учитываются.
GetShipScriptName - возвращает название скрипта, группы, а также название стейта, в которые занесён указанный корабль (если корабль не в скрипте, вернёт '');
  1 - корабль (любой, кроме игрока, для которого функция вернёт '');
  2 - что конкретно вернуть:
     0 - вернуть только название скрипта;
     1 - вернуть только название группы;
     2 - вернуть только название стейта;
     3 - вернуть название скрипта, название группы и название стейта в формате 'ScriptName.GroupName.StateName';
ShipJoinToScript - добавляет корабль в указанную скриптовую группу указанного скрипта (также может просто менять его текущий стейт), при этом не вызывая моментального исполнения кода из этого стейта (если корабль уже находится в какой-либо другой скриптовой группе, перед добавлением он будет выведен из неё автоматически):
  1 - корабль (любой, кроме игрока, для которого функция не сработает);
  2 - путь к скриптовой группе вида 'ScriptName.GroupName.StateName' (имя скрипта и название группы строкой, имя стейта в конце является опциональным, если его не указывать, то добавит корабль в базовый стейт указанной группы);
GetScriptNoKlingMarksFromStar - возвращает все скрипты, блокирующие систему от захвата посредством метки NoKling (можно выставить только из RScript) и/или метки NoComeKling в формате строки через запятую:
  1 - система, которую необходимо проверить на блокировку (вернёт имена блокирующих скриптов и маркеры, либо пустую строку):
     1 - маркер, что указанный скрипт повесил на систему маркер NoKling;
     2 - маркер, что указанный скрипт повесил на систему маркер NoComeKling;
     3 - маркер, что указанный скрипт повесил на систему оба маркера NoKling и NoComeKling;
  Примечание: Если будут обнаружены блокирующие скрипты, они вернутся в формате: 'ScriptName.1,ScriptName.3' (число через точку указывает маркер) и т.д., а если блокирующих указанную систему скриптов нет, будет возвращена пустая строка. Общий маркер, который вешается на саму звезду с помощью функции NoComeKlingToStar(), данная функция не возвращает.
GetPlanetOrbitProbe - возвращает число планетарных орбит под размещение зондов, либо возвращает/изымает конкретный зонд, размещённый на указанной орбите (если на указанной орбите зонда нет, вернёт 0):
  1 - планета;
  2 - номер орбиты, с которой необходимо вернуть зонд (если хотите вернуть только число доступных орбит, укажите здесь любое число меньше 0);
  3 - маркер о необходимости изъять зонд с указанной орбиты (0 - не изымать (просто вернуть указатель на зонд), 1 - изъять);
  Примечание: Данная функция не вызывает автоматического обновления уведомления об имуществе игрока. После изъятия зонда рекомендуется хотя бы промежуточно перемещать его на любой склад, чтобы такое обновление уведомления произошло.
CustomArtCostCalc - функция для определения случайной стоимости кастомного артефакта по заданной формуле с учётом текущей сложности и ГТУ:
  1 - базовое значение (рекомендуемый диапазон от 1000 (очень дешёвый арт) до 3000 (очень дорогой арт));
CustomArtSizeCalc - функция для определения случайного веса кастомного артефакта по заданной формуле с учётом текущей сложности игры:
  1 - минимальный вес (для сложности в 50%);
  Примечание: Обе эти функции не могут вернуть значение ниже 1.


Вызов скрипта и всё с этим связанное:
GRun - без аргументов, запускает текущий скрипт (работает только из глобал-кода скрипта);
ScriptRun - запускает скрипт с конкретным именем (возвращает 1, если скрипт успешно запущен):
  1 - система запуска;
  2 - планета запуска;
  3 - имя скрипта строкой;
GCntRun - возвращает количество запусков скрипта за текущую игровую партию:
  1 - имя скрипта строкой (удобно подставлять переменную GScriptName);
GLastTurnRun - возвращает ход, когда скрипт был запущен в последний раз (если скрипт ещё не запускался, вернёт 0):
  1 - имя скрипта строкой (удобно подставлять переменную GScriptName);
  Опционально:
  2 - новое значение (по умолчанию возвращает 0), которое будет возвращать данная функция в случае, если указанный скрипт ещё не запускался;
IsScriptActive - проверяет, существует и активен ли указанный скрипт:
  1 - имя скрипта строкой;
GAllCntRun - возвращает общее количество активных скриптов;
  Без аргументов - вернёт общее количество всех активных скриптов;
  Опционально:
  1 - номер типа скрипта (прописывается при объявлении скрипта в Main), вернёт количество активных скриптов с данным классом;
GScriptName - глобальная переменная, в которую записывается имя исполняемого в данный момент скрипта;
GRunFrom - глобальная переменная для определения состояний местонахождения игрока. Используется для запуска глобального кода во всех скриптах (а точнее принимает определённое значение при каждом срабатывании глобального кода) и может быть использована для точного определения времени запуска. Возможные значения переменной:
  0 - выставляется после совершения посадки игроком;
  1 - выставляется перед взлётом игрока;
  2 - выставляется после начала прыжка (на входе игрока в гипер);
  3 - выставляется перед завершением прыжка (на выходе игрока из гипера);
  Примечание: Подставляйте эту переменную с проверкой определённого состояния в условие перед стартом скрипта, если вы хотите, чтобы ваш скрипт стартовал в строго определённое время.


Сектор:
ConName - возвращает имя сектора:
  1 - сектор;
StarToCon - возвращает сектор системы:
  1 - система;
ConNear - проверяет находятся ли сектора, перечисленные начиная со второго аргумента, рядом с сектором, указанным в первом аргументе:
  1 - целевой сектор;
  2, 3, 4... - сектора для проверки;
ConStars - возвращает общее количество систем в секторе:
  1 - сектор;
ConStar - возвращает определённую систему сектора:
  1 - сектор;
  2 - номер системы в списке систем этого сектора;
GalaxySectors - возвращает общее количество секторов в Галактике или конкретный сектор из списка по его номеру (начиная с 0):
  Без аргументов - вернёт общее количество секторов в Галактике;
  Опционально:
  1 - номер сектора (всегда равен Id сектора минус 1);
SectorVisible - проверяет, есть ли у игрока карты указанного сектора, или открывает его:
  1 - сектор;
  Опционально:
  2 - если значение != 0 то открыть сектор (при открытии скрытого пиратского сектора, также будут отрисованы и до того скрытые границы между);


Система:
StarName - возвращает имя системы:
  1 - система (тип данных str);
GalaxyStars - без аргументов, возвращает общее количество систем в Галактике;
GalaxyStar - возвращает определённую систему по её номеру (начиная с 0):
  1 - номер системы в списке систем Галактики (всегда равен Id системы минус 1);
StarAngleBetween - угол, образованный тремя системами;
StarAngle - угол, определяющий направление от одной системы, к другой;
Dist2Star - возвращает квадрат числа парсек между двумя системами на галакарте (для получения реального игрового числа парсек между ними необходимо применить формулу: round(sqrt(Dist2Star(star1, star2)))):
  1 - первая система;
  2 - вторая система;
StarOwner - возвращает или устанавливает текущего владельца системы:
  1 - система;
  Опционально:
  2 - установить нового владельца:
    0 - Коалиция;
    1 - доминаторы;
    2 - пираты;
  Примечание: Для полноценной смены владельца системы вручную, нужно также поменять и владельца всех её населённых планет.
StarCustomFaction - возвращает или устанавливает текущего кастомного владельца системы в виде строки (например, 'Klissan'):
  1 - система;
  Опционально:
  2 - какое имя фракции установить;
  Примечание: Сразу же при снятии с системы кастомной фракции, хардкод автоматически переведёт её под контроль той ванильной фракции, которая, по его мнению, должна владеть системой в данный момент. Вывода уведомления об освобождении в этом случае не будет. Все планеты в системе кастомной фракции автоматически переходят под контроль кастомной фракции, а при её снятии переходят обратно под контроль текущей доминирующей в системе фракции.
ControlledSystems - возвращает количество систем, контролируемых одной из сторон конфликта в данный момент:
  1 - сторона конфликта:
     0 - Коалиция;
     1 - доминаторы;
     2 - пираты;
DeltaWin - возвращает или изменяет скрытый показатель общей галактической силы стороны, её "дельту":
  1 - сторона конфликта:
     0 - Коалиция;
     1 - доминаторы;
     2 - пираты;
  Опционально:
  2 - какую "дельту" установить данной стороне (жёстких лимитов нет, но, например, при активном захвате доминаторами множества систем подряд их "дельта" может дорасти до нескольких десятков);
  Примечание: Данный показатель регулярно меняется по ходу игры при переходе систем от одной стороны к другой. Крайне не рекомендуется вручную задавать значения данных параметров, т.к. это может привести к полому ключевой игровой механики. Используйте ручное выставление "дельты" только если вы точно уверены в том, что делаете.
StarBattle - проверяет, идёт ли в системе бой:
  1 - система;
StarSeries - возвращает или устанавливает серию доминаторов, владеющую системой (или владевшую ей ранее):
  1 - система;
  Опционально:
  2 - новая серия доминаторов:
     0 - Блазер;
     1 - Келлер;
     2 - Террон;
  Примечание: Смена серии всей системы на данный момент единственный способ изменить серию для спавна доминатора конкретной серии с помощью BuyDomik() или BuyDomikExtremal().
StarNearbyStars - возвращает систему на определённом удалении от исходной:
  1 - исходная система;
  2 - номер по удалённости для возврата другой системы (на нулевом номере находится сама исходная система);
  Примечание: Очень удобно использовать для перебора ближайших к игроку систем. Всего в Галактике имеется 73 системы, включая ту, от которой будет вестись отчёт под нулевым номером.
StarNearbyStarsDist - то же самое, но возвращает не саму звезду, а расстояние до неё в парсеках;
DistToNearestEnemySystem - возвращает расстояние от системы до ближайшей доминаторской системы:
  1 - система;
StarEnemyThreatLevel - возвращает текущий уровень угрозы, нависший над системой:
  1 - система:
    Уровни угрозы:
      0 - система под контролем Коалиции или пиратов, угрозы нет;
      1 - система под контролем Коалиции или пиратов, но в гипере к ней уже направляются доминаторы или враждебная кастомная раса;
      2 - система под контролем Коалиции или пиратов, и в ней идёт бой (кого и с кем не имеет значения);
    3 - система находится под контролем доминаторов или враждебной кастомной расы (будет всегда возвращать 3, пока систему не отобьют Коалиция или пираты);
  Опционально:
  2 - если стоит маркер 1, то добавить в условие проверки ещё и пиратов в качестве враждебной расы:
    Уровни угрозы:
      0 - система под контролем Коалиции, угрозы нет;
      1 - система под контролем Коалиции, но в гипере к ней уже направляются доминаторы, враждебная кастомная раса или пираты;
      2 - система под контролем Коалиции, и в ней идёт бой (кого и с кем не имеет значения);
    3 - система находится под контролем доминаторов, враждебной кастомной расы или пиратов (будет всегда возвращать 3, пока систему не отобьют Коалиция или пираты);
StarFonImage - установка фона системы:
  1 - ссылка на систему;
  2 - номер нового фона (брать из CacheData раздел BGO, указывать только номер);
StarSetGraph - установка новой визуальной оболочки звезды:
  1 - звезда;
  2 - путь к новой звезде в Main.dat по пути 'Data.SE.Star. ...';
  Примечание: Оригинальная графика остаётся прежней, но поверх неё догружается дополнительная анимация (нужно подтверждение).


Планеты:
PlanetToStar - возвращает систему планеты:
  1 - планета;
AddPlanetNews - добавляет новую галановость в инфоцентре:
  1 - текст галановости;
  Опционально:
  2 - тип добавляемой новости числом, список существующих оригинальных типов ниже (по умолчанию выбирается 0);
  Примечание: Можно задавать свои кастомные типы под номерами с 46 по 255.
PlanetNews - без аргументов, возвращает общее число текущих галановостей в инфоцентре;
  Примечание: Для проверки свежих новостей желательно делать перебор от конца к началу, если только вам, по каким-то причинам, не нужно проверить все текущие новости в инфоцентре.
PlanetNewsDate - возвращает дату галановости:
  1 - номер галановости;
PlanetNewsType - возвращает тип галановости числом:
  1 - номер галановости, возможные типы:
      0 (GalaxyNews) - неопознанная кастомная новость, добавленная через AddPlanetNews();
      1 (RevoltAnarchy) - на какой-то планете установилась анархия;
    2 (RevoltDictatorship) - на какой-то планете установилась диктатура;
    3 (RevoltMonarchy) - на какой-то планете установилась монархия;
    4 (RevoltRepublic) - на какой-то планете установилась республика;
    5 (RevoltDemocracy) - на какой-то планете установилась демократия;
    6 (MineralDeposit) - на какой-то планете имеются большие запасы дешёвых минералов;
    7 (NeedMineral) - на какой-то планете наблюдается острая нужда в минералах;
    8 (ManyArms) - на какой-то планете имеются большие запасы дешёвого оружия (товаров);
    9 (NeedArms) - на какой-то планете наблюдается острая нужда в оружии (товаров);
     10 (ManyTechnics) - на какой-то планете имеются большие запасы дешёвой техники (товаров);
     11 (ManyFood) - на какой-то планете имеются большие запасы дешёвых продуктов (одновременно в этом же типе новости может наблюдаться ещё и нехватка техники);
     12 (NeedFood) - на какой-то планете наблюдается острая нужда в продуктах (одновременно в этом же типе новости может наблюдаться ещё и нехватка медикаментов);
     13 (ManyMedicine) - на какой-то планете имеются большие запасы дешёвых медикаментов;
     14 (ManyLuxury) - на какой-то планете имеются большие запасы дешёвой роскоши;
     15 (NeedLuxury) - на какой-то планете наблюдается острая нужда в роскоши;
     16 (ManyAlcohol) - на какой-то планете имеются большие запасы дешёвого алкоголя;
     17 (NeedAlcohol) - на какой-то планете наблюдается острая нужда в алкоголе;
     18 (StarTransport) - в какой-то системе промышляет слишком много транспортников;
     19 (StarPiratesMany) - в какой-то системе промышляет слишком много пиратов;
     20 (StarPiratesSome) - в какой-то системе промышляет некоторое количество пиратов;
     21 (StarPiratesNone) - в какой-то системе были истреблены все пираты;
     22 (StarRangers) - в какой-то системе промышляет слишком много рейнджеров;
     23 (StarBestRanger) - в какую-то систему нагрянул рейнджер, числящийся лучшим воином, торговцем или пиратом;
     24 (StarKlingAttack) - на какую-то систему напали доминаторы;
     25 (StarKlingLost) - нападение доминаторов на какую-то систему было успешно отражено;
     26 (GroupWarriorLiberator) - военные готовят операцию по освобождению системы (без участия ВБ);
     27 (StarPiratesAttack) - на какую-то систему напали пираты;
     28 (StarPiratesLost) - нападение пиратов на какую-то систему было успешно отражено;
     29 (StarNormalsCaptureKlings) - Коалиция отбила систему у доминаторов;
     30 (StarNormalsCapturePirates) - Коалиция отбила систему у пиратов;
     31 (StarPiratesCaptureKlings) - пираты отбили систему у доминаторов;
     32 (StarPiratesCaptureNormals) - пираты отбили систему у Коалиции;
     33 (StarKlingsCaptureNormals) - доминаторы отбили систему у Коалиции;
     34 (StarKlingsCapturePirates) - доминаторы отбили систему у пиратов;
     35 (CoalitionDefeated) - Коалиция была полностью разгромлена;
     36 (NewBlackHole) - где-то открылась новая "чёрная дыра" (червоточина);
     37 (EminentWarrior) - новость о присвоении какому-то рейнджеру статуса "Отличившийся воин";
     38 (EminentTrader) - новость о присвоении какому-то рейнджеру статуса "Выдающийся делец";
     39 (EminentPirate) - новость о присвоении какому-то рейнджеру статуса "Злейший пират";
     40 (RangerImprisoned) - какой-то рейнджер загремел в тюрьму;
     41 (NewStation) - была построена новая станция;
     42 (Investment) - игрок пожертвовал/профинансировал деньги нуждающимся рейнджерам, пиратам, семьям или ещё куда-нибудь;
     43 (ProgramResearched) - завершилось исследование одной из ключевых антидоминаторских разработок;
     44 (SpecialShip) - был построен один из особых корпусов из оригинальной игры (Перезагрузки) - Скала, Болид или Убийца;
     45 (WBJumpPlanned) - какая-то военная база готовит операцию по освобождению системы;
PlanetNewsText - возвращает или меняет текст указанной галановости:
  1 - номер галановости (начиная с 0);
  Опционально:
  2 - новый текст;
  Примечание: Изменение текста галановости не меняет её тип.
GetRelationPlanet - возвращает отношение планеты к кораблю (не только к рейнджеру, но для всех прочих типов и рас отношение планеты фиксированное):
  1 - планета;
  2 - корабль;
PlanetName - возвращает имя планеты:
  1 - планета (тип данных str);
IdToPlanet - возвращает планету по её Id:
  1 - Id планеты;
PlanetGetGraph - возвращает анимацию планеты в космосе из Main.dat (раздел 'Data.SE.Planet'):
  1 - планета (вернёт номер анимации в виде str, пример '001');
PlanetSetGraph - меняет анимацию планеты в космосе из Main.dat (раздел 'Data.SE.Planet'):
  1 - планета;
  2 - путь к новой анимации планеты, передавать в виде номера анимации как str (пример: '001'), либо int;
FindPlanet - ищет планету в системе по заданным характеристикам:
  1 - система;
  2 - фильтр расы строкой (можно указывать несколько значений через запятую без пробелов, а если фильтр не нужен, просто оставить пустым ''):
     'NotMaloc' - не малокская;
     'NotPeleng' - не пеленгская;
     'NotPeople' - не человеческая;
     'NotFei' - не фэянская;
     'NotGaal' - не гаальская;
     'NotKling' - не доминаторская;
     'NotPirateClan' - не пиратская;
     'NotNone' - не незаселённая;
  3 - первая относительная граница расположения планеты внутри системы, где 0 - центр системы, а 100 - самый её край;
  4 - вторая относительная граница расположения планеты внутри системы;
    Примечание: При указании третьего и четвёртого аргумента как '0,100', поиск будет выбирать любые существующие в системе планеты, а при указании этих же аргументов как, например, '33,66', будут подбираться лишь планеты со средним удалением от звезды, и т.д.
NearCivilPlanet - возвращает ближайшую к кораблю/станции обитаемую планету в системе, где он находится:
  1 - корабль/станция;
  Примечание: Если система находится под контролем безусловно враждебной фракции (например, доминаторов) и все обитаемые планеты захвачены, то вернёт 0.
StarPlanets - возвращает количество планет в системе, или конкретную планету в ней:
  1 - система (вернёт количество);
  Опционально:
  2 - номер планеты в списке планет системы (вернёт планету);
GotoGov - принудительно переводит игрока на форму правительства ('Gov' для заселённых планет и 'RuinsTalk' для станций) и устанавливает запрет на её покидание:
  Без аргументов - проверить, установлен ли запрет на покидание правительства;
  Опционально:
  1 - установить/снять запрет:
     0 - отпустить игрока;
     1 - разово перевести игрока в правительство (сработает только если игрок уже не находится там);
     2 - перевести в правительство (сработает только если игрок уже не находится там) и установить запрет на его покидание;
PlanetOwner - возвращает текущую расу-владельца планеты или устанавливает её:
  1 - планета;
  Опционально:
  2 - какого владельца назначить:
     0 или (Maloc) - малоки (Коалиция);
     1 или (Peleng) - пеленги (Коалиция);
     2 или (People) - люди (Коалиция);
     3 или (Fei) - фэяне (Коалиция);
     4 или (Gaal) - гаальцы (Коалиция);
     5 или (Kling) - доминаторы (Доминаторы);    
     6 или (None) - незаселённая;
     7 или (PirateClan) - пиратский клан (Пираты);
PlanetRace - возвращает или устанавливает коренную расу планеты:
  1 - планета;
  Опционально:
  2 - какую расу установить:
     0 (Maloc) - малоки;
     1 (Peleng) - пеленги;
     2 (People) - люди;
     3 (Fei) - феяне;
     4 (Gaal) - гаальцы;
PlanetGov - возвращает или устанавливает форму правления на планете:
  1 - планета;
  Опционально:
  2 - какую форму правления установить:
     0 - анархия;
     1 - диктатура;
     2 - монархия;
     3 - республика;
     4 - демократия (на самом деле это больше политический строй, а не форма правления - добавлен в перечень форм правления по ошибке);
PlanetEco - возвращает или устанавливает тип экономики планеты:
  1 - планета;
  Опционально:
  2 - какой тип установить, типы экономики:
     0 - аграрная;
     1 - смешанная;
     2 - индустриальная;
PlanetPirateClan - без аргументов, возвращает Роджерию;
GetShipHomePlanet - возвращает родную планету корабля:
  1 - корабль;
PlanetTerrain - возвращает и устанавливает исследуемые территории незаселённой планеты:
  1 - планета;
  2 - тип местности (0 - вода, 1 - равнины, 2 - горы);
  Опционально:
  3 - какую площадь указанной местности установить планете;
PlanetTerrainExplored - возвращает или устанавливает уже исследованные территории незаселённой планеты:
  1 - планета;
  2 - тип местности (0 - вода, 1 - равнины, 2 - горы);
  Опционально:
  3 - какую часть территории указанной местности сделать исследованной;
PlanetOrbitRadius - возвращает или устанавливает радиус орбиты планеты:
  1 - планета;
  Опционально:
  2 - новый радиус;
PlanetOrbitalVelocity - возвращает или устанавливает скорость и направление вращения планеты в градусах за 10 ходов:
  1 - планета;
  Опционально:
  2 - задать новую скорость (в градусах за 10 ходов) и/или направление:
     > 0 - по часовой стрелке;
     < 0 - против часовой;
       0 - планета замрёт на месте;
  Примечание: Если задать скорость как 3600, то планета будет делать полный оборот вокруг звезды за один ход.
PlanetSize - возвращает или устанавливает размер планеты:
  1 - планета;
  Опционально:
  2 - дистанция удаления от звезды, орбита (если указать орбиту уже существующей планеты, то в списке системы поставит новую после неё);
CreatePlanet - создаёт новую планету:
  1 - система;
  Опционально:
  2 - радиус орбиты планеты;
PlanetPopulation - возвращает или устанавливает популяцию планеты:
  1 - планета;
  Опционально:
  2 - какую численность населения установить;
PlanetWarriors - возвращает число военных кораблей, приписанных планете (даже если они в данный момент находятся на вылете):
  1 - планета;
  Опционально:
  2 - конкретный корабль из списка;
  Примечание: Пираты, созданные через BuyWarrior на пиратских планетах, данной функцией не учитываются.
FindPlanetByAdvancement - возвращает планету по степени её технического развития (может быть полезно, например, для спавна кораблей):
  1 - степень развития (от 1 до 100);
  Опционально:
  2 - владелец планеты (PlanetOwner());
PlanetCurInvention - возвращает или устанавливает текущий изучаемый планетой проект: 
  1 - планета;
  2 - тип проекта (числом);
  Опционально:
  3 какой проект установить;
PlanetCurInventionPoints - возвращает или устанавливает уровень исследования текущего проекта планеты:
  1 - планета;
  2 - тип проекта (числом);
  Опционально:
  3 - какой уровень исследования текущего проекта установить (от 0 до 100);
  Примечание: По достижении 100% изучения текущего проекта, его ТУ на данной планете повышается на единицу, после чего планета выбирает себе новый проект для изучения.
PlanetInventionLevel - возвращает или устанавливает текущий технический уровень определённого проекта планеты:
  1 - планета;
  2 - тип проекта (числом);
  Опционально:
  3 - какой технический уровень проекта установить (от 1 до 8);
  Типы проектов:
  0 (HullAlloy) - ТУ корпусов;
  1 (FuelTanksType) - ТУ топливных баков;
    2 (EngineSpeed) - ТУ двигателей;
  3 (RadarRadius) - ТУ радаров;
    4 (ScanerType) - ТУ сканеров;
  5 (RepairRobotType) - ТУ дроидов;
    6 (CargoHookType) - ТУ захватов;
  7 (TechLevel) - общий ТУ планеты, непосредственно влияющий на весь ГТУ и на доступность изучения различных типов орудий (для начала изучения той или иной пушки, ТУ планеты должен быть сперва приравнен к ТУ этой пушки);
    8 (Weapon1) - ТУ промышленного лазера;
  9 (Weapon2) - ТУ осколочного орудия;
  10 (Weapon3) - ТУ лезки;
  11 (Weapon4) - ТУ ракетомёта;
  12 (Weapon5) - ТУ третона;
  13 (Weapon6) - ТУ волнового фазера;
  14 (Weapon7) - ТУ потокового бластера;
  15 (Weapon8) - ТУ электронного резака;
  16 (Weapon9) - ТУ мультирезонатора;
  17 (Weapon10) - ТУ атомного визиона;
  18 (Weapon11) - ТУ дезинтегратора;
  19 (Weapon12) - ТУ турбогравира;
PlanetBoostInventions - разово увеличивает скорость развития проектов на планете:
  1 - планета;
  2 - сколько дневных норм исследования проектов накинуть;
  Примечание: Каждый день планета получает определённое количество очков к исследованию своего проекта. При захвате системы доминаторами, у планеты появляется 30% шанс не получить очков исследований за текущий день, а при захвате системы пиратами этот же шанс составляет 15%. Функция PlanetBoostInventions позволяет условно промотать время исследований на N дней вперёд, но при этом градация получения очков исследования за день для планеты не изменится.


Станции:
StarRuins - возвращает количество станций в системе, либо конкретную станцию из этого списка:
  1 - система (вернёт количество станций в системе);
  Опционально:
  2 - если число, то вернёт станцию с указанным номером из списка, а если строка, то вернёт станцию указанного типа (либо 0, если такая станция отсутствует);
  Оригинальные типы станций:
  'RC' - ЦР;
  'WB' - ВБ;
  'SB' - НБ;
  'BK' - БЦ;
  'MC' - МЦ;
  'PB' - ПБ;
  'CB' - доминион;
  Примечание: Аналогично может сделать возврат кастомной станции с кастомным строковым типом, однако цель обязательно должна быть станцией, а не кораблём. Если станция с кастомным строковым типом имеет цифровой тип оригинальной станции (например, t_PB с типом 'BM'), то такая станция будет расценена функцией как кастомная и по запросу базы оригинального типа она возвращена не будет (то есть по StarRuins(star, 'PB') станция t_PB с 'BM' не вернётся).
RuinsChangeType - изменяет основной тип станции (ShipTypeN):
  1 - база;
  2 - новый тип станции (числом или строкой);
  Примечание: Данная функция позволяет сменить не строковый, но основной числовой тип базы, например t_RC на t_CB. Допускается указывать новый тип не числом, а строкой вида 'CB', 'RC' и т.д. в пределах восьми основных типов станций.
BuildRuins - создать базу (возвращает созданную):
  1 - система;
  2 - тип базы:
     t_RC (6) - центр рейнджеров;
     t_PB (7) - пиратская база;
     t_WB (8) - военная база;
     t_SB (9) - научная база;
     t_BK (10) - бизнес-центр;
     t_MC (11) - медицинский центр;
     t_CB (12) - доминион;
BuildCustomRuins - создать кастомную базу (возвращает созданную):
  1 - система;
  2 - кастомный тип строкой;
  3 - чьей считать данную базу (тип Standing):
    Типы Standing:
    0 - Kling - (доминатор) считается доминатором, а потому всеми другими расами воспринимается враждебно;
    1 - None - (ничейный) полностью безразличен к происходящему в системе, аналогичен транклюкатору без хозяина;
    2 - CoalMilitary - (военные) соответствует военным, флагманам, ВБ и ЦР (неизбежно вызовет агрессию со стороны клановых пиратов и автоматически начнёт сражение за пиратскую систему);
    3 - CoalActive - (военные-нейтралы) соответствует рейнджерам на стороне Коалиции (пока они находятся в пиратской системе), НБ и БЦ (может захватить/удержать систему для Коалиции в случае возникновения спорной ситуации);
    4 - CoalPassive - (гражданские) соответствует любым гражданским судам в пиратских системах и рейнджерам на стороне клана (пока они находятся в пиратской системе) (может захватить/удержать систему для Коалиции, но только если сам начнёт уничтожать корабли пиратов);
    5 - Neutral - (нейтралы) соответствует МЦ, перепрограммированному Блазеру и кораблям в тюрьме, игнорирует коалиционные и пиратские тёрки, но к доминаторам враждебен;
    6 - PiratePassive - (вольные пираты) соответствует вольным коалиционным пиратам, рейнджерам на стороне Коалиции (пока они находятся в Коалиционной системе) и ПБ (может захватить/удержать систему для клана, но только если сам начнёт уничтожать корабли военных);
    7 - PirateActive - (пираты-нейтралы) соответствует рейнджерам на стороне пиратского клана (пока они находятся в Коалиционной системе) и странствующим клановым пиратам (может захватить/удержать систему для клана в случае возникновения спорной ситуации);
    8 - PirateMilitary - (клановые пираты) соответствует пиратским доминионам и запрещает посадку коалиционных кораблей (неизбежно вызовет агрессию со стороны военных и автоматически начнёт сражение за коалиционную систему);
    9 - Custom - будет враждебен ко всему, что не имеет той же кастомной фракции и абсолютно всему, если кастомная фракция у данного корабля отсутствует;
    Примечание: Добавление кастомной (t_UB) станции в кастомную фракцию (функция ShipCustomFaction()) автоматически переведёт её в категорию tst_Custom, которая сохранится, даже если впоследствии кастомная фракция будет снята. Данное ограничение не распространяется на станции с оригинальными типами (t_SB, t_PB и т.д.).
    При добавлении к кастомному типу станции приставки '_licensed' (пример, 'MB_licensed'), станция получит возможность ремонтировать артефакты и нестандартное оборудование (равно как и залетающие NPC смогут ремонтировать их на ней).


Корабль (также данные функции работают для станций):
ShipStar - возвращает систему, в которой находится указанный корабль (у каждого корабля имеется указатель на свою текущую систему):
  1 - корабль;
GetOwner - возвращает основную расу корабля (не расу пилота, но, как правило, они совпадают):
  1 - корабль;
GiveReward - выдаёт кораблю случайную медаль по её типу;
  1 - корабль;
  2 - кем выдана (раса);
  3 - тип медали числом;
CountReward - возвращает общее количество медалей корабля или количество медалей определённого типа:
  1 - корабль;
  Опционально:
  2 - тип медали числом (за что выдана);
    Типы медалей:
      0 (ForLiberationSystem) - за освобождение системы или за победу над боссами (просто потому что);
      1 (ForAccomplishment) - за выполнение задания, освобождение системы или за победу над боссами;
      2 (ForSecretMission) - за выполнение задания;
      3 (ForCowardice) - за провал задания;
      4 (ForPerfidy) - различные позорные метки;
      5 (ForPlanetBattle) - за победу в планетарном бою;
CountRewardByNom - возвращает общее количество медалей корабля или количество определённых медалей по их номеру из Lang:
  1 - корабль;
  Опционально:
  2 - номер конкретной медали из Lang;
GiveRewardByNom - выдаёт кораблю определённую медаль по её номеру в Lang:
  1 - корабль;
  2 - номер конкретной медали из Lang;
DeleteRewardByNom - удаляет у корабля определённую медаль по её номеру в Lang и возвращает число удалённых медалей:
  1 - корабль;
  2 - номер конкретной медали из Lang;
  Опционально:
  3 - сколько медалей с данным номером удалить (по умолчанию удалит только одну);
DropItem - заставляет корабль выбросить указанный (или случайный) предмет:
  1 - корабль;
  2 - предмет (либо тип предмета, в таком случае будет выброшен случайный предмет указанного типа);
  Опционально:
  3 - откуда выбросить предмет (если для дропа был указан конкретный предмет, а не тип, то будет работать как 4-й аргумент):
     0 - из трюма;
     1 - экипированный;
  4 - скриптовый объект, в который будет автоматически занесён выброшенный предмет;
ShipPicksItem - возвращает/выставляет кораблю маркер на подбор предмета в космосе, либо запрещает его подбор:
  1 - корабль;
  2 - предмет;
  Опционально:
  3 - какой маркер установить:
    -1 - запретить подбор данного предмета;
     0 - снять все маркеры;
     1 - добавить предмет в список на подбор;
  Примечание: Все маркеры будут автоматически сброшены, если корабль сядет на планету/станцию или покинет систему. Также можно добавлять в список на подбор/запрет предметы, которые уже находятся на борту другого корабля. В таком случае они будут подобраны ботами, если по какой-либо причине окажутся дропнутыми в космос (владелец сам дропнул предмет, либо его корабль был уничтожен).
DeleteEquipment - удаляет указанное установленное в слот оборудование с корабля:
  1 - корабль;
  2 - тип оборудования;
  Примечание: Не может удалять кастомное оружие и артефакты, а для удаления оригинального оружия необходимо указывать его конкретный тип.
ShipTypeN - возвращает основной числовой тип корабля (можно подставлять переменные типа t_Pirate, t_PB):
  1 - корабль;
     0 (t_Kling) - доминатор;
     1 (t_Ranger) - рейнджер;
     2 (t_Transport) - гражданский (не только транспорт);
     3 (t_Pirate) - пират (в т.ч. и клановый);
     4 (t_Warrior) - военный;
     5 (t_Tranclucator) - транклюкатор;
     6 (t_RC) - центр рейнджеров;
     7 (t_PB) - пиратская база;
     8 (t_WB) - военная база;
     9 (t_SB) - научная база;
     10 (t_BK) - бизнес-центр;
     11 (t_MC) - медицинский центр;
     12 (t_CB) - доминион;
     13 (t_UB) - кастомная база (создаётся функцией BuildCustomRuins);
  Примечание: Числовые типы кораблей являются оригинальными основными типами для большого количества кастомных типов судов. Они не поддерживают добавления кастомных типов и служат сугубо внутренним игровым функциям. Определять по ним корабли можно лишь в очень широких диапазонах. Для более точного определения типа корабля, используйте кастомные строчные типы и функцию ShipType().
ShipType - возвращает строковое имя типа корабля (дипломат, рейнджер, доминатор и т.д.):
  1 - корабль;
  2 - сменить строковое имя типа корабля на другое:
  Оригинальные имена типов (модами можно добавить свои):
  'Ranger' - рейнджер;
  'FemRanger' - спецагентка;
  'Pirate' - пират;
  'Transport' - транспорт;
  'Liner' - лайнер;
  'Diplomat' - дипломат;
  'Warrior' - военный или флагман;
  'Tranclucator' - робот;
  'Kling' - доминатор;
  'PlayerBridge' - станция-мостик, имеет основной тип t_WB;
  Оригинальные типы станций:
  'RC' - центр рейнджеров;
  'RCSmall' - ЦР;
  'SB' - научная база;
  'SBSmall' - НБ;
  'WB' - военная база;
  'WBSmall' - ВБ;
  'MC' - медицинский центр;
  'MCSmall' - МЦ;
  'BK' - бизнес-центр;
  'BKSmall' - БЦ;
  'PB' - пиратская база;
  'PBSmall' - ПБ;
  'CB' - доминион;
  'CBSmall' - ДМ;
    Примечание: Типы станций с приставкой Small используются в некоторых окнах для подстановки сокращённых названий (например, при улучшении станции игроком). Проверять станции на такие типы в скрипте не нужно, они используются только в Lang для указания сокращённого имени.
  Кастомные типы кораблей:
  'Militiaman1' - ополченец, первый тип (ExpPilotBridge);
  'Militiaman2' - ополченец, второй тип (ExpPilotBridge);
  'Militiaman3' - ополченец, третий тип (ExpPilotBridge);
  'Rebel' - повстанец (ExpPilotBridge и ShuRebellion);
  'PirateRunner' - пират-загонщик (ExpPilotBridge);
  'AbandonedShip' - покинутый корабль, остающийся после запуска спасательной шлюпки (фактически лайнер, ExpTC);
  'RangerPirate' - рейнджер изменник (ExpTraitors);
  'RangerPiratePlayer' - тип игрока, когда он переходит на сторону пиратов (ExpTraitors);
  'RangerExplorer' - рейнджер с фиксированным именем характера "Исследователь" (ExpExplorers);
  'RangerPirateExplorer' - рейнджер-изменник с фиксированным именем характера "Авантюрист" (ExpExplorers);
  'Smuggler' - рядовой контрабандист (ShuSmugglers), а также тип одного скриптового контрабандиста для события получения доступа к ЧР (ExpBlackMarket);
  'KillerAsteroid' - огромный астероид, угрожающий планете (ExpPhysGun);
  'Dreadnought' - дредноут (EvoArmada);
  'PirateCorvette' - пиратский корвет (EvoArmada);
  'PirateFrigate' - пиратский фрегат (EvoArmada);
  'PirateGalleon' - пиратский галеон (EvoArmada);
  'EliteWarrior' - элитный военный с акриновым корпусом (ShuWarriors);
  'Merc' - наёмник (ShuMercs);
  'PlayerMerc' - наёмник из организации игрока (ShuMercsHQ);
  'Freelancer' - фрилансер (ShuMercs);
  'StarCockerel' - наёмник из элитного отряда "Кумачовые петушки" (ShuMercsHQ);
  'RedLeader' - варлорд Бордюрг Ебрын (ShuMercs);
  'AtlantLeader' - лидер Кайло Норт (ShuMercs);
  'FeiLeader' - гендир Элайма Фэй (ShuMercs);
  'DomTrank' - доминаторский транклюкатор (ShuDomiks);
  'Superdominator' - супердоминатор (ShuDomiks и ShuMiniBoss);
  'DomRuins' - доминаторская верфь (замаскированный эквентор, ShuDomiks);
  'KellerClone' - клон Келлера (замаскированный эквентор, ShuDomiks);
  'Klissan' - клисанский корабль, когда он пират? (ShuKlissan);
  'Klissan1' - клисан эгемон (ShuKlissan);
  'Klissan2' - клисан нондус (ShuKlissan);
  'Klissan3' - клисан катаури (ShuKlissan);
  'Klissan4' - клисан рогит (ShuKlissan);
  'Klissan5' - клисан мутенок (ShuKlissan);
  'Unknown' - неизвестный корабль (ShuKlissan);
  'Khan' - хан (ShuPirates);
  'Thug' - головорез (ShuPirates);
  Кастомные типы станций:
  'TC' - технологический центр (номерной тип 13 - t_UB, ExpTC);
  'TCSmall' - ТЦ;
  'SSB' - подпространственная база (номерной тип 7 - t_PB, ExpSSB);
  'SSBSmall' - ППБ;
  'BM' - чёрный рынок (номерной тип 7 - t_PB, ExpBlackMarket);
  'BMSmall' - ЧР;
  'MB' - центр наёмников (номерной тип 13 - t_UB, ShuMercs);
  'MBSmall' - ЦН;
  'PlayerMB' - штаб наёмников игрока (номерной тип 13 - t_UB, ShuMercs);
  'PlayerMBSmall' - ЦН;
  'PlayerMB_licensed' - штаб наёмников игрока, с лицензией на ремонт артефактов и прочих нестандартных штук (номерной тип 13 - t_UB, ShuMercs);
  'PlayerMBSmall_licensed' - ЦН;
  'Manaan' - свободный порт, а точнее центр наёмников после уничтожения всех главарей наёмников (номерной тип 13 - t_UB, ShuMercs);
  'ManaanSmall' - СП;
  'Inhibitor' - ингибитор (номерной тип 13 - t_UB, ShuDomiks);
  'InhibitorSmall' - Ингибитор;
  'KB' - нейролинк (номерной тип 13 - t_UB, ShuKlissan);
  'KBSmall' - НЛ;
  'Handler' - секретный объект Хандлер (номерной тип 13 - t_UB, ShuKlissan);
  'HandlerSmall' - Хандлер;
  'Machpella' - Махпелла (номерной тип 13 - t_UB, ShuKlissan);
  'MachpellaSmall' - '';
    Примечание: При добавлении к кастомному типу станции приставки '_licensed' (пример, 'MB_licensed'), станция получит возможность ремонтировать артефакты и нестандартное оборудование (равно как и залетающие NPC смогут ремонтировать их на ней).
ShipSubType - возвращает или устанавливает подтип корабля:
  1 - корабль (вернёт текущий подтип);
  Опционально:
  2 - какой подтип установить:
    Доминаторы:
    0 - босс (Блазер, Келлер или Террон);
    1 - эквентор;
    2 - ургант;
    3 - смерш;
    4 - менок;
    5 - штип;
    6 - бертор;
    7 - клиг;
    Гражданские корабли (ShipTypeN = 2):
    0 - транспорт;
    1 - лайнер;
    2 - дипломат;
    Военные:
    0 - обычный;
    1 - флагман;
    Пираты:
    0 - вольный пират (не из клана, либо странствующий клановец, по умолчанию создаются функцией BuyPirate());
    1, 2, 3 - виды клановых пиратов-воинов, отличающихся только предпочтениями в эквипе для разнообразия (по умолчанию создаются функцией BuyWarrior());
  Примечание: Смена подтипа для доминаторских кораблей (или доминаторов с кастомной расой) автоматически не заменит их скин, да и вообще никакой разницы между подтипами доминаторов нет. Основное же поведение корабля задаётся только логикой, которая проверяет подтип перед каждой обработкой, так что при желании превратить, например, штипа в бертора можно без проблем.
ShipCustomFaction - возвращает/устанавливает/снимает кастомную фракцию для корабля (для получения кастомной фракции корабль обязательно должен находиться в скриптовой группе!):
  1 - корабль;
  Опционально:
  2 - имя кастомной фракции строкой ('' - снять кастомную фракцию);
  Примечание: Если имя кастомной фракции начинается с 'SubFaction' (например, 'SubFactionKlissan'), то корабли с такой фракцией не станут по умолчанию враждебными всем окружающим, но сохранят свою стандартную логику поведения. Опционально имеется возможность накладывать маркер 'FixedStanding' в названии кастомной фракции для жёсткого закрепления за кораблём его текущего типа Standing (подробнее об этом читайте в описании функции ShipStanding()).
  Примечание: Наличие обязательной скриптовой группы для кораблей с кастомной фракцией не обеспечивает им защиту от астероидов. Корабли с враждебной всем кастомной фракцией получают повышенный шанс дропа своего оборудования, идентичный шансу дропа у доминаторов.
IdToShip - возвращает корабль по его Id:
  1 - Id корабля;
ShipPilotRace - возвращает/устанавливает расу пилота корабля:
  1 - корабль;
  Опционально:
  2 - какую расу установить:
     0 (Maloc) - малоки;
     1 (Peleng) - пеленги;
     2 (People) - люди;
     3 (Fei) - феяне;
     4 (Gaal) - гаальцы;
ShipCanJump - проверяет, может ли корабль совершить прыжок (по умолчанию проверяет только по дальности двигателя) из одной системы в другую(ие) систему(ы):
  1 - корабль;
  2 - система, из которой нужно прыгать;
  3, 4, 5 и т.д. - следующие системы которые нужно проверить на возможность прыжка (фактически, проверяется маршрут), минимум одна система (3) должна быть указана, далее количество систем для проверки не ограничено. Помимо системы, следующим аргументом в очереди можно указать маркер 1, чтобы функция проверила возможность прыжка не только по двигателю, но и по остатку топлива для всего выстроенного маршрута;
ShipInStar - проверяет, не находится ли указанный корабль в определённой системе:
  1 - корабль;
  2 - система;
ShipInPlanet - проверяет не находится ли корабль на планете:
  1 - корабль;
  2 - планета;
ShipFind - ищет в системе, в которой находится игрок, корабль определённого типа:
  1 - числовой тип корабля;
ShipDestroy - уничтожает определённый корабль или принудительно отменяет его уничтожение:
  1 - корабль;
  2 - уничтожить/отменить уничтожение (1 или 0);
Player - без аргументов, возвращает корабль игрока;
CountTurn - возвращает количество ходов, которое потребуется кораблю, чтобы достигнуть определённого объекта:
  1 - корабль;
  2 - объект (возможные типы объектов: скриптовое место, планета, корабль/станция);
ShipTurnBeforeEndOrder - аналог CountTurn, но без второго аргумента, просто считает сколько будет выполняться текущий приказ корабля:
  1 - корабль;
ShipGetBad - возвращает текущий объект враждебности корабля:
  1 - корабль (проверять враждебность только по отношению Relation для игрока некорректно, т.к. даже при враждебном поведении отношение корабля может быть выше 10);
  Примечание: ShipBad корабля не сбрасывается до тех пор, пока ему не будет назначена новая цель, либо старая не сдохнет. Даже если цель или преследующий её корабль улетят по разным системам, ShipBad сам по себе сброшен не будет.
ShipSetBad - назначить кораблю/станции текущего врага:
  1 - корабль;
  2 - враг (другой корабль или станция);
ShipInGameEvent - проверяет, не участвует ли военный корабль или ВБ в операции по освобождению системы (помешать этому из скрипта никак нельзя):
  1 - военный корабль или военная база;
ShipInNormalSpace - проверяет, что корабль в обычном космосе (не в гиперпространстве, не в АБ, не на планете и т.д.):
  1 - корабль;
ShipInHole - проверяет не находится ли корабль в ЧД:
  1 - корабль;
  Примечание: Фактически представляет собой две последовательные проверки: ShipInHyperSpace(ship) и ShipOrder(ship) == 4 (приказ на прыжок в ЧД), так что может возвращать 'True' параллельно с функцией ShipInHyperSpace.
ShipIsTakeoff - проверяет не взлетает ли корабль с планеты/станции:
  1 - корабль;
StarShips - возвращает количество кораблей и станций (!) в системе (но иногда не учитывает военные корабли на планетах), или конкретный корабль в ней:
  1 - система (вернёт количество);
  Опционально:
  2 - номер корабля в списке кораблей и станций (!) системы (вернёт корабль);
GetShipPlanet - возвращает планету, на которой в текущий момент находится корабль (если корабль не на планете вернёт 0):
  1 - корабль;
GetShipRuins - возвращает станцию, на которой в текущий момент находится корабль (если корабль не на станции вернёт 0):
  1 - корабль;
  Примечание: Если игрок находится на экране мостика и при этом сидит на планете или станции, для возврата соответствующей планеты или станции необходимо применить функцию возврата повторно, пример: GetShipRuins(GetShipRuins(Player())) или GetShipPlanet(GetShipRuins(Player())).
GetTalkShip - без аргументов, во время разговора в космосе возвращает корабль собеседника (во всех остальных случаях вернёт 0);
ShipInHyperSpace - проверяет, не находится ли корабль в гиперпространстве:
  1 - корабль;
OrderJump - заставляет корабль совершить прыжок в другую систему игнорируя возможности двигателя и бака:
  1 - корабль;
  2 - система назначения;
  Опционально:
  3 - приоритет приказа (нескриптовые корабли всё равно могут проигнорить, но по ерунде отвлекаться не будут);
ShipDestination - переносит игрока в другую систему сразу после его взлёта со станции, (функция, воссоздающая портальный прыжок с пиратских доминионов, выставлять только пока игрок находится на станции):
  1 - игрок (с одним аргументом вернёт текущую систему назначения);
  Опционально:
  2 - установить систему назначения (пропуск хода станет невозможен);
OrderLanding - заставляет корабль приземлиться:
  1 - корабль;
  2 - объект для посадки (планета или станция);
  Опционально:
  3 - приоритет приказа;
OrderTakeOff - отдать кораблю приказ на взлёт:
  1 - корабль;
OrderLock - блокировать/разблокировать возможность отдавать любые приказы (кроме скриптовых) для конкретного корабля:
  1 - корабль;
  Опционально:
  2 - блокировать/разблокировать отдачу приказов: 1/0;
  Примечание: В том числе блокирует логику, выставляемую кораблям стейтами, так что если вам необходимо поместить корабль в стейт, но при этом не использовать логику данного стейта (включая стейты с None), и выставлять приказы только вручную, то OrderLock() будет обязательным условием такого контроля.
OrderNone - отменяет текущий приказ и боевые цели корабля:
  1 - корабль;
OrderMove - приказ кораблю двигаться к указанным координатам:
  1 - корабль;
  2 - X координата, либо название переменной (без кавычек) скриптового места, если приказ вызывается из конкретного скрипта;
  3 - Y координата;
  Примечание: При выдаче приказа движения в скриптовое место, код будет автоматически переназначать конкретную точку в границах указанного места движения каждый ход.
OrderTeleport - приказ кораблю/станции телепортироваться в указанную систему в указанные координаты:
  1 - корабль или станция;
  2 - целевая система;
  3 - X координата в целевой системе;
  4 - Y координата в целевой системе;
  Опционально:
  5 - приоритет приказа (в данном случае бесполезно);
  6 - длительность нахождения корабля/станции в гипере в днях (допустимо выставлять 0 для мгновенного переноса);
OrderFollowShip - приказ кораблю следовать за другим кораблём:
  1 - корабль;
  2 - целевой корабль;
  3 - тип следования:
     0 - простое следование;
     1 - выход на дистанцию выстрела;
     2 - выход на дистанцию выстрела самого дальнобойного орудия (не используется в оригинальной игре);
  Опционально:
  4 - приоритет приказа;
OrderJumpHole - приказ кораблю залететь в ЧД:
  1 - корабль;
  2 - ЧД;
  Опционально:
  3 - приоритет приказа;
ShipOrder - возвращает или устанавливает текущий приказ для корабля:
  1 - корабль;
  Опционально:
  2 - какой приказ установить числом, либо 'X' или 'Y' строкой для возвращения координаты текущего приказа:
    Список приказов:
     -1 - автобой (только для игрока, используйте этот маркер только для возврата приказа, установить автобой можно лишь с помощью AutoBattle());
    0 - без приказа;
    1 - движение;
    2 - посадка;
    3 - прыжок;
    4 - прыжок в ЧД;
    5 - взлёт;
    6 - следование (обычное, либо приближение на расстояние выстрела);
    7 - телепортация;
  3 - если вторым аргументом стоит 'X' или 'Y', то установить новое значение соответствующей координаты;
  Примечание: Координаты приказа имеются только у приказов движения, прыжка, и также прыжка в ЧД.
ShipOrderData1 - первая переменная, хранящая в себе длительность прыжка/телепорта/ЧД-прыжка:
  1 - корабль;
  Опционально:
  2 - задать новую длительность;
    Примечание: Если у корабля установлен приказ "следование", то у ShipOrderData1() будет три возможных значения:
       0 - t_FollowNear (простое следование);
     1 - t_FollowMin (на расстоянии выстрела);
     2 - t_FollowMax (на расстоянии выстрела самой дальнобойной пушки (по умолчанию в игре не используется));
ShipOrderData2 - вторая переменная, хранящая в себе длительность прыжка/телепорта/ЧД-прыжка (для ЧД-прыжков здесь выставляются особые маркеры):
  1 - корабль;
  Опционально:
  2 - задать новую длительность;
    Примечание: Общая длительность прыжка хранится в двух переменных типа dword и определяется игрой по следующей формуле: ShipOrderData1 + ShipOrderData2 * 65536. При этом максимально допустимое значение длительности будет достигнуто, если одновременно установить кораблю ShipOrderData1(ship, 65535) и ShipOrderData2(ship, 32767) (не больше, иначе dword переполнится!). При установлении длительности прыжка в функции самого приказа (например, OrderTeleport), переданное значение длительности будет автоматически разбито по двум ShipOrderData, что необходимо учитывать, если в дальнейшем вы захотите изменить длительность этими функциями.
    При залёте в ЧД значение второй переменной ShipOrderData2 используется под маркеры, а потому максимальную длительность конкретно ЧД-прыжка можно запомнить только в одной переменной ShipOrderData1(ship, 65535).
      Маркеры, записываемые в ShipOrderData2 при ЧД-прыжках:
        Для простых кораблей:
        0 - корабль влетел в ЧД со стороны входа;
        1 - корабль влетел в ЧД со стороны выхода;
      Для Келлера:
        Маркеры, каким-то образом определяющие траекторию вылета Келлера из ЧД;
      Для всех:
        65535 - корабль производит вылет из ЧД (ShipOrderData1 при этом должен быть задан на 0);
      Примечание: При вылете из ЧД объект приказа на саму ЧД (ShipOrderObj()) у корабля уже обнулён, а потому, если выставить ShipOrderData1(ship, 0) и ShipOrderData2(ship, 65535), задать кораблю нужные координаты, отдать приказ на ЧД-прыжок (ShipOrderObj() должен быть 0) и произвести MakeShipEnterStar(), с указанием нужной системы, можно заставить корабль совершить взлёт из любой желаемой точки системы. К сожалению, данный метод будет работать только из акткода, на OnStep 1 и выше, и не факт, что сработает для корабля игрока, нужны тесты.
      Пример верной расстановки функций:
      MakeShipEnterStar(ship, to_star, from_star, 0);
      ShipSetCoords(ship, 0, 0);
      ShipOrder(ship, 4);
      ShipOrderObj(ship, 0);
      ShipOrderData1(ship, 0);
      ShipOrderData2(ship, 65535);
ShipOrderObj - возвращает или изменяет объект действия текущего приказа корабля (если корабль ведёт автобой, то объектом будет его цель, если совершает прыжок, то целевая система, если залетает/находится в ЧД, то ЧД и т.д.):
  1 - корабль;
  Опционально:
  2 - на какой объект заменить объект действия корабля;
MakeShipEnterStar - форсирует вход корабля в систему, как будто он совершил полноценный прыжок:
  1 - корабль;
  2 - система, в которую совершается прыжок;
  3 - система, из которой совершается прыжок (определяет точку выхода из гипера);
  4 - время нахождения корабля в гипере перед выходом;
AutoBattle - функция активации автобоя для игрока:
  1 - корабль с которым игрок должен вести автобой, либо 0 - отмена автобоя (допустимо вести автобой с самим собой);
ShipAddDropItem - добавляет указанный предмет в дроплист корабля, все предметы из данного листа гарантированно выпадут из корабля при его смерти (кроме случаев выставления кораблю ShipDestroy()), предметы из дроплиста не занимают места на корабле и не отображаются в его трюме:
  1 - корабль;
  2 - предмет;
ChanceToWin - возвращает (в виде int от 0 до 100) шанс победы одного корабля над другим:
  1 - один корабль;
  2 - другой корабль;
  Опционально:
  3 - опциональный флаг (любое число выше 0), чтобы функция вернула расчёт не в процентах, а в оригинальном виде с типом float, где все значения от 4 целых и выше уже будут считаться игрой 100% шансом на победу;
  Примечание: Клиги будут таранить игрока только при получении ChanceToWin < 0.2, а иначе будут просто атаковать его как обычные корабли.
IsChameleon - проверяет, применён ли хамелеон (не камуфляж, а именно "хамелеон", то есть визуальная смена внешнего вида корпуса) к кораблю в настоящий момент:
  1 - корабль;
Chameleon - меняет визуальный облик корабля:
  1 - корабль или база (если это единственный аргумент, то сбрасывает шкурку на базовый вид для текущего корпуса или акрина);
  Опционально:
  2 - путь в main.dat/Data/SE к нужной шкурке (например, строка вида 'Ship.Gaal.Transport' поменяет шкурку на гаальский транспорт) или строка 'GraphName' для возврата полного пути к уже установленной на корабле шкурке;
  3 - если значение больше 0, то выполнится автоматический перезаход на форму StarMap для моментальной визуальной смены шкурки корпуса. Имеет смысл применять данный маркер только если игрок находится на форме StarMap и имеет прямой визуальный контакт на корабль, меняющий шкурку. Во всех остальных случаях просто игнорируйте этот аргумент.
  Примечание: Если вы повесили на корпус корабля акрин и хотите автоматически обновить его облик, команды Chameleon(ship) для этого вполне достаточно.
PlayerChameleonCharges - проверяет или устанавливает количество доступных активаций камуфляжа у игрока:
  1 - серия;
  Опционально:
  2 - сколько активаций задать;
PlayerChameleonDetected - проверяет, устанавливает и снимает детект доминаторами камуфляжа игрока:
  1 - серия камуфляжа;
  Опционально:
  2 - включить/отключить детект;
PlayerChameleonCurType - возвращает/устанавливает активный доминаторский камуфляж на корабле игрока:
  Без аргументов - возвращает текущий камуфляж (-1 - камуфляж неактивен);
  Опционально:
  1 - установить, либо снять камуфляж:
      -1 - снять камуфляж;
     0 - установить камуфляж блазероида;
     1 - установить камуфляж келлероида;
     2 - установить камуфляж терроноида;
  Примечание: Сама по себе данная функция "хамелеон" не накладывает, а просто устанавливает игроку камуфляжный режим. То есть без вызова дополнительной функции Chameleon() внешний вид игрока не изменится, но доминаторы всё равно будут считать его за своего.
PlayerLogicChameleon - особая скриптовая маскировка, позволяющая активировать функцию, аналогичную игровому камуфляжу, но с новыми дополнительными возможностями (внешний вид корабля доминатора не накладывается, а коалиционные и пиратские корабли не считают игрока доминатором):
  1 - серия доминаторов, без второго аргумента просто вернёт статус спецкамуфляжа:
     0 - блазероиды;
     1 - келлероиды;
     2 - терроноиды;
  Опционально:
  2 - какой статус спецкамуфляжа для указанной серии доминаторов установить;
    Возможные статусы:
    0 - камуфляжа нет (отключает спецкамуфляж);
    1 - доминаторы не атакуют, пока не заметят обман (базовый тип камуфляжа);
    2 - доминаторы не атакуют игрока совсем, но и игрок также не может атаковать доминаторов;
  Примечание: Если бой уже начался, то запрет атаки в обе стороны включить не выйдет, т.к. игрок всё равно сможет защищаться. Диалоги с другими кораблями при включении спецкамуфляжа никак не меняются (кроме, возможно, вариаций диалогов домиков). Боссы при статусе спецкамуфляжа 1 или 2 (при условии, что игрок не был обнаружен) не запускают скриптовый диалог, а выдают стандартную камуфляжную реплику, как при обычном камуфляже, которую можно перебить оверрайдом.
ShipChangeStar - меняет текущую систему привязки корабля, что необходимо делать вручную только при нестандартном перемещении кораблей из кода (также важно для корректного возврата функции ShipStar()):
  1 - корабль;
  2 - новая система привязки;
ShipRefit - обновляет оборудование на корабле (заставляет корабль провести реинвентаризацию из своего источника/магазина), если он находится на планете или станции (иначе не сделает ничего):
  1 - корабль;
  Опционально:
  2 - минимальный размер корпуса, который нужно установить кораблю (автоматически поднимет и число HP);
  3 - минимальная сумма денег, которую нужно установить кораблю;
  Примечание: При рефите доминаторов и прочих враждебных рас, оборудку они будут брать из магазина планеты с местной расой (не доминаторской), поэтому во избежание появления у доминаторов, например, малокской оборудки, после рефита необходимо вручную перебрать им все вещи и задать овнера и серию. Можно делать рефит и на незаселённых планетах, однако ввиду нулевого технического развития, шмотки там будут всегда галимые.
ShipStatusEffect - проверяет и изменяет мощность эффектов, наложенных на корабль в текущий момент (0 - эффекта нет):
  1 - корабль;
  2 - тип эффекта:
     0 (Shock) - эффект ионизации;
     1 (Acid) - эффект ослабления брони (коррозия);
     2 (Magnetic) - эффект ЭМ-помех;
     3 (WeaponBlock) - эффект блокировки орудий;
     4 (DroidBlock) - эффект блокировки дроида;
     5 (BWBuff) - эффект усиления от флагмана;
     6 (BWRepairDebuff) - эффект ослабления последовательных ремонтов от флагмана (если корабль чиниться от флагмана, либо сам флагман применяет на себя особый ремонт, с каждым разом эффективность ремонта будет становиться всё слабее и слабее);
  Опционально:
  3 - на какое значение изменить мощность эффекта, также напрямую влияющую на продолжительность этого эффекта (суммируется с уже существующим значением, может быть отрицательным);
  4 - корабль/станция, которая будет считаться наложившей эффект (будет применено, только если мощность эффекта была увеличена, по сравнению с предыдущим значением);
  Примечание: Если добавить в любую кастомную инфошку параметр StatusEffect, то текст из него будет использован в игре в качестве эффекта в карточке корабля, на который наложена данная инфошка. Значение силы эффекта (отображается если надет "Сканерный кэш") при этом будет браться из первой числовой переменной инфошки, которая должна будет иметь значение не равное нулю, чтобы такой самодельный эффект в принципе отобразился в карточке.

Группа кораблей:
SetRelationGroup - устанавливает отношение скриптовой группы кораблей к скриптовой группе кораблей рейнджеров:
  1 - группа кораблей, которым задаём отношение;
  2 - группа рейнджеров;
  3 - какой уровень отношения установить (0-4);
SetRelationPlanet - устанавливает отношение планеты к скриптовой группе кораблей рейнджеров:
  1 - группа рейнджеров;
  2 - планета;
  3 - какой уровень отношения установить (0-4);
    Уровни отношения:
      0 (ReWar) - враждебное отношение, фактическое значение 5;
      1 (ReBad) - плохое отношение, фактическое значение 20;
      2 (ReNormal) - нормальное отношение, фактическое значение 45;
      3 (ReGood) - хорошее отношение, фактическое значение 70;
      4 (ReBest) - отличное отношение, фактическое значение 90;
ShipGroup - возвращает номер скриптовой группы корабля (имеет смысл вызывать только из того скрипта, в котором находится корабль):
  1 - корабль (если корабль не в группе, вернёт -1);
  Примечание: Название группы - это переменная с номером, так что можно сравнивать возврат данной функции непосредственно с названием переменной конкретной группы. При этом в каждом скрипте нумерация скриптовых групп своя, так что проверять соответствие группы корабля номеру группы из другого скрипта не имеет смысла.
GroupToShip - возвращает первый корабль в выбранной группе текущего скрипта:
  1 - название переменной или номер группы;
GroupCount - считает количество кораблей в определённой скриптовой группе:
  1 - название переменной или номер группы;
GroupShip - возвращает конкретный корабль из скриптовой группы:
  1 - название переменной или номер группы;
  2 - номер корабля в скриптовой группе (начиная с 0);
GroupIn - проверяет не находится ли скриптовая группа в определённом месте (необходимо присутствие в одном месте сразу всех кораблей группы):
  1 - название переменной или номер группы;
  2 - место, возможные типы:
     - Конкретный сектор;
     - Конкретная система;
     - Конкретная планета;
     - Конкретная станция или корабль (да, можно сажать корабли на корабли);
     - Конкретное скриптовое место;
CountIn - считает количество кораблей указанной скриптовой группы в определённом месте:
    1 - название переменной или номер группы (без второго аргумента вернёт общее количество кораблей в группе);
  Опционально:
  2 - место, в котором будет производиться подсчёт:
     - Конкретный сектор;
     - Конкретная система;
     - Конкретная планета;
     - Конкретное скриптовое место;
  3 - флаг (если != 0) о пропуске подсчёта кораблей группы, которые в данный момент находятся в гипере (ShipInHyperSpace()), что актуально, если нужно подсчитать число кораблей группы в конкретной системе;
NearestGroup - проверяет какая из перечисленных скриптовых групп ближе к определённому кораблю:
  1 - корабль;
  2 - минимальная дистанция для проверки, 3, 4, 5 и т.д. - номера групп для проверки;
GroupSetBad - назначить всем кораблям группы текущего врага:
  1 - название переменной или номер группы;
  2 - корабль врага;
GroupIs - проверяет не является ли группа корабля указанной(ыми) группой(ами):
  1 - корабль;
  2, 3, 4 и т.д - номера групп (подставлять переменную группы) для проверки;


Создание кораблей:
BuyRanger - спавнит рейнджера:
  1 - планета для спавна;
  Опционально:
  2 - модификатор (в процентах, по умолчанию 100%) стартового капитала рейнджера от текущего среднего капитала рейнджеров, либо доля от капитала самого богатого рейнджера (выбирается наименьший вариант, то есть, обычно, средний рейнджерский капитал), а если Коалиция побеждена, то будет взят средний капитал всех странствующих клановых пиратов и всех до сих пор существующих в Галактике рейнджеров, включая игрока, либо доля от капитала самого богатого рейнджера;
  Примечание: Доля самого богатого рейнджера выбирается случайно в диапазоне от 40% до 60% (но не более 500.000 cr.) его текущего капитала (в лейтгейме самым богатым рейджером, скорее всего, будет игрок). Модификатор из второго аргумента будет наложен уже после определения базового капитала корабля.
BuyPirate - спавнит странствующего пирата (обычного коалиционного или с клановым овнером, в зависимости от планеты спавна):
  1 - планета для спавна корабля;
  Опционально:
  2 - модификатор (в процентах, по умолчанию 100%) стартового капитала пирата от доли текущего капитала самого богатого рейнджера (если Коалиция побеждена, то, как минимум, из числа рейнджеров активным и самым богатым останется сам игрок);
  Примечание: Доля самого богатого рейнджера выбирается случайно в диапазоне от 30% до 50% (но не более 800.000 cr.) его текущего капитала (в лейтгейме самым богатым рейджером, скорее всего, будет игрок). Модификатор из второго аргумента будет наложен уже после определения базового капитала корабля.
  Примечание: При спавне пирата на Роджерии (PlanetPirateClan()), его раса пилота (и оборудования) НЕ будет выбрана случайным образом, т.к. кто-то в 2017 году попросил специально сломать эту удобнейшую возможность при спавне пиратов из скрипта. Наслаждайтесь.
BuyWarrior - спавнит военный корабль или кланового пирата-военного (зависит от овнера планеты):
  1 - планета для спавна;
  Опционально:
  2 - модификатор (в процентах, по умолчанию 100%) стартового капитала военного от доли текущего капитала самого богатого рейнджера (если Коалиция побеждена, то, как минимум, из числа рейнджеров активным и самым богатым останется сам игрок);
  Примечание: Доля самого богатого рейнджера выбирается случайно в диапазоне от 30% до 50% (но не более 900.000 cr. для военного и не более 800.000 cr. для кланового пирата) его текущего капитала (в лейтгейме самым богатым рейджером, скорее всего, будет игрок). После вычисления своего капитала от доли рейнджера, военные и клановые пираты также получают множитель итоговой суммы на значение от 1.2 до 0.7 (чем меньше систем, тем больше денег) в зависимости от текущего процента числа захваченных систем у Коалиции и пиратского клана соответственно. Под конец военный и клановый пират имеют 20%-й шанс получить доп. модификатор в зависимости от успешности хода боевых действий Коалиции и пиратского клана от 2.0 до 0.5 (чем хуже дела, тем больше денег). Модификатор из второго аргумента будет наложен уже после определения базового капитала корабля.
  Примечание: При спавне пирата-защитника на Роджерии (PlanetPirateClan()), его раса пилота (и оборудования) будет выбрана случайным образом.
BuyBigWarrior - спавнит флагман:
  1 - планета для спавна;
  Опционально:
  2 - модификатор (в процентах, по умолчанию 100%) стартового капитала флагмана от доли текущего капитала самого богатого рейнджера (если Коалиция побеждена, то, как минимум, из числа рейнджеров активным и самым богатым останется сам игрок);
  Примечание: Доля самого богатого рейнджера выбирается случайно в диапазоне от 30% до 50% (но не более 900.000 cr.) его текущего капитала (в лейтгейме самым богатым рейджером, скорее всего, будет игрок). После вычисления своего капитала от доли рейнджера, флагманы также получают множитель итоговой суммы на значение от 1.2 до 0.7 (чем меньше систем, тем больше денег) в зависимости от текущего процента числа захваченных систем у Коалиции. Под конец флагман имеет 20%-й шанс получить доп. модификатор в зависимости от успешности хода боевых действий Коалиции от 2.0 до 0.5 (чем хуже дела, тем больше денег). Модификатор из второго аргумента будет наложен уже после определения базового капитала корабля.
BuyTransport - спавнит гражданское судно (не только транспорт):
  1 - планета для спавна корабля;
  Опционально:
  2 - тип гражданского:
     0 - транспорт;
     1 - лайнер;
     2 - дипломат;
  3 - модификатор (в процентах, по умолчанию 100%) стартового капитала гражданского от доли текущего капитала самого богатого рейнджера (если Коалиция побеждена, то, как минимум, из числа рейнджеров активным и самым богатым останется сам игрок);
  Примечание: Доля самого богатого рейнджера выбирается случайно в диапазоне от 20% до 40% (но не более 600.000 cr.) его текущего капитала (в лейтгейме самым богатым рейджером, скорее всего, будет игрок). Модификатор из второго аргумента будет наложен уже после определения базового капитала корабля.
BuyTranclucator - спавнит транклюкатора:
  1 - планета для спавна;
  Опционально:
  2 - маркер силы транклюкатора:
     0 - создать транклюкатора с нормальной силой, как те, что падают из ЧД или выдаются в качестве награды за задания;
     1 - создать слабого транклюкатора, как в начальном обучении (вариант по умолчанию!!!);
BuyDomik - спавнит доминатора, устаревший алгоритм:
  1 - планета для спавна;
BuyDomikExtremal - спавнит доминатора, стандартный алгоритм:
  1 - планета для спавна;
  Опционально:
  2 - подтип ShipSubType() доминатора:
     1 - эквентор;
     2 - ургант;
     3 - смерш;
     4 - менок;
     5 - штип;
     6 - бертор;
     7 - клиг;
TransferShip - перемещает (не телепортирует, а просто мгновенно переносит) корабль/станцию на заданный объект:
  1 - корабль/станция;
  2 - объект, куда нужно переместить корабль, возможные типы объектов:
     - система (появится в новой системе по своим текущим координатам);
     - планета;
     - станция;
GalaxyShipId - без аргументов, возвращает Id, которое будет присвоено следующему родившемуся кораблю;


Игрок и другие рейнджеры:
IsPlayer - проверяет, не является ли корабль игроком (аналогично можно проверить как if(ship == Player()), но IsPlayer() оптимальнее):
  1 - корабль;
StatusPlayer - без аргументов, возвращает текущий статус характера игрока (устаревшая функция):
  Типы статусов:
  1 - торговец;
  0 - воин;
   -1 - пират;
RangerStatus - возвращает текущий статус характера любого рейнджера (включая игрока):
  1 - корабль рейнджера;
    Типы возвращаемых статусов:
      0 - торговец;
      1 - пират;
        2 - воин;
  2 - проверка, не вынесен ли рейнджер на доску почёта в указанной категории (подставить строку) прямо сейчас:
     'EminentWarrior' - отличившийся воин;
     'EminentTrader' - выдающийся делец;
     'EminentPirate' - злейший пират;
ShipStatus - возвращает или устанавливает статус характера рейнджера (от 0 до 100):
  1 - корабль;
  2 - тип статуса;
  Опционально:
  3 - изменить данный статус (от 0 до 100) типы статусов:
     0 - торговец;
     1 - пират;
     2 - воин;
ShipStrengthInBestRanger - возвращает относительную силу корабля по сравнению с лучшим рейнджером:
  1 - корабль;
ShipStrengthInAverageRanger - возвращает относительную силу корабля по сравнению со средним рейнджером:
  1 - корабль;
ShipJoinsClan - корабль вступает в пиратский клан:
  1 - корабль;
ShipInPirateClan - проверяет, состоит ли корабль в пиратском клане, а для игрока - вступал ли он в клан в этой партии вообще:
  1 - корабль;
ShipOnSidePirateClan - проверяет, состоит ли корабль в пиратском клане в настоящий момент (также можно проверить с помощью ShipOwner(ship) == PirateClan):
  1 - корабль;
ShipRank - возвращает текущее военное звание корабля числом:
  1 - корабль;
    Звания:
      0 - Новичок;
      1 - Кадет;
      2 - Пилот;
      3 - Капитан;
      4 - Истребитель;
      5 - Ас (Пилот);
      6 - Командор;
      7 - Адмирал;
GetShipPirateRank - возвращает текущее пиратское звание корабля числом:
  1 - корабль;
    Звания:
      0 - Салага;
      1 - Юнга;
      2 - Рейдер;
      3 - Шкипер;
      4 - Головорез;
      5 - Атаман;
      6 - Хан;
      7 - Барон;
ShipRankPoints - возвращает или устанавливает текущее количество очков коалиционного (военного) рейтинга:
  1 - корабль;
  Опционально:
  2 - какое количество очков установить;
ShipNextRankPoints - возвращает количество очков коалиционного рейтинга, необходимое для получения следующего звания (не сколько осталось кораблю, а сколько ему нужно всего):
  1 - корабль;
ShipRaiseRank - повышает текущее коалиционное звание корабля на плюс одно (сработает только если у корабля достаточно очков):
  1 - корабль;
ShipPirateRankPoints - возвращает или устанавливает текущее количество очков пиратского рейтинга:
  1 - корабль;
  Опционально:
  2 - какое количество очков установить;
ShipNextPirateRankPoints - возвращает количество очков пиратского рейтинга, необходимое для получения следующего звания (не сколько осталось кораблю, а сколько нужно всего):
  1 - корабль;
RaisePirateRank - повышает текущее пиратское звание корабля на плюс одно (сработает только если у корабля достаточно очков):
  1 - корабль;
ShipSkill - возвращает или устанавливает значение определённого навыка корабля:
  1 - корабль;
  2 - тип навыка:
    Навыки для подстановки вторым аргументом (можно подставлять числом или строкой):
    'Accuracy' (0) - точность;
    'Mobility' (1) - манёвренность;
    'Technical' (2) - техника;
    'Trader' (3) - торговля;
    'Charm' (4) - обаяние;
    'Leadership' (5) - лидерство;
    Только для запросов значения (подставлять только строкой):
    'AccuracyCur' - точность с учётом всех бонусов/штрафов;
    'MobilityCur' - манёвренность с учётом всех бонусов/штрафов;
    'TechnicalCur' - техника с учётом всех бонусов/штрафов;
    'TraderCur' - торговля с учётом всех бонусов/штрафов;
    'CharmCur' - обаяние с учётом всех бонусов/штрафов;
    'LeadershipCur' - лидерство с учётом всех бонусов/штрафов;
  Опционально:
  3 - какой уровень навыка установить;
  Примечание: При попытке установить уровень навыка выше 6, будет автоматически установлен уровень 6.
ShipFace - возвращает уже инициализированный или устанавливает кораблю новый портрет (может быть -1):
  1 - корабль (просто вернёт номер текущего портрета, а если тот ещё не инициализирован, то -1);
  Опционально:
  2 - номер нового портрета в списке числом, либо 'New', для принудительной реинициализации (в том числе уже инициализированного портрета), либо 'Init' для возвращения номера текущего портрета и предварительной инициализации в случае, если он ещё не был инициализирован, либо 'Path', чтобы вернуть путь портрета в CacheData (также автоматически его инициализирует, если портрет ещё не инициализирован);
  Примечание: Если номер портрета установлен как -1, значит, портрет корабля ещё не инициализирован. Инициализация портрета произойдёт в момент, когда игрок первый раз его увидит, то есть первый раз просканирует, либо заговорит с кораблём.
ShipFreeExp - возвращает или устанавливает количество нераспределённого опыта корабля:
  1 - корабль;
  Опционально:
  2 - какое количество установить;
  Примечание: Боты автоматически распределяют свой свободный опыт на следующий ход, после его получения (если хватает).
GetShipExpByType - возвращает количество заработанного кораблём опыта за всю игру:
  1 - корабль;
  Опционально:
  2 - конкретный тип опыта:
     0 - сумма всех типов (выбирается по умолчанию);
     1 - убийство доминаторов;
     2 - убийство пиратов;
     3 - прочие убийства;
     4 - торговля;
RelationToShip - возвращает отношение объекта к указанному кораблю (от 0 до 100, где < 10 - враждебное отношение):
  1 - объект (корабль, станция или планета);
  2 - корабль;
  Примечание: Если речь не идёт об отношении к кораблю рейнджера, у всех кораблей разных рас имеются свои фиксированные таблицы уровня отношений друг с другом. Если же два любые корабля ведут бой (выставлен ShipBad), включая корабли рейнджеров, то данная функция в любом случае вернёт 0.
RelationToRanger - возвращает или устанавливает отношение объекта к рейнджеру (от 0 до 100):
  1 - объект (корабль, станция или планета);
  2 - корабль рейнджера;
  Опционально:
  3 - какое отношение установить:
     80-100 - отличное;
     60-79 - хорошее;
     30-59 - нормальное;
     10-29 - плохое;
     0-9 - враждебное;
  Примечание: Военные корабли не имеют своего собственного отношения к рейнджерам, так что выставлять им его бесполезно. Их отношение к кораблю наследуется от их родной планеты. Также не имеют своего отношения к рейнджерам и все пиратские планеты (вернее имеют, но не используют до освобождения от пиратов), а потому наследуют его от Роджерии (для смены отношения всех пиратских планет, отношение нужно менять у Роджерии). Также, в отличие от функции RelationToShip(), эта функция всегда возвращает конкретный уровень отношения к рейнджеру, даже если корабли враждуют (выставлен ShipBad), поэтому проверять непосредственную враждебность с помощью данной функции неудобно.
ConChangeRelationToRanger - меняет отношение к рейнджеру на всех планетах указанного сектора:
  1 - сектор;
  2 - корабль рейнджера;
  3 - на сколько изменить текущее отношение к рейнджеру (+20, -45 и т.д.);
  Примечание: Изменение отношения сработает только для коалиционных планет (если только не применить эту функцию для Тортугаца/Нифигаца), поскольку пиратские планеты наследуют отношение от Роджерии. Имейте в виду, что изменение отношения для пиратских планет все равно сработает, но увидеть это изменение игрок сможет только после их освобождения от пиратов.
GalaxyRangers - возвращает общее количество рейнджеров в Галактике, или конкретного рейнджера из их числа:
  Без аргументов - вернёт общее количество;
  Опционально:
  1 - номер рейнджера в списке (вернёт конкретного рейнджера);
ExtremalTakeOff - без аргументов, форсирует взлёт игрока с его текущей планеты/станции и сразу же запускает следующий ход;
TruceBetweenShips - корабли мирятся:
  1 - первый корабль;
  2 - второй корабль;
  Примечание: Также принудительно вызывает внеочередное срабатывание логики (включая стейткод) у обоих кораблей.
ShipSetPartner - назначает кораблю напарника:
  1 - корабль-наёмник;
  2 - корабль-наниматель;
  3 - длительность контракта в днях (для разрыва деловых отношений просто подставить 0 во 2 и 3 аргументы);
ShipPartners - возвращает количество рейнджеров-партнёров у корабля, или конкретный корабль из этого списка:
  1 - корабль нанимателя (возвращает количество);
  Опционально:
  2 - номер партнёра в списке (возвращает корабль партнёра);
PlayerPirates - возвращает количество пиратов-партнёров у игрока:
  Без аргументов - возвращает количество пиратов-партнёров;
  Опционально:
  1 - номер партнёра в списке (возвращает корабль партнёра);
ShipIsPartner - проверяет, не находится ли корабль в подчинении у другого, возвращая корабль нанимателя, либо 0:
  1 - корабль;
  Примечание: Автоматический (!) наём партнёров и становление партнёром другого корабля не работает для скриптовых кораблей с несвободным поведением (любой стейт, кроме Free), а также для кораблей с наличием скриптового блока приказов OrderLock().
ShipInFear - проверяет, не находится ли корабль в данный момент в состоянии испуга:
  1 - корабль;
PirateType - возвращает подтип пирата:
  1 - корабль пирата:
     0 - обычный не клановый (вольный) или странствующий клановый пират;
   Далее идут подтипы клановых воинов, отличающихся лишь предпочтениями в эквипе и поведении:
     1 - пират-танк (самый бронированный пират, принимает на себя урон);
     2 - пират-снайпер (предпочитает дальнобойный пушки и держится на расстоянии);
     3 - пират-шустрик (использует небольшой корпус ради скорости и предпочитает пушки с большим количеством накладываемых дебафов);
  Примечание: Сменить подтип пирата можно с помощью функции ShipSubType.
ShipCalcParam - заставляет корабль принудительно пересчитать все свои параметры (имеет смысл добавлять, например, после искусственного обвеса бота и перед запуском ShipFreeSpace(), т.к. до обработки трюма корабля тёрн-кодом, он сам ещё пока не в курсе, что получил обвес):
  1 - корабль;
ShipFreeSpace - возвращает свободное место в трюме корабля (в том числе с отрицательным значением, если имеется перевес):
  1 - корабль;
ShipFreeFlight - разово запускает собственную классовую логику корабля (логика скриптового стейта в расчёт не принимается), позволяя ему выбрать свой план действий:
  1 - корабль;
  Примечание: Полезно, если ранее мы вмешались в его приказы, а сейчас нужно вновь вернуть корабль к самостоятельным действиям или просто узнать, что бы в текущей ситуации захотел сделать он сам. Также автоматически расставляет прицелы всех орудий корабля, поэтому последовательный запуск из стейткода ShipFreeFlight() и OrderNone() (любой приказ, в принципе), позволит вам получить корабль, автоматически стреляющий по мимо-астероидам и врагам, но выполняющий при этом все ваши приказы.
RangerPlaceInRating - место рейнджера в рейтинге рейнджеров:
  1 - рейнджер;
RangerExcludedFromRating - проверяет/изменяет статус рейнджера в едином списке рейнджеров:
  1 - рейнджер;
  Опционально:
  2 - добавить/исключить (0/1) рейнджера из единого рейтинга;


Доминаторы:
Blazer - без аргументов, возвращает Блазера (если он жив, иначе 0);
Keller - без аргументов, возвращает Келлера (если он жив, иначе 0);
Terron - без аргументов, возвращает Террона (если он жив, иначе 0);
HaveProgramm - проверяет, имеется ли у игрока указанная антидоминаторская программа:
  1 - номер программы;
GetProgramm - возвращает количество антидоминаторских программ указанного типа у игрока:
  1 - номер программы;
SetProgramm - устанавливает количество антидоминаторских программ указанного типа у игрока:
  1 - номер программы;
  2 - количество;
DomikProgramm - возвращает/применяет к кораблю доминатора указанную антидоминаторскую программу (программа будет активирована в тот же ход):
  1 - корабль доминатора (с одним аргументом вернёт текущую действующую на доминатора программу, либо 0);
  Опционально:
  2 - номер программы (при уже имеющейся активной программе заменит её на указанную);
  3 - максимальное количество предметов для сброса при активации "Аварийного сигнала" (по умолчанию сбросит стандартное количество);
  Примечание: Функция работает крайне дерьмово. Сперва необходимо проверять DomikProgrammDate() на факт наличия активной действующей программы и только затем проверять, какая именно программа активна с помощью DomikProgramm(). В частности это нужно для того, чтобы определить принадлежность возврата 0 (отсутствие активной программы, либо iКеллер). К тому же, даже единоразово срабатывающие программы, вроде "Аварийного сигнала" будут числиться активными после применения, несмотря на то, что срока действия они не имеют.
DomikProgrammDate - возвращает дату активации (когда была применена программа) текущей активной антидоминаторской программы на доминаторе, либо устанавливает длительность действия текущей этой программы (сперва необходимо применить к нему одну из программ с помощью DomikProgramm(), если активной программы на доминаторе нет, либо срок её действия закончился - вернёт 0):
  1 - корабль доминатора;
  2 - до какого числа должна действовать текущая активная программа (актуально для W-Кодера, Гатрикс матрицы и Шоккера-5300);
    Номера программ:
      0 - progKellerCall - iКеллер;
      1 - progLogicalNegation - Противодействие;
      2 - progDematerial - Дематериализатор;
      3 - progEnergotron - Энерготрон;
      4 - progSabCrack - Сабмодем;
      5 - progIntercom - Интерком;
      6 - progShipwreck - Аварийный сигнал;
      7 - progWeaponBlocking - W-Кодер (по умолчанию действует 10 дней);
      8 - progInsanity - Гатрикс матрица (по умолчанию действует 23 дня);
      9 - progShock - Шоккер-5300 (по умолчанию действует 7 дней);
      10 - progSelfDestruction - Абсолютное оружие (эффект идентичен выставлению ShipDestroy());
      11 - progDisconnection - Системное отключение (бессрочная программа, логика доминатора отключается навсегда);
NoComeKlingToStar - проверяет, устанавливает или снимает запрет доминаторам атаковать конкретную систему (также блокирует всякую возможность захвата системы любой стороной!):
  1 - система;
  Опционально:
  2 - если значение больше 0, то запретить атаковать систему;
ShipDestroyType - уничтожает всех блазероидов в Галактике, создана специально для скрипта Блазера, чтобы быстро уничтожить все его корабли при использовании антидоминаторской программы:
  1 - маркер об уничтожении, должен быть равен 1;
  Примечание: Если вызвать данную функцию без аргумента, либо установить иное значение кроме единицы, то она выполнит перебор всех блазероидов в Галактике, но при этом не сделает с ними ничего. Потому что логика.
PlayerMayTakeSubCrack - без аргументов, проверяет, может ли игрок в данный момент купить сабмодем на ПБ;
SubCrackCost - без аргументов, возвращает текущую стоимость сабмодема;
TerronWeaponLock - без аргументов, отключает всё оружие Террона (результат срабатывания Сабмодема);
TerronGrowLock - без аргументов, отключает спавн новых доминаторов Террону;
TerronLandingLock - без аргументов, позволяет совершить посадку на Террона для проведения планетарного боя;
TerronToStar - без аргументов, отправляет Террона преобразовывать звезду;
KellerLeave - без аргументов, отправляет Келлера к клиссанам;
KellerNewResearch - без аргументов, Келлер сотрудничает с пиратами в новых исследованиях:
  1 - Id системы для исследований;
KellerKill - без аргументов, уничтожает Келлера в АБ;
BlazerLanding - приземляет Блазера для сотрудничества с Коалицией:
  1 - Id планеты;
BlazerSelfDestruction - без аргументов, Блазер самоуничтожается;
DomiksDefeated - проверяет, не побеждены ли доминаторы:
  Без аргументов - общая проверка, побеждены ли все доминаторы (0/1);
  Опционально:
  1 - вернёт тип победы над конкретным боссом:
    0 - Блазер:
       0 - не побеждён;
       1 - уничтожен в бою;
       2 - самоуничтожился;
       3 - сотрудничает с Коалицией;
    1 - Келлер:
       0 - не побеждён;
       1 - уничтожен программой или как-либо ещё в космосе;
       2 - улетел к клисанам;
       3 - изучает пиратов;
    2 - Террон:
       0 - не побеждён;
       1 - уничтожен в бою;
       2 - преобразовывает звезду;
       3 - побеждён в наземном бою;
CoalitionDefeated - проверяет, не была ли побеждена Коалиция, или изменяет этот статус:
  Без аргументов - вернёт текущий статус;
  Опционально:
  1 - какой статус установить (0 - Коалиция не побеждена, 1 - побеждена);
  Примечание: Пока жив хотя бы игрок с Коалиционным овнером, Коалиция не считается полностью уничтоженной, даже если систем у неё совсем не осталось.


Сообщения и тексты:
NewsAdd - добавляет новость (идентична функции Ether(0, '', 'text')):
  1 - текст новости;
MsgAdd - добавляет на панель заметок сообщение о переговорах между игроком и одним из кораблей указанной скриптовой группы:
  1 - текст сообщения;
  2 - номер группы, также проверяет, успешно ли выполнена операция, условия успеха:
  - В указанной группе есть корабль;
  - Корабль в той же системе, что игрок;
  - Игрок не в гиперпространстве;
Ether - добавляет сообщение определённого типа на панель уведомлений:
  1 - тип сообщения, подставлять числом:
     0  - mp_Galaxy, общая галактическая новость (захваты систем и т.д.);
     1  - mp_Ether, переговоры других кораблей между собой;
     2  - mp_ShipPlus, что-то на корабле было отремонтировано (введено в строй после полной поломки) Нанитоидами;
     3  - mp_Quest, задание в процессе (не удаляется игроком);
     4  - mp_QuestOk, задание выполнено;
     5  - mp_QuestCancel, задание провалено;
     6  - mp_Tips, подсказка, как в обучении;
     7  - mp_User, информация, которую игрок решил сохранить сам (а также закреплённая информации с карты сокровищ), не проигрывает звук вывода уведомления;
     8  - mp_ShipMinus, что-то на корабле поломалось;
     9  - mp_Storage, список вещей вне корабля (не удаляется игроком);
     10 - mp_Ether2, переговоры других кораблей как-либо касающиеся игрока (иконка имеет чуть другой оттенок);
  2 - уникальный идентификатор сообщения (если в нём нет необходимости, то оставить пустую строку '');
  3 - текст сообщения;
  Опционально:
  4, 5, 6 - корабли, станции или планеты, на которые будет происходить центровка камеры при клике на Ether;
  Примечание: Если передать 4, 5 или 6 аргументами 0, то Ether не будет обновлён, т.к. код не знает что в таком случае ему делать. Также не будут обновлены другие Ether, кроме квестовых (3), если цель в 4, 5 или 6 аргументах находится в другой системе.
CustomEther - добавляет сообщение определённого типа на панель заметок с изменённым изображением сообщения,
  1 - название кастомного изображения из папки 'Bm.MsgPlayer.';
  2 - тип сообщения, подставлять числом:
     0  - 'Galaxy', общая галактическая новость (захваты систем и т.д.);
     1  - 'Ether', переговоры других кораблей между собой;
     2  - 'ShipPlus', что-то на корабле было отремонтировано (введено в строй после полной поломки) Нанитоидами;
     3  - 'Quest', задание в процессе (не удаляется игроком);
     4  - 'QuestOk', задание выполнено;
     5  - 'QuestCancel', задание провалено;
     6  - 'Tips', подсказка, как в обучении (проигрывает звук уведомления и не удаляется до тех пор, пока игрок его не прочитает);
     7  - 'User', информация, которую игрок решил сохранить сам (не проигрывает звук уведомления и может быть удалено только самим игроком), не проигрывает звук вывода уведомления;
     8  - 'ShipMinus', что-то на корабле поломалось;
     9  - 'Storage', список вещей вне корабля (не удаляется игроком);
     10 - 'Ether2', переговоры других кораблей как-либо касающиеся игрока (иконка имеет чуть другой оттенок);
  3 - уникальный идентификатор сообщения (если в нём нет необходимости, то оставить пустую строку '');
  4 - текст сообщения;
  Опционально:
  5, 6, 7 - корабли, на которые будет происходить центровка при клике на Ether;
  Примечание: Если передать 4, 5 или 6 аргументами 0, то Ether не будет обновлён, т.к. код не знает что в таком случае ему делать. Также не будут обновлены другие Ether, кроме квестовых (3), если цель в 4, 5 или 6 аргументах находится в другой системе, либо же на планете, станции или в гипере.
EtherDelete - удаляет Ether по его идентификатору:
  1 - идентификатор уведомления строкой;
EtherState - возвращает тип сообщения по его идентификатору:
  1 - идентификатор уведомления строкой (если сообщение с таким идентификатором отсутствует, вернёт -1):
     0  - mp_Galaxy, общая галактическая новость (захваты систем и т.д.);
     1  - mp_Ether, переговоры других кораблей между собой;
     2  - mp_ShipPlus, что-то на корабле было отремонтировано (введено в строй после полной поломки) Нанитоидами;
     3  - mp_Quest, задание в процессе (не удаляется игроком);
     4  - mp_QuestOk, задание выполнено;
     5  - mp_QuestCancel, задание провалено;
     6  - mp_Tips, подсказка, как в обучении (проигрывает звук уведомления и не удаляется до тех пор, пока игрок его не прочитает);
     7  - mp_User, информация, которую игрок решил сохранить (не проигрывает звук уведомления и может быть удалено только самим игроком);
     8  - mp_ShipMinus, что-то на корабле поломалось;
     9  - mp_Storage, список вещей вне корабля (не удаляется игроком);
     10 - mp_Ether2, переговоры других кораблей как-либо касающиеся игрока (имеют чуть другой оттенок);
EtherIdDelete - отцепляет квестовое уведомление от скрипта, чтобы при завершения скрипта статус такого уведомление не становился провальным:
  1 - идентификатор уведомления строкой;
EtherIdAdd - цепляет к скрипту уведомление с указанными идентификатором (предполагается, что перед этим оно будет отцеплено от предыдущего скрипта):
  1 - идентификатор уведомления строкой;
  Примечание: Обе этих функции необходимо вызывать из соответствующих скриптов.
Tips - выводит уведомление-подсказку (используются в начале игры) по её номеру в Lang (раздел 'Tips'):
  1 - номер подсказки, которую необходимо вывести;
TipsState - проверяет (возвращает 0/1), выводилась ли уже подсказка под указанным номером в Lang (раздел 'Tips'):
  1 - номер подсказки, которую необходимо проверить;
Dialog - запустить разговор с игроком (работает только в космосе), для начала разговора необходимо указать как минимум корабль вызывающего игрока NPC:
  1 - корабль, который должен начать разговор с игроком (можно вызывать, в том числе, из акткода), либо название диалога (без кавычек, т.к. переменная, сработает только при вызове из конкретного скрипта);
  Опционально:
  2, 3, 4 ... - список потенциальных кораблей-собеседников с игроком, если первым аргументом был указан диалог;
  Примечание: Если вам необходимо инициировать диалог из акткода, используйте для указателя на конкретный диалог в скрипте глобальную переменную или данные предмета/инфошки. При таком варианте, в скрипте диалог нужно ловить как обычный диалог с кораблём в космосе, но с проверкой значения соответствующей переменной/данных.
SkipGreeting - без аргументов, отключает текст стандартного приветствия для скриптовых диалогов на базах/планетах/кораблях;
  Примечание: Полезно, если вам необходимо добавить туда свой собственный текст, например через AddDialogInject() или AddDialogOverride().
DeleteTags - удаляет все тэги из строки, например тэги цветов:
  1 - исходная строка;
DChange - используется для перевода диалога на определённую реплику собеседника:
  1 - номер реплики собеседника DialogMsg (идентично прямому указателю стрелки на нужную реплику);
  Примечание: При использовании данной функции в коде, сразу после неё обычно подставляется оператор exit, чтобы прервать дальнейшее исполнение кода после смены реплики.
DText - отображает текст в текущем пустом диалоговом окне (вызывается из кода реплики DialogMsg):
  1 - текст;
DAddText - добавляет дополнительный текст в уже заполненное диалоговое окно (вызывается из кода реплики DialogMsg, но только после DText()):
  1 - текст;
DAdd - добавляет ответ по его номеру в скриптовом диалоге:
  1 - номер ответа DialogAnswer (идентично прямому указателю стрелки на нужный ответ);
AddDialogInject - добавляет новые варианты ответа в стандартный стартовый диалог, добавляет в приветственную реплику собеседника нужный текст, удаляет из приветственной реплики собеседника весь стандартный (не трогая текста других инжектов) текст:
  1 - название диалога (в виде строки), который запустится при выборе данного ответа (можно добавлять диалог из другого скрипта*);
  2 - текст, который будет добавлен к приветственной реплике собеседника (если текст не нужен, просто оставьте здесь пустую строку '');
  3 - текст добавляемого варианта ответа;
  4 - приоритет (чем больше число, тем выше диалог в списке относительно других инжектов, стандартные ответы из игры приоритета не имеют вовсе);
  Опционально:
  5 - флаг (если больше 0), очищающий весь стандартный (игровой) приветственный текст;
  6 - значение, которое будет присвоено глобальной игровой переменной GAnswerData (имеет тип dword);
  7 - исполняемый код в виде строки, который сработает при клике игрока по данному ответу;
InjectAnswer - добавляет ответ к скриптовому (!!!Сперва необходим AddDialogInject() или диалоговый объект!!!) диалогу:
  1 - название диалога (в виде строки), который запустится при выборе данного ответа (можно добавлять диалог из другого скрипта*);
  2 - текст ответа;
  3 - значение, которое будет присвоено глобальной игровой переменной GAnswerData (используется для передачи нужных значений или для определения, какой ответ был выбран, имеет тип dword);
  4 - исполняемый код в виде строки, который сработает при клике игрока по данному ответу;
  Функциональные диалоговые тэги для поля Name() в ответах:
  block - блокирует указанный ответ, автоматически перекрашивая его в серый цвет;
  snap - при клике по указанному ответу, положение вертикального скролла в диалоге не изменится (полезно при создании меню опций, когда выбор ответа не переключает диалог);
  planet - ответ автоматически переводит игрока из диалога с планетарным правительством на общий экран планеты (исполняет прикреплённый код);
  shop - ответ автоматически переводит игрока в магазин оборудования, если он есть (исполняет прикреплённый код);
  goods - ответ автоматически переводит игрока в магазин товаров, если он есть (исполняет прикреплённый код);
  hangar - ответ автоматически переводит игрока в ангар, если он есть (исполняет прикреплённый код);
  takeoff - ответ инициирует взлёт корабля (исполняет прикреплённый код);
  restart - делает рестарт текущего диалога (исполняет прикреплённый код);
  exit - выходит из текущего диалога (исполняет прикреплённый код);
  fastexit - выходит из текущего диалога (не исполняет прикреплённый после себя код и добавляет крестик для быстрого закрытия скриптовых диалогов в космосе);
    Примечание: В диалогах планет и станций fastexit не работает.
  <Object=adr,23,17,0> - при подстановке такого тэга в текст ответа, на его месте появится кнопка для центровки камеры на корабль-цель (актуально для диалогов в космосе), где:
     adr - адрес корабля в памяти;
     23,17,0 - прочие параметры отрисовки кнопки, как именно работают - неизвестно;
AddDialogOverride - заменяет стандартную стартовую реплику собеседника в диалоге на скриптовый диалог:
  1 - название диалога (в виде строки), которым будет заменён стандартный (можно добавлять диалог из другого скрипта*);
  2 - приоритет (имеет значение, если к стартовой реплике применяется сразу несколько таких операций, чтобы выбрать, какая конкретно будет выполнена);
  Опционально:
  3 - значение, которое будет присвоено глобальной игровой переменной GAnswerData (имеет тип dword);
  *Примечание: При подстановке имени диалога в функциях AddDialogInject(), InjectAnswer() и AddDialogOverride(), допустимо использовать строку вида 'Название_скрипта:Название_диалога' для подстановки в нужное место диалога из любого желаемого скрипта. Без указания имени скрипта будет выбран диалог из текущего.
DAnswer - функция добавления ответа, по умолчанию используемая компилятором в RScript:
  1 - текст добавляемого ответа;
  Примечание: Допускается добавлять к тексту ответа флаги типа restart, exit, hangar и т.д. Флаги добавляются прямо в текст, но с разделителем в виде ~ то есть запись ответа с флагом должна выглядеть примерно вот так DAnswer('restart~' + "Текст ответа"). Использовать данную функцию для добавления НЕ завершающих диалог реплик (то есть всех кроме restart и exit) неудобно, т.к. придётся вручную указывать номер следующего объекта, на который должен переводить ответ.
  DAnswer('main') - данная конструкция используется для создания стандартной "выходной" реплики в космическом диалоге. То есть сбросит диалог в самое начало, сохранив при этом последний текст ответа собеседника (подставлять в "Op" сразу после "выходной" реплики). Если после подстановки DAnswer('main') есть вероятность исполнения последующего кода или открытие диалоговых реплик, рекомендуется добавить exit во избежание непонятных крашей.
AddDialogBlock - ищет в вариантах ответа ответ с определённым текстом и на выбор удаляет или блокирует его:
  1 - текст ответа для поиска;
  2 - что сделать:
     0 - вариант останется обычным (кликабильным);
     1 - вариант станет серого цвета и будет некликабильным;
     2 - вариант пропадёт;
  Примечание: Добавлять данный блок необходимо ДО подстановки блокируемого ответа, а не после.
TalkByAI - без аргументов, проверка, что диалог с игроком инициировал NPC (1 - да, 0 - нет);
  Примечание: Если вы "искусственно" инициируете разговор NPC с игроком посредством функции Dialog(NPC) (например, через акткод), то проверка TalkByAI() будет возвращать 0.
GetTalkType - без аргументов, возвращает тип диалога с NPC (при вызове, исходящем от самого NPC) в космосе, варианты:
  0 - TalkMoney - корабль требует деньги;
  1 - TalkGoods - корабль требует груз;
  2 - TalkTruce - корабль предлагает перемирие;
  3 - TalkAttack - корабль предлагает совместную атаку;
  4 - TalkBreakPartner - партнёр разрывает контракт из-за плохого отношения к игроку или недостаточного рейтинга (в случае пиратов);
  5 - TalkPartnerTheEnd - вышел срок контракта;
  6 - TalkPartnerRiot - партнёр разрывает контракт, если по какой-то причине ведёт бой с другим партнёром игрока;
MessageBox - вызывает сообщение с кнопкой (как, например, при включении форсажа) может быть вызвана из диалога, стэйт кода или OnUseCode:
  1 - текст сообщения;
  Опционально:
  2 - флаг внешнего вида;
MessageBoxYesNo - вызывает сообщение с выбором да/нет (при выборе да возвращает 1, при нет 0):
  1 - текст сообщения;
  Опционально:
  2 - сет внешнего вида;
  Функции вывода сообщений могут визуально меняться в зависимости от суммы установленных флагов, ниже приведены значения, которые нужно суммировать во второй аргумент для получения той или иной комбинации визуального интерфейса сообщения (задать сет):
  1 - Ok - кнопка ОК (с галочкой);
  2 - Cancel - кнопка отмены (с крестиком);
  4 - IconInfo - бэкграунд с информационным сообщением (i) (как в большинстве месседжей);
  8 - IconWarning - бэкграунд с предупреждающим сообщением (!) (как на планетах с плохим отношением);
  16 - IconQuestion - бэкграунд с вопросительным сообщением (?) (как в стандартных месседжах вида YesNo);
  32 - IconError - бэкграунд с сообщением об ошибке (x) (как при попытке передвинуть корабль с нулевой скоростью);
  64 - AlignLeft - выравнивание текста по левому краю;
  По умолчанию (без флагов) выводятся стандартный информационный месседж с кнопкой отмены и стандартный вопросительный меседж YesNo с вопросительным сообщением.
CountBox - вызывает интерфейс с ползунком и выбором да/нет (как при выбросе товаров в космос или их покупке/продаже, если игрок нажал кнопку отмены - вернёт 'Cancel', иначе вернёт выбранное число):
  1 - строка пути к изображению в CacheData.dat (например, строка вида 'Bm.Items.2Minerals' добавит в интерфейс изображение минералов);
  2 - текст, отображаемый над счётчиком;
  3 - минимальное значение;
  Опционально:
  4 - максимальное значение;
  5 - цена за единицу, если != 0, то появится ещё и счётчик стоимости;
  6 - шаг изменения величины, по умолчанию 1 (опционально, но в любом случае не работает (видимо, пережиток из КР1, где шаг был кратен 5));
  7 - максимальное значение единиц, после которого блокируется утвердительный выбор;
  8 - максимальное значение единиц, после которого счётчик единиц становится красным;
  9 - максимальное значение кредитов, после которого счётчик кредитов становится красным;
  10 - по умолчанию предзаданное число на счётчике (в диапазоне минимального и максимального значений);
NumberBox - аналогичен CountBox(), однако все числовые аргументы и возвращаемое значение теперь dword вместо int, а отображаемый счётчик значения центрирован. Также кнопки увеличения и уменьшения значения счётчика NumberBox() имеют свойство увеличивать и понижать скорость накрутки счётчика в зависимости от продолжительности нажатия (если игрок нажал кнопку отмены - вернёт 'Cancel', иначе вернёт выбранное число):
  1 - путь к иконке, например: 'Bm.Items.2Minerals';
  2 - текст, отображаемый над счётчиком;
  3 - минимальное значение;
  4 - максимальное значение;
  Опционально:
  5 - максимальное разрешенное для выбора значение (при превышении утвердительный ответ блокируется и счётчик становится красным);
  6 - кастомная картинка полоски, на которой распологается счётчик (при добавлении этого аргумента, счётчик теряет центровку и принимает вид обычного счётчика из CountBox()), оставлять пустой строкой '', если замена не требуется;
  7 - по умолчанию предзаданное число на счётчике (в диапазоне минимального и максимального значений);
TextBox - вызывает интерфейс для ввода текста, возвращает строку с введённым текстом:
  1 - текст над полем ввода;
  Опционально:
  2 - предзаданный текст в поле ввода;
  3 - максимальное количество символов для ввода (по умолчанию 30, но можно установить и больше);
  Примечание: Сочетания клавиш Ctrl+C и Ctrl+V можно без проблем использовать для текста в открытом TextBox().
ListBox - вызывает блок со списком ответов, созданного из элементов указанного массива (будет брать значение элементов в виде str). После выбора конкретного варианта и нажатия "Да", возвращает индекс соответствующего элемента массива, а если был выбран ответ "Нет", то вернёт -1:
  1 - текст заголовка панели;
  2 - массив со строками, из которого будет сформирован список (начиная с элемента под индексом 0), либо первый вариант списка строкой;
  Опционально:
    3, 4, 5 и т.д. - прочие элементы списка в виде строк в случае, если 2 аргумент - не массив;


Функции для общей работы с различными объектами:
SetName - назначает имя кораблю или объекту:
  1 - корабль, планета, система или предмет;
  2 - строка нового имени;
Name - возвращает имя объекта:
  1 - объект:
    - система;
    - сектор;
    - планета;
    - корабль (вернёт полное имя);
    - предмет (вернёт имя без приписок всяких бонусов);
ShipName - возвращает не полное (без приставки типа) имя корабля (для возврата полного используйте Name):
  1 - корабль (пример, из "Лякуша Лошарик" вернёт "Лошарик");
  Примечание: Если ранее вы меняли имя корабля через SetName(), то вернёт уже изменённое, а не изначальное имя.
ShortName - аналог Name(), в случае если объект - корабль/станция, возвращает короткое имя (без приставки имени типа):
  1 - объект;
Id - возвращает Id любого объекта, имеющего Id:
  1 - объект;
  Примечание: Айдишники для чёрных дыр могут использоваться игрой повторно, но для всех прочих типов объектов они должны быть всегда уникальными. При запросе Id ракеты будет возвращён Id выпустившего её ракетомёта, либо 0, если ракета была создана скриптом.

GlobalRelationsPlanets - возвращает глобальное среднее отношение всех указанных заселённых планет к рейнджеру:
  1 - корабль рейнджера;
  2 - в каком месте проверять отношение планет:
     0 - глобальное отношение (менять по всей Галактике);
     != 0 указатель на какой-то конкретный объект (сектор, система), менять в пределах указанного объекта;
  3 - сет рас тех планет, общее отношение которых нужно проверить (пример - общее отношение всех планет малоков и гаальцев будет равно 17):
     1 - отношение любых малокских (не пиратских) планет;
     2 - отношение любых пеленгских (не пиратских) планет;
     4 - отношение любых человеческих (не пиратских) планет;
     8 - отношение любых фэянских (не пиратских) планет;
     16 - отношение любых гаальских (не пиратских) планет;
     31 - отношение планет любых рас Коалиции (1+2+4+8+16);
     128 - отношение любых пиратских планет (не работает, отношение пиратских планет и Роджерии не поменяются);
     159 - отношение вообще всех заселённых свободных планет (1+2+4+8+16+128) (не работает, отношение пиратских планет и Роджерии не поменяются);
ChangeGlobalRelationsPlanets - изменяет отношение всех указанных заселённых планет к рейнджеру:
  1 - корабль рейнджера;
  2 - в каком месте менять отношение планет:
     0 - глобальное отношение (менять по всей Галактике);
     != 0 указатель на какой-то конкретный объект (сектор, система), менять в пределах указанного объекта;
  3 - тип изменения:
     0 - снизить до определенного значения (не изменится, если уже и так ниже или равно данному значению);
     1 - повысить до определенного значения (аналогично);
     2 - прибавить определенное значение (не поднимется выше 100);
     3 - вычесть определенное значение (не опуститься ниже 0);
     4 - вычесть определенное значение, но так, чтобы отношение не опустилось ниже 10 (то есть не стало враждебным);
  4 - само значение;
  5 - сет рас тех планет, общее отношение которых нужно изменить:
     1 - отношение любых малокских (не пиратских) планет;
     2 - отношение любых пеленгских (не пиратских) планет;
     4 - отношение любых человеческих (не пиратских) планет;
     8 - отношение любых фэянских (не пиратских) планет;
     16 - отношение любых гаальских (не пиратских) планет;
     31 - отношение планет любых рас Коалиции (1+2+4+8+16);
     128 - отношение любых пиратских планет (не работает, отношение пиратских планет и Роджерии не поменяются);
     159 - отношение вообще всех заселённых свободных планет (1+2+4+8+16+128) (не работает, отношение пиратских планет и Роджерии не поменяются);
GlobalRelationsShips - возвращает среднее отношение всех указанных типов кораблей к рейнджеру:
  1 - корабль рейнджера;
  2 - в каком месте проверять отношение кораблей:
     0 - глобальное отношение (менять по всей Галактике);
     != 0 указатель на какой-то конкретный объект (сектор, система, планета), менять в пределах указанного объекта;
  3 - сет номерных типов кораблей (пропустит изменение отношения кораблей, если указать 0):
     1 - рейнджер;
     2 - военный (военные корабли не хранят отношений к рейнджерам, так что в этом параметре нет смысла);
     4 - пират;
     8 - транспорт;
     16 - лайнер;
     32 - дипломат;
  4 - сет рас пилотов кораблей, отношение которых нужно проверить:
     1 - отношение малокских кораблей;
     2 - отношение пеленгских кораблей;
     4 - отношение человеческих кораблей;
     8 - отношение фэянских кораблей;
     16 - отношение любых гаальских кораблей;
     31 - отношение кораблей любых рас Коалиции (1+2+4+8+16);
     128 - отношение пиратских кораблей;
     159 - отношение вообще всех коалиционных и пиратских кораблей (1+2+4+8+16+128);
ChangeGlobalRelationsShips - изменяет отношение всех указанных типов кораблей к рейнджеру:
  1 - корабль рейнджера;
  2 - в каком месте менять отношение кораблей:
     0 - глобальное отношение (менять по всей Галактике);
     != 0 указатель на какой-то конкретный объект (сектор, система, планета), менять в пределах указанного объекта;
  3 - тип изменения:
     0 - снизить до определенного значения (не изменится, если уже и так ниже или равно данному значению);
     1 - повысить до определенного значения (аналогично);
     2 - прибавить определенное значение (не поднимется выше 100);
     3 - вычесть определенное значение (не опуститься ниже 0);
     4 - вычесть определенное значение, но так, чтобы отношение не опустилось ниже 10 (то есть не стало враждебным);
  4 - само значение;
  5 - сет номерных типов кораблей (пропустит изменение отношения кораблей, если указать 0):
     1 - рейнджер;
     2 - военный (военные корабли не хранят отношений к рейнджерам, так что в этом параметре нет смысла);
     4 - пират;
     8 - транспорт;
     16 - лайнер;
     32 - дипломат;
  6 - сет рас пилотов кораблей, отношение которых нужно изменить:
     1 - отношение малокских кораблей;
     2 - отношение пеленгских кораблей;
     4 - отношение человеческих кораблей;
     8 - отношение фэянских кораблей;
     16 - отношение любых гаальских кораблей;
     31 - отношение кораблей любых рас Коалиции (1+2+4+8+16);
     128 - отношение пиратских кораблей;
     159 - отношение вообще всех коалиционных и пиратских кораблей (1+2+4+8+16+128);
Dist - возвращает расстояние между двумя объектами в системе:
  1 - первый объект;
  2 - второй объект;
    Возможные типы объектов:
      - корабль/станция;
      - ракета;
      - астероид;
      - предмет в космосе;
      - планета;
    - звезда (указывается система и любой другой объект в её пределах, вернёт расстояние до самой звезды в центре);
      - система (если оба указанных объекта системы, то вернёт дистанцию, а не парсеки);
      - скриптовое место;
StarMissiles - возвращает количество ракет в системе, или конкретную ракету в ней:
  1 - система (вернёт количество);
  Опционально:
  2 - номер ракеты в списке ракет системы (вернёт ракету);
StarAsteroids - возвращает количество астероидов в системе, или конкретный астероид в ней:
  1 - система (вернёт количество);
  Опционально:
  2 - номер астероида в списке астероидов системы (вернёт указанный астероид);
CoordX - возвращает/устанавливает значение X координаты для указанного объекта:
  1 - объект, возможные типы:
    - корабль/станция;
    - ракета;
    - астероид;
    - предмет в космосе;
    - планета;
    - система (координаты звезды на галакарте);
    - скриптовое место;
  Опционально:
  2 - новое значение X координаты;
CoordY - возвращает/устанавливает значение Y координаты для указанного объекта:
  1 - объект, возможные типы:
    - корабль/станция;
    - ракета;
    - астероид;
    - предмет в космосе;
    - планета;
    - система (координаты звезды на галакарте);
    - скриптовое место;
  Опционально:
  2 - новое значение Y координаты;
ShipSetCoords - установить координаты корабля/станции (фактически может работать как мгновенный телепорт внутри системы):
  1 - корабль;
  2 - координата X;
  3 - координата Y;
  Примечание: Аналогично можно менять координаты и другим объектам, включая системы на галакарте (не точно), но для этого нужно пользоваться отдельными функциями CoordX и CoordY. Если изменить координаты корабля, находящегося на планете или станции, то в космос он не перенесётся, однако координаты местонахождения в системе изменит.
Angle - возвращает угол между двумя объектами по часовой стрелке, где юг, это нулевой угол (для перевода в обратную точку отсчёта необходима функция) в виде int:
  1 - первый объект;
  2 - второй объект;
  Примечание: Функция перевода возврата данной функции в обратную точку отсчёта:
  function DabToNormal(dword angle)
  {
    result = abs(angle - 180);
  }
ShipAngle - возвращает/устанавливает угол направления носа корабля по часовой стрелке (где север, это нулевой угол) в виде float (передавать можно и int):
  1 - корабль (или станция, если на неё установлена hai анимация);
  Опционально:
  2 - новый угол поворота в градусах (направит корабль в другую сторону);
ObjectType - возвращает тип указанного объекта:
  1 - объект:
     0 - объект неопределяем, либо функции был передан 0;
     1 - звезда;
     2 - ЧД;
     3 - планета;
     4 - станция;
     5 - корабль;
     6 - предмет;
     7 - ракета/торпеда;
     8 - астероид;
AsteroidRespawn - респавнит (фактически, уничтожает без взрыва) указанный астероид:
  1 - астероид;
  Примечание: У каждой системы на всю игру имеется ограниченный набор астероидов. При уничтожении астероиды снова респавнятся на границе своей системы, не меняя визуальный скин до конца партии.
AsteroidMinerals - возвращает или устанавливает количество минералов в астероиде (возможный диапазон в одном астероиде 20-99):
  1 - астероид (вернёт значение);
  Опционально:
  2 - какое количество минералов установить (вернёт количество до изменения);
AsteroidGraph - возвращает или устанавливает внешний вид астероида:
  1 - астероид;
  Опционально:
  2 - путь к новой анимации астероида в Main.dat ('Data.SE');


Скриптовые объекты (скриптовые предметы):
  Примечание: Создаются в RScript, посредством объекта Item. Предмет в скриптовом объекте использовать намного удобнее, кроме того он получает полную защиту от авторасстрела NPC в космосе и не может быть по собственному желанию дропнут ими из трюма. В каждый скриптовый объект одновременно можно занести лишь один предмет.
ItemExist - проверяет, существует ли предмет в скриптовом объекте:
  1 - скриптовый объект (название без кавычек, т.к. это переменная);
ItemIn - проверяет, не находится ли предмет в скриптовом объекте в определённом месте:
  1 - скриптовый объект или предмет в нём;
  2 - место:
     - Конкретная система (предмет болтается в качестве лута в определённой системе);
     - Конкретный корабль (предмет в трюме у определённого корабля);
     - Конкретная планета (предмет находится на планете);
LinkItemToScript - занести предмет в скриптовый объект:
  1 - предмет;
  Опционально:
  2 - скриптовый объект (нужно указывать только в случае, если есть необходимость занести предмет в заранее созданный в скрипте объект);
  Примечание: Без указания второго аргумента предмет будет занесён в безымянный скриптовый объект, и не получит никакой "защиты" от действий ботов или игрока (запрет продажи такого предмета будет по умолчанию выключен).
ReleaseItemFromScript - удалить предмет из скриптового объекта (снять с него скрипт):
  1 - скриптовый объект;
ItemInScript - проверяет не занесён ли предмет в скриптовый объект:
  1 - предмет:
     0 - предмет не в скриптовом объекте;
     1 - предмет в скриптовом объекте;
     2 - предмет в скриптовом объекте, но не имеет никакой скриптовой "защиты" от ботов/продажи и т.д. (занесён в безымянный скриптовый объект);
ScriptItemData - возвращает/устанавливает числовые данные для скриптового объекта (не для предмета в нём!):
  1 - скриптовый объект или предмет в нём;
  2 - номер переменной (1-3) для записи типа int (Data1, Data2, Data3);
  Опционально:
  3 - какое значение переменной установить;
ScriptItemTextData - возвращает/устанавливает текстовые данные для скриптового объекта (не для предмета в нём!):
  1 - скриптовый объект или предмет в нём;
  2 - номер переменной (1-3) для записи типа str (TextData1, TextData2, TextData3);
  Опционально:
  3 - какое значение переменной установить;
  Важно: (!!!) Скрипт автоматически не очищает данные скриптового объекта после релиза/удаления предмета, находящегося в нём. Так что в случае чего чистить все эти переменные необходимо вручную!
  Примечание: Значения данных переменных будут автоматически подставляться в описание скриптового предмета при наличии в нём тэгов <Data1>, <TextData1> и т.д. Это также работает и применительно к описаниям скриптового оборудования, однако добавить в него соответствующие тэги возможно только с помощью акринов.
ScriptItemToItem - возвращает непосредственно предмет, занесённый в скриптовый объект:
  1 - скриптовый объект;
DropScriptItem - заставляет корабль выбросить за борт предмет в скриптовом объекте:
  1 - корабль;
  2 - скриптовый объект или предмет в нём;
CanSellItem - проверяет/включает/отключает возможность продажи предмета в скриптовом объекте (по умолчанию продавать нельзя):
  1 - скриптовый объект или предмет в нём;
  Опционально:
  2 - установить/снять разрешение для продажи 0/1;
ItemOnActCode - возвращает строку OnActCode скриптового объекта (!!!) или устанавливает её (при установке старая строка акткода удаляется):
  1 - скриптовый объект или предмет в нём;
  Опционально:
  2 - строка с кодом, для установки объекту в качестве OnActCode (из данного акткода можно будет видеть и менять значения переменных в соответствующем скрипте);
  3 - строка фильтров для событий акткода, идентично значению параметра OnActCodeTypes;
  4 - строка фильтров для шагов события t_OnStep акткода, идентично значению параметра OnActStepTypes;
ItemOnUseCode - возвращает строку OnUseCode скриптового объекта (!!!) или устанавливает её (при установке старая строка юзкода удаляется):
  1 - скриптовый объект или предмет в нём;
  Опционально:
  2 - строка с кодом, для установки объекту в качестве OnUseCode (из данного юзкода можно будет видеть и менять значения переменных в соответствующем скрипте);
 Примечание: Если строка с кодом берётся из раздела в Lang, то перед назначением предмету она должна быть предварительно скомпонована в доступный компилятору вид с помощью функции GenerateCodeStringFromBlock().


Предметы:
IdToItem - возвращает предмет по его Id (в том числе предмет, который находится в хранилище):
  1 - Id предмета;
ItemDestroy - уничтожает предмет в космосе:
  1 - предмет;
  2 - тип взрыва:
    -N - актуально для события t_OnItemHit - отменяет уничтожение предмета от попадания N числа выстрелов или ракет (чем ниже значение, тем больше попаданий будет проигнорировано);
     0 - предмет спокойно существует и не готовится быть уничтоженным;
     1 - обычный взрыв;
     2 - взрыв как у бочки с горючим (урон по области есть, но дистанция от эпицентра взрыва никак не учитывается), также данный взрыв не сработает, если в предмет до взрыва попадёт ракета или торпеда;
   Примечание: При выставлении второго аргумента в значение 2, взрыв "бочки" получит фиксированный урон в 800 единиц, но если значение будет выше, то взрыв получит урон, равный переданному значению.
   Примечание: При выставлении отрицательного маркера можно установить туда любое отрицательное число. Тогда каждое срабатывание t_OnItemHit для данного предмета будет плюсовать к отрицательному значению по единице вплоть до выхода счётчика в плюс и уничтожения предмета (если значение ItemDestroy() для предмета при попадании равно 0, то вывод значения маркера в плюс будет осуществляться сразу два раза). Актуально для тех предметов, у которых нет собственного акткода, но которые всё равно нужно временно оградить от уничтожения.
  Примечание: Помеченный на уничтожение предмет автоматически блокируется для подбора всеми NPC (но не игроком), так что, выставляя этот маркер на время, можно блокировать нежелательную "кражу" предмета ботами.
ItemCount - возвращает количество предметов указанного типа на корабле:
  1 - корабль;
  2 - тип предмета;
UselessItemCreate - создаёт Useless предмет и сразу же заносит его в скрипт (применяется только из кода скрипта):
  1 - системное название предмета строкой (список находится в 'Lang.dat/UselessItems');
  2 - название скриптового объекта, в который нужно поместить данный предмет;
  3 - скриптовое место, в котором появится данный предмет;
CreateQuestItem - создаёт UselessItem (ошмёток, квестовые предметы и прочие юзлесы):
  1 - системное название предмета строкой (список находится в 'Lang.dat/UselessItems');
  Опционально:
  2 - раса-производитель (по умолчанию устанавливается неизвестная);
UselessItemText - возвращает (только в том случае, если оно было установлено этой функцией, но не дефолтное!) или устанавливает описание для UselessItem:
  1 - предмет;
  Опционально:
  2 - какое описание установить;
UselessItemData - возвращает/устанавливает значение внутренней int перемененной Useless предмета:
  1 - предмет;
  2 - номер переменной (от 1 до 3);
  Опционально:
  3 - какое значение переменной установить (при подстановке тэга вида <Data1> в описание данного предмета, игра автоматически подставляет в то место значение соответствующей переменной);
ShipItems - возвращает общее количество, или конкретный предмет из трюма:
  1 - корабль;
  Опционально:
  2 - номер предмета в списке предметов корабля (учтите, что под номером 0 всегда находится и всегда должен находиться корпус корабля);
ItemType - возвращает тип предмета:
  1 - предмет (список всех типов в конце документа);
ItemName - возвращает общее название предмета, например для любого двигателя вернёт строку 'Двигатель':
  1 - предмет;
ItemFullName - возвращает полное имя предмета, в том числе с установленным ММ:
  1 - предмет;
ItemSize - вернёт текущий размер предмета или задаст его:
  1 - предмет (вернёт размер);
  Опционально:
  2 - какой размер установить (вернёт размер до изменения);
  Примечание: При помещении на корабль/станцию предмета с отрицательной массой, объём свободного пространства в трюме будет расширен на отрицательное значение массы. При изменении размера корпуса, корабль NPC не сразу "сообразит", что его корабль получил другие параметры, поэтому после смены размера корпуса рекомендуется также вызывать функцию ShipCalcParam().
ContainerFuel - возвращает/устанавливает количество топлива в баке/цистерне:
  1 - бак/цистерна;
  Опционально:
  2 - какое количество топлива установить;
ItemCharge - возвращает/устанавливает заряд для предметов с зарядом, например, для трансфакторных маяков:
  1 - предмет;
  2 - заряд, который необходимо установить;
ItemOwner - вернёт производителя предмета или установит его:
  1 - предмет (вернёт производителя);
  Опционально:
  2 - какого производителя установить (вернёт производителя до изменения):
    0 или Maloc - малокский производитель;
    1 или Peleng - пеленгский производитель;
    2 или People - человеческий производитель;
    3 или Fei - фэянский производитель;
    4 или Gaal - гаальский производитель;
    5 или Kling - доминаторский производитель;    
    6 или None - неизвестный производитель;
    7 или PirateClan - пиратский производитель;
ItemSubrace - возвращает или устанавливает доминаторскую серию предмета:
  1 - предмет (вернёт серию);
  Опционально:
  2 - какую серию установить (вернёт серию до изменения):
     0 - блазероидная;
     1 - келлероидная;
     2 - терроноидная;
     6 - клисане, кастомная серия из мода ShuKlissan;
     3-255 (кроме 6) - все прочие возможные серии, не используемые в ваниле;
  Примечание: На данный момент единственная функция в оригинальном движке (есть ещё ShipSubrace() в моде UtilityFunctionsPack) для определения доминаторской серии корабля. Серия доминатора определяется по серии его корпуса.
EqCustomFaction - возвращает или устанавливает кастомную фракцию для любого предмета:
  1 - предмет;
  Опционально:
  2 - системное название фракции, которую надо установить предмету (иконка фракции будет взята из Data.Race.Emblem.2your_faction_name в мейне, аналогично её нужно будет прописать и для кэша, формат Png);
  Примечание: Если кастомная фракция была наложена на предмет с неизвестной расой, то все его базовые свойства (вроде совместимости с артефактами, ММ и акринами) будут отключены. Во всех остальных случаях (любая базовая раса кроме неизвестной), свойства предмета с кастомной фракцией отключены не будут. Также в параметр Owner у ММ и акринов можно прописывать название кастомной фракции, с предметами которой данный бонус станет совместим вне зависимости от базовой расы предмета.
ItemCost - вернёт текущую цену предмета или установит её:
  1 - предмет (вернёт стоимость);
  Опционально:
  2 - какую цену установить (вернёт стоимость до изменения);
ItemIsInUse - проверяет, надет ли предмет на корабль/станцию, либо надевает его:
  1 - предмет;
  Опционально:
  2 - корабль (вернёт номер слота в котором установлен предмет, что актуально для оружия (1-5) и артефактов (1-4), а для всех прочих предметов будет всегда  возвращать 1);
  3 - 0/1 снять/надеть указанный предмет;
  4 - номер слота, в который нужно экипировать предмет (актуально для оружия (1-5) и артефактов (1-4), также можно (но не обязательно) подставлять 1 для всех прочих типов предметов);
  Примечание: Надевать можно не только оборудование, но и, например, UselessItem, который пропадёт из трюма, но останется висеть на корабле в "невидимом" состоянии. Таким образом можно полностью скрывать присутствие на корабле определённых вещей (вылетать из экипировки они не будут даже при смене комплектаций). Правда, для сокрытия счетчика занятого в трюме места придётся также прибегнуть к несколько большим ухищрениям с подменой самого счетчика на кастомный Label.
ItemIsInSet - проверит используется ли предмет в любом из сетов:
  1 - предмет;
  Опционально:
  2 - к какому сету прикрепить предмет;
PlayerEqSet - возвращает текущий активный сет:
  Без аргументов - вернёт номер активного сета;
  Опционально:
  1 - номер конкретного сета для получения информации по нему:
     0 - если такого сета ещё нет;
     1 - если сет есть, но он не активен;
     2 - если сет есть, и именно он сейчас активен;
HullType - возвращает или устанавливает тип указанного корпуса:
  1 - сам корпус или использующий его корабль;
  Опционально:
  2 - какой тип установить:
     0 - корпус рейнджера;
     1 - корпус военного;
     2 - корпус пирата;
     3 - корпус транспорта;
     4 - корпус лайнера;
     5 - корпус дипломата;
   Приведут к крашу (не приведут, если сразу после создания наложить на них акрин):
     6 - корпус доминатора (все резисты всегда по 100%, что может быть полезно при создании своего акринового корпуса);
     7 - корпус транклюкатора;
     8 - корпус станции;
     9 - корпус с любым акрином (внутренний тип, автоматически подставляется любому стандартному корпусу при его акринации);
     10 - корпус флагмана (а этот к крашу не приведёт, однако в оригинальной игре таким корпусам не хватает "складских" пикч);
CreateHull - создаёт стандартный корпус и возвращает на него ссылку:
  1 - тип корпуса;
  2 - размер;
  3 - ТУ;
  4 - раса-производитель;
  Опционально:
  5 - номер серии (без серии -1, по умолчанию выбирается случайная серия, подходящая по типу корпуса);
  6 - флаг (0/1) о том, что корпус нужно считать клановым (появится символ клановой эмблемы с цветом расы-производителя);
  Примечание: Флаг в шестом аргументе можно выставлять только для корпусов с НЕ пиратским овнером. В противном случае в коде будет выставлен путь к иконке "2PirateClanPirateClan", которой по умолчанию в игровых файлах не существует.
SeriesCount - без аргументов, возвращает общее число доступных корпусных серий;
FindSeriesByName - поиск номера серии по её имени:
  1 - имя нужной серии;
HullSeries - возвращает (при отсутствии серии -1) или устанавливает серию корпуса:
  1 - корпус;
  Опционально:
  2 - номер серии, которую нужно установить (-1 - снять серию);
SeriesNumInCfg - возвращает раздел Lang, в котором прописана определённая серия:
  1 - номер серии (при несуществующем номере серии вернёт '');
CreateEquipment - создаёт оборудование/оружие (только оригинальное) или цистерну (но не корпус!), и возвращает указатель:
  1 - тип оборудования/оружия (полный перечень в конце списка);
  2 - размер оборудования;
  3 - технологический уровень (или текущее количество топлива для цистерны, если создаёте цистерну);
  4 - раса-производитель;
  Примечание: Тип t_CustomWeapon считается невалидным и при подстановке будет вызывать краш.
CreateEquipmentWithSpecial - создаёт оборудование/оружие (только оригинальное) с указанным акрином, при этом тип создаваемого оборудования будет автоматически взят из раздела акрина в Lang (если акрин может висеть на нескольких типах оборудования, выбирается случайный тип из этого списка):
  1 - номер бонуса (при подстановке бонуса, рассчитанного только для кастомных орудий, вернёт 0);
  2 - размер оборудования;
  3 - технологический уровень;
  4 - раса-производитель;
  Примечание: Данная функция используется для упрощения создания оборудования с произвольным акрином, без необходимости перебирать типы пригодного для акринации оборудования функцией MayAddBonusToEq.
GetEquipmentStats - возвращает определённый параметр предмета:
  1 - предмет;
  2 - параметр:
     Доступные для запроса параметры:
     Корпус:
        0 - броня;
        1 - количество открытых слотов под оружие;
        2 - количество открытых слотов под артефакты;
        3 - открыт ли слот радара;
        4 - открыт ли слот сканера;
        5 - открыт ли слот дроида;
        6 - открыт ли слот захвата;
        7 - открыт ли слот ГЗП;
        8 - открыт ли форсаж;
       Примечание: Доступность слотов проверяется с учётом всех применённых к корпусу бонусов и ограничений серии.
     Оружие:
        0 - максимальный урон;
        1 - минимальный урон;
        2 - дальность;
        3 - базовый тип урона (0 - энергетический, 1 - осколочный, 2 - ракетный);
        4 - количество выстрелов за ход;
        5 - количество залпов (например, ракет) в выстреле;
        6 - полный дамагсет с учётом всех бонусов;
     Двигатель:
        0 - скорость;
      1 - дальность прыжка;
     Топливный бак:
        0 - ёмкость;
      1 - текущее количество топлива;
     Радар:
        0 - дальность;
     Сканер:
        0 - мощность;
     Дроид:
        0 - эффективность ремонта;
     Захват:
        0 - размер захватываемых объектов;
      1 - дальность захвата;
      2 - скорость притяжения захвата на дальней дистанции (наименьшая) в виде float;
      3 - скорость притяжения захвата на ближней дистанции (наибольшая) в виде float;
     Генератор защитного поля (ГЗП):
        0 - процент поглощения урона;
     Исследовательский зонд:
        0 - вода;
        1 - равнина;
        2 - горы;
        3 - надёжность (Fragility) зонда в виде float;
     Цистерна:
        0 - ёмкость;
      1 - текущее количество топлива;
      Примечание: При указании в запросе номера параметра, которого у предмета нет (к примеру, запросить 1 для радара), будет возвращён 0. Также имейте в виду, что указанные в карточке N + X значения параметра при установленном ММ, данная функция вернёт уже в просуммированном виде. Для корректного выделения значения параметра, полученного от ММ, ММ перед проверкой необходимо будет извлечь.
  Альтернативный вид запроса GetEquipmentStats() - запрос статов предмета в виде готовой строки с целью подстановки куда-либо. При передаче данной функции строки в качестве второго аргумента, все перечисленные ниже тэги в передаваемой строке, будут заменены на соответствующие параметры. Возвратом функции в таком случае будет являться переданная строка с автоматически произведённой заменой всех указанных тэгов:
     Корпус:
       '<FragilityE>' - восприимчивость к энергетическому урону;
       '<FragilityS>' - восприимчивость к осколочному урону;
       '<FragilityM>' - восприимчивость к ракетному урону;
       '<HitProtect>' - броня;
     Оружие:
       '<MaxDamage><Bonus>' - максимальный урон (<Bonus> добавляет значения бонусов от ММ и акринов и подставляется отдельно от основного тэга только для урона);
       '<MinDamage>' - минимальный урон (тэг <Bonus> может быть также подставлен и сюда, но зачем?);
       '<Radius>' - дальность;
       '<CntAttacks>' - количество выстрелов за ход;
       '<CntShots>' - количество залпов (например, ракет) в выстреле;
       '<Count>' - текущее число зарядов в оружии;
       '<MaxCount>' - максимальное число зарядов в оружии;
     Двигатель:
       '<Speed>' - скорость;
       '<Parsec>' - дальность прыжка;
     Топливный бак:
       '<Capacity>' - ёмкость;
     Радар:
       '<Radius>' - дальность;
     Сканер:
       '<Percent>' - мощность;
     Дроид:
       '<RecoverHitPoints>' - эффективность ремонта;
     Захват:
       '<PickUpSize>' - размер захватываемых объектов;
       '<Radius>' - дальность захвата;
       '<SpeedMin>' - скорость притяжения захвата на дальней дистанции (наименьшая) в виде float;
       '<SpeedMax>' - скорость притяжения захвата на ближней дистанции (наибольшая) в виде float;
     Генератор защитного поля (ГЗП):
       '<Percent>' - процент поглощения урона;
SetEquipmentStats - по аналогии с GetEquipmentStats(), устанавливает значения параметрам предмета:
  1 - предмет;
  2 - новое значение;
  3 - параметр (!!!Обратите внимание, что очерёдность аргументов тут дебильная!!!):
    Доступные для изменения параметры:
     Корпус:
        0 - броня;
     Оружие:
        0 - максимальный урон;
        1 - минимальный урон;
        2 - дальность;
     Двигатель:
        0 - скорость;
      1 - дальность прыжка;
     Топливный бак:
        0 - ёмкость;
      1 - текущее количество топлива;
     Радар:
        0 - дальность;
     Сканер:
        0 - мощность;
     Дроид:
        0 - эффективность ремонта;
     Захват:
        0 - размер захватываемых объектов;
      1 - дальность;
      2 - скорость притяжения захвата на дальней дистанции (наименьшая) в виде float;
      3 - скорость притяжения захвата на ближней дистанции (наибольшая) в виде float;
     Генератор защитного поля (ГЗП):
        0 - процент поглощения урона;
     Исследовательский зонд:
        0 - вода;
      1 - равнина;
      2 - горы;
      3 - надёжность (Fragility) зонда в виде float;
     Цистерна:
        0 - ёмкость;
      1 - текущее количество топлива;
      Примечание: При указании в запросе номера параметра, которого у предмета нет/не доступен для изменения (к примеру, попытаться установить 3 для оружия), параметр изменён не будет.
  Примечание: Если значение параметра не равно базовым статам для текущего ТУ данного типа предмета (с учётом вставленных ММ), то такой предмет будет считаться улучшенным.
EquipmentImageName - возвращает или изменяет системное имя (из Lang), а попутно и картинку предмета, работает с предметами или кораблём транклюкатора, для кастомных артефактов меняет тип артефакта:
  1 - предмет;
  Опционально:
  2 - новое системное имя;
DropItemInSystem - выбрасывает (не обязательно из трюма или из хранилища) предмет в космосе в определённой системе по определённым координатам:
  1 - система;
  2 - предмет;
  3 - начальная X координата (точка появления предмета, откуда он начнёт движение);
  4 - начальная Y координата;
  5 - конечная X координата (точка завершения движения предмета, место, где он остановится);
  6 - конечная Y координата;
StopMovingItem - останавливает движущийся по системе предмет:
  1 - система;
  2 - предмет (желательно использовать сразу после DropItemInSystem() (если последняя не была задействована из акткода), чтобы предмет появился в своих конечных координатах сразу, а не с началом расчёта хода);
StarItems - возвращает количество лута в системе, или конкретный предмет из списка лута:
  1 - система;
  Опционально:
  2 - номер предмета из списка лута;
StorageItems - возвращает количество предметов на складе (общего для всех планет и баз в Галактике) или конкретный предмет:
  Без аргумента - возвращает количество предметов на складе;
  Опционально:
  1 - номер предмета в списке предметов склада (возвращает конкретный предмет);
StorageItemLocation - возвращает местоположение предмета на складе (планету или базу):
  1 - номер предмета в списке предметов склада;
ShopItems - возвращает количество предметов в магазине оборудования или конкретный предмет из этого списка:
  1 - магазин (планета или станция);
  Опционально:
  2 - номер предмета в списке;
PlanetItems - возвращает количество предметов на поверхности планеты или конкретный предмет из этого списка:
  1 - планета (возвращает количество);
  Опционально:
  2 - номер предмета в списке (возвращает предмет);
CreateZond - создаёт зонд и возвращает на него ссылку:
  1 - ТУ (в оригинале от 0 до 5, в моде EvoSB до 7);
  2 - раса-производитель;
  Опционально:
  3 - скорость исследования воды;
  4 - скорость исследования равнин;
  5 - скорость исследования гор;
  По умолчанию берёт базовые характеристики из Lang с 20% шансом на +1 к одной случайной (20% вода, 20% равнины и 20% горы), и с 40% шансом не выдать доп. стат вовсе.
  В оригинале, обновление продающегося на станции зонда может происходить хоть каждый день с шансом 1 к 17.
ExistingZonds - без аргумента возвращает общее количество зондов у игрока:
  1 - возвращает зонд по номеру (начиная с 0), если он в данный момент работает на планете, а все нерабочие зонды всегда будут в конце "списка" с возвратом 0;
  2 - маркер (если больше 0), для возврата планеты, на которой сейчас работает зонд (если он работает);
CreateCustomCountableItem - создаёт кастомный сыпучий (разделяемый) предмет:
  1 - системное имя предмета из Lang строкой;
  2 - количество:
     Номера картинок, используемые при разных размерах стака сыпучего предмета:
       0 - при размере стака до 999 единиц;
       1 - при размере стака от 1000 до 1999 единиц;
       2 - при размере стака от 2000 до 3999 единиц;
       3 - при размере стака от 4000 до 7999 единиц;
       4 - при размере стака от 8000 единиц и выше;
  Опционально:
  3 - вид анимации предмета в космосе, если предмет планируется добавлять непосредственно туда, либо в дроп к кораблю;
     0 - анимация предмета в стандартном грузовом контейнере (вариант по умолчанию);
     1 - собственная анимация предмета (если таковой не прописано, произойдёт краш);
AddItemToShop - добавляет предмет в магазин:
  1 - магазин (планета или станция);
  2 - предмет (по умолчанию работает только для оборудования, но можно добавить графических ресурсов для отображения в магазине любого другого предмета):
    Принцип определения фона под предметом (с изображением уровней) работает следующим образом. Игра проверяет тип предмета, и составляет строку вида '2SlotCargoHook_4' - где последняя цифра - это ТУ оборудования, либо, например, '2ArtRadar' для любых предметов, у которых уровней нет. Если по данному имени игра найдёт графику в папке FormShop2, то подставит соответствующий фон, иначе подставит стандартный фон с уровнем для любого оборудования, и фон по имени '2SlotArtefact' для любого артефакта (в т.ч. любого кастомного). Для всех прочих предметов по умолчанию будет взят фон '2SlotLevel0'.
  Список возможных названий фона:
    '2SlotFood' - еда;
    '2SlotMedicine' - медикаменты;
    '2SlotTechnics' - техника;
    '2SlotLuxury' - роскошь;
    '2SlotMinerals' - минералы;
    '2SlotAlcohol' - алкоголь;
    '2SlotArms' - оружие;
    '2SlotNarcotics' - наркотики;
     Примечание: Попытка добавить товары в магазин оборудования, скорее всего, приведёт к крашу.
      '2SlotHull_N' - корпус с номером уровня;
    '2SlotFuelTanks_N' - топливный бак с номером уровня;
    '2SlotEngine_N' - двигатель с номером уровня;
    '2SlotRadar_N' - радар с номером уровня;
    '2SlotScaner_N' - сканер с номером уровня;
    '2SlotRepairRobot_N' - дроид с номером уровня;
      '2SlotCargoHook_N' - захват с номером уровня;
    '2SlotDefGenerator_N' - ГЗП с номером уровня;
    '2SlotWeapon_N' - любое оружие (в т.ч. кастомное) с номером уровня;
      '2SlotArtHull', '2SlotArtFuel', '2SlotArtSpeed', '2SlotArtPower', '2SlotArtRadar', '2SlotArtScaner', '2SlotArtDroid', '2SlotArtNano', '2SlotArtHook', '2SlotArtDef', '2SlotArtAnalyzer', '2SlotArtMiniExpl', '2SlotArtAntigrav', '2SlotArtTransmitter', '2SlotArtBomb', '2SlotArtTranclucator', '2SlotArtDefToEnergy', '2SlotArtEnergyPulse', '2SlotArtEnergyDef', '2SlotArtSplinter', '2SlotArtDecelerate', '2SlotArtMissileDef', '2SlotArtForsage', '2SlotArtWeaponToSpeed', '2SlotArtGiperJump', '2SlotArtBlackHole', '2SlotArtDefToArms1', '2SlotArtDefToArms2', '2SlotArtArtefactor', '2SlotArtBio', '2SlotArtPDTurret', '2SlotArtFastRacks' - индивидуальные типы оригинальных артефактов, расшифровка имён внизу списка функций;
    '2SlotArtefact' - любой кастомный артефакт, либо оригинальный артефакт без индивидуального фона;
    '2SlotUselessItem' - любой квестовый (не имеющий базовых свойств) предмет;
      '2SlotUselessCountableItem' - квестовый сыпучий (разделяемый);
      Примечание: Для всех предметов, имеющий системное имя типа в Lang (артефакты, юзлесы и т.д.), возможно добавление индивидуальной иконки фона по её имени (пример: '2SlotYourArtName'), которая будет считаться приоритетной по отношению к иконке общего типа данного предмета.
    '2SlotNod_1' - ММ третьего уровня со стандартной графикой;
    '2SlotNod_2' - ММ второго уровня со стандартной графикой;
    '2SlotNod_3' - ММ первого уровня со стандартной графикой;
    '2SlotYourGraphName_1' - ММ третьего уровня с кастомной графикой (параметр KindGraph) 'YourGraphName';
    '2SlotYourGraphName_2' - ММ второго уровня с кастомной графикой (параметр KindGraph) 'YourGraphName';
    '2SlotYourGraphName_3' - ММ первого уровня с кастомной графикой (параметр KindGraph) 'YourGraphName';
      '2SlotProtoplasm' - ноды;
    '2SlotCistern' - цистерна;
    '2SlotSatellite' - зонд;
    '2SlotTreasureMap' - карта сокровищ;
GetItemFromShop - изымает предмет из магазина (возвращает указатель на изъятый предмет):
  1 - магазин (планета или база);
  2 - сам предмет (при передаче переменной типа dword) или номер предмета (при передаче переменной типа int) в списке предметов магазина;
AddItemToShip - добавляет предмет в трюм корабля:
  1 - корабль;
  2 - предмет;
  Примечание: Если с помощью данной функции на корабль добавляется корпус, то при отсутствии активного корпуса в списке предметов корабля под номером 0 (если старый корпус предварительно изъяли с помощью GetItemFromShip()), добавляемый корпус будет автоматически установлен в качестве основного. Графика корпуса, однако, при этом заменена не будет, так что потребуется ещё вручную вызвать Chameleon().
FindItemInShip - ищет определённый предмет/артефакт на корабле, и при успехе возвращает его номер (при неудаче вернёт -1) в списке предметов/артефактов корабля:
  1 - корабль;
  2 - предмет;
GetItemFromShip - изымает предмет из трюма корабля (возвращает указатель на изъятый предмет):
  1 - корабль;
  2 - сам предмет (при передаче переменной типа dword) или номер предмета (при передаче переменной типа int) в списке предметов корабля;
GetArtFromShip - аналогично GetItemFromShip(), но изымает артефакт из трюма корабля, т.к. все артефакты хранятся на корабле отдельным списком (возвращает указатель на изъятый артефакт):
  1 - корабль;
  2 - сам артефакт (при передаче переменной типа dword) или номер артефакта (при передаче переменной типа int) в списке артефактов корабля;
AddItemToPlanet - добавляет предмет на поверхность незаселённой планеты (может добавить и на заселённую, однако смысла в этом нет):
  1 - планета;
  2 - предмет;
  Примечание: При добавлении предмета на ещё не полностью исследованную (либо на полностью неисследованную) незаселённую планету он будет автоматически спрятан где-то в неисследованных территориях. При добавлении же предмета на полностью исследованную незаселенную планету, она обнулит свой статус и вновь станет полностью неисследованной, а предмет будет спрятан на ней как обычно.
GetItemFromPlanet - изымает предмет с поверхности планеты (возвращает указатель на изъятый предмет):
  1 - планета;
  2 - номер предмета в списке предметов планеты;
GetItemFromStar - изымает предмет, валяющийся в качестве лута в открытом космосе в определённой системе (возвращает указатель на изъятый предмет):
  1 - система;
  2 - сам предмет (при передаче переменной типа dword) или номер предмета (при передаче переменной типа int) в списке предметов системы;
AddItemToStorage - добавляет предмет на склад:
  1 - склад (планета или станция);
  2 - предмет;
FindItemInStorage - возвращает номер предмета в списке предметов хранилища (вернёт -1, если предмета на складе нет):
  1 - предмет;
GetItemFromStorage - изымает предмет со склада (возвращает указатель на изъятый предмет):
  1 - номер предмета в списке склада игрока (склад игрока это единый массив, где каждому предмету дополнительно присвоено его конкретное местонахождение (планета или станция));
PutItemInVault - помещает предмет в невидимое хранилище:
  1 - строковая метка, которая будет обозначать переносимый в хранилище предмет (удобно указывать Id предмета, можно вместе с контрольным словом);
  2 - предмет (если передать 0, то очистит всю переменную и удалит записанный по данному маркеру предмет);
  Примечание: Если по определённой строковой метке в хранилище уже лежит какой-то предмет, то при занесении нового старый предмет будет автоматически удалён.
GetItemFromVault - изымает предмет из невидимого хранилища (возвращает указатель на изъятый предмет, либо 0, если по данной метке предмета не оказалось):
  1 - строковая метка, обозначающая конкретный предмет в хранилище;
FreeItem - удаляет предмет из игры и очищает выделенную под него память:
  1 - предмет;
  Важно: Нельзя удалить предмет сразу из трюма, с планеты, из космоса и т.д., для начала его нужно оттуда изъять, для чего существуют специальные вышеописанные функции типа Get.
FormShipCurItem - позволяет взаимодействовать с предметом, находящимся "в руке" (поднятом):
  Без аргументов - вернёт предмет в руке игрока;
  Опционально:
  1 - тип проверки или действия с предметом в руке:
    0 или 'MoveType' - вернёт тип того, что находится в руке:
       0 - ничего;
     1 - сыпучий предмет (в т.ч. товары);
     2 - простой предмет;
     3 - артефакт;
    1 или 'StackableType' - вернёт конкретный тип сыпучего предмета (для товара взятого из трюма предмет не существует, поэтому чекнуть можно только так);
    2 или 'StackableCount' - вернёт количество сыпучего предмета, находящегося в руке;
    3 или 'StackableCost' - вернёт цену сыпучего предмета, находящегося в руке;
    4 или 'PutBack' - не вернёт ничего, но положит предмет из руки на место;
    5 или 'Destroy' - не вернёт ничего, но уничтожит предмет в руке (уничтожить через FreeItem() его в данный момент нельзя);
    6 или 'Detach' - уберёт предмет из руки, но не вернёт его на корабль. Возвращает ссылку на убранный из руки предмет, если это возможно (например, товары в трюме не являются предметом);
ArrangeItems - заставляет корабль проинспектировать своё оборудование и предметы в трюме (к примеру, чтобы он сразу надел/продал/выбросил выданный ему предмет):
  1 - корабль;
CustomWeaponType - возвращает строковый тип кастомного оружия (для оригинальных типов орудий будет возвращать ''):
  1 - кастомное оружие в виде предмета;
CustomWeaponTypes - возвращает общее количество существующих в Галактике (объявленных) кастомных орудий:
  1 - номер орудия в списке, вернёт строковый кастомный тип;
GetCustomWeaponPrimaryDamageType - возвращает базовый тип урона для указанного типа кастомного или оригинального (!) оружия:
  1 - тип кастомного оружия (для получения типа урона оригинального оружия, необходимо подставлять сюда его числовой тип в виде int, а для кастомного - строчный в виде str);
    Типы урона:
      0 - энергетический;
      1 - осколочный;
      2 - ракетный;
GetCustomWeaponData - возвращает различные параметры для конкретного типа кастомного или оригинального (!) оружия:
  1 - тип оружия (для получения информации об оригинальном оружии, необходимо подставлять сюда его числовой тип в виде int, а для кастомного - строчный в виде str);
  2 - запрашиваемый параметр:
  'TechLevel' - технологический уровень оружия;
  'AverageSize' - средний размер;
  'AverageRadius' - средний радиус;
  'SecondaryDamageRadius' - радиус сплеша (актуально для орудий с типом выстрела Splash или Exploder);
  'MissileRadius' - ракетный радиус (у ракетных орудий максимальную дальность наведения орудия по умолчанию определяет именно он);
  'MaxDamage' - максимальный урон;
  'MinDamage' - минимальный урон;
  'kCost' - ценовой коэффициент (определяет стоимость);
  'ShotType' - тип выстрела:
     'Normal' - обычная стрельба по одиночной цели;
     'Splash' - попадание также наносит урон по области вокруг основной цели;
     'Chain' - цепная атака, как у Волнового фазера;
     'Exploder' - цепная реакция в случае уничтожения цели, как у Турбогравира;
     'AreaDamage' - атака по области вокруг корабля, как у Вертикса;
     'Rocket' - обычная ракета (изменение числа ракет в одной атаке производится добавлением цифры в конце, например: Rocket3);
     'Missile' - ракета, имеющая сплеш (изменение числа ракет в одной атаке производится добавлением цифры в конце, например: Missile3);
     'Torpedo' - обычная торпеда;
  'DamageType' - стандартный дамагсет для указанного типа оружия;
  'AttackCount' - число залпов за ход;
  'ShotCount' - число выстрелов/ракет в залпе (или количество целей, например, для волнового фазера);
  'Availability' - возвращает тип магазинов, в которых можно приобрести это оружие:
     'Free' - оружие продаётся в любых магазинах (коалиционных или пиратских);
     'CoalitionOnly' - только на планетах/станциях Коалиции;
     'PirateOnly' - только на пиратских планетах/станциях;
     'MalocOnly' - только на малокских планетах/станциях;
     'PelengOnly' - только на пеленгских планетах/станциях;
     'PeopleOnly' - только на человеческих планетах/станциях;
     'FeiOnly' - только на фэянских планетах/станциях;
     'GaalOnly' - только на гаальских планетах/станциях;
     'NotSold' - это оружие нельзя купить в магазинах;
     'NotSoldAndNodeRepair' - это оружие нельзя купить в магазинах, а его ремонт доступен только за ноды;
GetCustomWeaponInfo - возвращает указатель на раздел со статами кастомной пушки:
  1 - имя типа кастомного оружия;
CreateCustomWeapon - создать кастомное оружие:
  1 - тип кастомного оружия;
  2 - размер;
  3 - технологический уровень;
  4 - раса-производитель;
InventNewCustomWeapon - создаёт новый тип оружия с указанным именем и прописывает его в сейве, возвращает указатель на него:
  1 - имя;
  Опционально:
  2 - тип базовой пушки с которой будут изначально скопированы статы (по умолчанию - пром. лазер);
SetCustomWeaponShotData - устанавливает тип выстрела кастомной пушки:
  1 - раздел кастомного оружия;
  2 - тип выстрела (строка: 'Normal', 'Splash', 'Exploder', 'AreaDamage', 'Torpedo', 'Missile', 'Rocket', 'Chain') если в залпе больше 1 выстрела, то можно увеличить число (например 'Rocket3' (не работает для торпед));
  Опционально:
  3 - скорость произведения выстрела (от 0 до 100, где 0 - скорость Ракетомёта и Лирекрона, а 100 - скорость Турбогравира);
  4 - средний радиус;
  5 - вторичный средний радиус (радиус сплеша);
  6 - сколько руды останется после выстрела по астероиду;
  7 - число выстрелов за ход;
  Примечание: Параметр скорости выстрела можно установить сколь угодно высоким, однако после наложения всех возможных бонусов, фактическая скорость выстрела будет всё равно рассчитана из диапазона 0-100. Значения скорости выше сотни имеет смысл устанавливать лишь для снижения отрицательных эффектов бонусов, влияющих на скорость.
SetCustomWeaponDamageData - устанавливает параметры урона кастомной пушки:
  1 - раздел кастомного оружия;
  2 - минимальный урон;
  3 - максимальный урон;
  4 - дамагсет в виде числа, либо строки, аналогичной оригинальному виду: 'Splinter,Acid,NoDelta' (без пробелов и с учётом регистра);
  Опционально:
  5 - первый аргумент float из списка, либо сразу целая строка вида: '1.00,1.10,1.15,1.20,1.25,1.30,1.35,1.40' без пробелов (все уровни указывать не обязательно);
  6, 7, 8, 9, 10, 11, 12 - прочие параметры mWeaponDamage в виде float (по одному аргументу на уровень, подставлять все 8 также не обязательно);
SetCustomMissileWeaponStats - устанавливает статы ракеты/торпеды для кастомного оружия ракетного типа:
  1 - раздел кастомного оружия;
  2 - радиус ракеты;
  3 - максимальная скорость;
  4 - минимальная скорость;
  5 - шанс на сбитие ракеты при выстреле по ней (от 0 до 100);
SetCustomWeaponPrimaryData - устанавливает данные о продаже кастомного оружия:
  1 - раздел кастомного оружия;
  2 - ГТУ разблокировки возможности использования/починки и начала появления пушки в магазинах (в магазинах планет начинает появляться по достижении самой планетой указанного в аргументе ТУ);
  3 - номер ванильного орудия, технологический уровень которого будет наследован для повышения ТУ данной кастомной пушки на планетах;
    Примечание: А конкретно, насколько рано начнут повышаться ТУ кастомной пушки в магазинах.
    У каждого оригинального оружия для этого имеется свой индивидуальный технический планетарный проект, который открывается для изучения планетой не раньше, чем открывается для покупки базовое орудие без повышенных уровней ТУ (A, B, C и т.д.). Далее, получив необходимый уровень ПТУ, планета может начать изучать проект определённого оружия, что в итоге приведёт к повышению технического уровня данного орудия при его продаже на конкретной планете. Поскольку у кастомного оружия индивидуального планетарного проекта нет, проект будет наследован ею от проекта указанной в данном аргументе оригинальной пушки и, следовательно, уровень ТУ кастомного орудия будет повышен на конкретной планете одновременно с уровнем родительской оригинальной пушки.
  4 - номер ванильного орудия, эффект которого будет наследован кастомной пушкой в АБ;
  Примечание: В третьем аргументе необходимо указывать оригинальный тип, т.к. планеты не могут изучать кастомное оружие и будут зависеть от этой привязки. Кастомная пушка будет повышать уровни в магазинах планет одновременно с повышением уровней родительского оружия.
SetCustomWeaponSizeAndCost - устанавливает цену и вес кастомной пушки (очерёдность аргументов не совпадает с названием!!!):
  1 - раздел кастомного оружия;
  2 - коэффициент стоимости (допустимы значения float);
  3 - средний вес;
SetCustomWeaponAvailability - устанавливает место продажи кастомной пушки:
  1 - раздел кастомного оружия;
  2 - строка:
    'Free' - оружие продаётся в любых магазинах;
    'CoalitionOnly' - только на планетах/станциях Коалиции;
    'PirateOnly' - только на пиратских планетах/станциях;
    'MalocOnly' - только на малокских планетах/станциях;
    'PelengOnly' - только на пеленгских планетах/станциях;
    'PeopleOnly' - только на человеческих планетах/станциях;
    'FeiOnly' - только на фэянских планетах/станциях;
    'GaalOnly' - только на гаальских планетах/станциях;
    'NotSold' - это оружие нельзя купить в магазинах;
    'NotSoldAndNodeRepair' - это оружие нельзя купить в магазинах, а его ремонт доступен только за ноды;
SetCustomWeaponSE - устанавливает графические эффекты кастомного оружия:
  1 - раздел кастомного оружия;
  2 - анимация выстрела;
  3 - анимация сплэша;
  4 - анимация подрыва ракеты;
  5 - номер палитры для анимации выстрела;


Артефакты:
ShipArts - аналогично ShipItems(), только для артефактов, т.к. они находятся на корабле отдельным списком, возвращает количество артов в трюме, или конкретный арт из трюма:
  1 - корабль (возвращает количество);
  Опционально:
  2 - номер арта в списке артов корабля (возвращает конкретный артефакт);
CreateArt - создаёт оригинальный артефакт:
  1 - тип артефакта;
  2 - раса-производитель;
CreateCustomArt - создаёт кастомный артефакт:
  1 - системное название кастомного артефакта (строкой);
  2 - размер;
  3 - цена;
  4 - раса-производитель;
CustomArtData - создаёт три поля для хранения переменных типа integer, с возможностью их подстановки в описание Data1, Data2, Data3:
  1 - артефакт;
  2 - номер поля (от 1 до 3);
  Опционально:
  3 - какое значение установить;
CustomArtTextData - три поля для хранения текстовой инфы кастомного арта <TextDataN>, где N - номер поля:
  1 - артефакт;
  2 - номер поля (от 1 до 3);
  Опционально:
  3 - какой текст установить;
ArtefactTypeInUse - возвращает количество экипированных и не сломанных артефактов указанного типа на корабле:
  1 - корабль;
  2 - тип артефакта или сам артефакт, тип которого нужно проверить (можно проверять кастомные типы);
  Примечание: При установленном Артефакторе, для "информационных" артефактов из трюма, вроде Биомира, эта функция также вернёт "true" во время событий t_OnEnteringForm и t_OnReEnteringForm, но не во время событий t_OnStep, что вообще нихера не удобно учитывать в коде, но просто примите как факт. Всякие Биомиры в трюме при установленном Артефакторе считаются рабочими только в тот момент, когда игрок захочет посмотреть свои статы. И, более того, с ТН на установку множества однотипных артефактов, при установке в слоты сразу двух Артефакторов, всякие Биомиры будут полноценно работать из трюма (увеличивать длительность действия стимуляторов) на постоянной основе, возвращая "true" даже во время t_OnStep.
ArtefactTypeBoosted - возвращает текущий статус совместимости (0/1) экипированных на корабле артефактов определённого типа:
  1 - корабль;
  2 - тип артефакта или артефакт, тип которого нужно проверить;
   Примечание: Под "совместимостью" понимается разблокировка дополнительных свойств артефакта, в случае наличия на корабле установленного "совместимого" с ним, то есть оборудования от неизвестного производителя (ItemOwner(item) == 6). Пример: Железные жупи и корпус неизвестной расы.


Ракеты/торпеды:
SpawnMissile - спавнит ракету в системе, и возвращает указатель на неё:
  1 - система;
  2 - цель ракеты;
  3 - место появления ракеты, координата X;
  4 - место появления ракеты, координата Y;
  5 - стартовый угол поворота ракеты;
  6 - минимальный урон;
  7 - максимальный урон;
  8 - скорость ракеты;
  9 - тип оружия, из которого якобы запускается ракета (номер типа или строка типа для кастомного оружия);
  Опционально:
  10 - номер ММ для оружия, из которого якобы запускалась ракета (если не нужен, подставить -1);
  11 - номер акрина для оружия, из которого якобы запускалась ракета (если не нужен, подставить -1);
  Примечание: Если подразумевается, что заспавленную ракету выпустил корабль, не забудьте прописать его ракете через MissileOwner(). В противном случае ракета просто детонирует об корабль, который якобы её и выпустил.
MissileStar - возвращает систему, в которой находится ракета:
  1 - ракета;
MissileType - возвращает тип оружия (только оригинального числом или t_CustomWeapon для кастомного оружия), из которого была выпущена данная ракета:
  1 - ракета;
CustomMissileType - возвращает тип кастомного оружия (строкой, для оригинальных орудий вернёт 'W01', 'W02' и т.д.), из которого была выпущена ракета:
  1 - ракета;
MissileOwner - возвращает или устанавливает выпустивший ракету корабль:
  1 - ракета;
  Опционально:
  2 - корабль, который будет считаться хозяином ракеты;
  Примечание: Не забывайте использовать эту функцию в случаях, когда ракета была добавлена в игру функций SpawnMissile(). В противном случае она просто детонирует об корабль, который якобы её и выпустил.
MissileTarget - возвращает или устанавливает цель ракеты:
  1 - ракета;
  Опционально:
  2 - установить новую цель;
MissileLive - возвращает/изменяет время полёта ракеты/торпеды, по умолчанию составляющее 1000 (5 дней):
  1 - ракета;
  Опционально:
  2 - на какое значение изменить время полёта ракеты/торпеды;
     Пояснение: Изначальное время полёта ракеты составляет 0, а по достижению 1000, то есть 5 дней, ракета самоуничтожается. Функция MissileLive() позволяет изменять это время, при этом значение, которое игрок устанавливает через функцию, будет отниматься от той самой 1000. Таким образом, если, например, задать MissileLive() при запуске ракеты (событие t_OnMissileShot), то время полёта ракеты сместиться в минус и будет составлять 0-value, пример: при MissileLive(missile, 200) на старте ракеты, её начальное время полёта уже будет составлять как бы 1 день (-200), как раз тот день, в который ракета вылетает из установки, набирает скорость и врубает самонаведение. То есть при MissileLive(missile, 200) на старте, ракета вылетит из установки уже на максимальной скорости и моментально направится к цели. Учтите, что при данном подходе время реальной жизни ракеты после пуска также сократиться до 800 (4 дней).
     Если же устанавливать MissileLive() для уже вылетевшей ракеты, то значение будет отниматься из фактически проделанного её пути, пример: ракета пролетела 3 дня, её срок жизни составляет 600, а установка MissileLive(missile, 200) отнимет 200 из этого значения, по сути "омолодив" ракету на один день. Таким образом, можно продлять срок жизни нужной ракеты до бесконечности.
     Примечание: Выставлять отрицательное значение в функции MissileLive() также возможно, но тогда ракета будет получать буст ко времени вывода на цель. То есть просто будет лететь по прямой на минимальной скорости, ни на что не реагируя. Подробно эту возможность не тестировал. Также данную функцию можно использовать для мгновенного уничтожения ракеты, просто выставляя MissileLive(missile, 1000), либо больше.
MissileSpeed - возвращает/устанавливает текущую скорость ракеты:
  1 - ракета;
  Опционально:
  2 - какую скорость установить;
MissileAngle - возвращает/устанавливает угол направления носа ракеты по часовой стрелке (где север, это нулевой угол) в виде float (передавать можно и int):
  1 - ракета;
  Опционально:
  2 - новый угол поворота в градусах;
WeaponAmmunition - возвращает/устанавливает текущее количество зарядов в ракетном оружии:
  1 - оружие;
  Опционально:
  2 - установить новое значение;
WeaponMaxAmmunition - возвращает/устанавливает максимальное число зарядов в ракетном оружии (учитывает установленные акрины и ММ):
  1 - оружие;
  Опционально:
  2 - какое максимальное число зарядов установить:
    Стандартный лимит зарядов любого ракетного оружия в ваниле зависит только от его ТУ:
      ТУ 1 - 30 залпов
    ТУ 2 - 35 залпов
    ТУ 3 - 40 залпов
    ТУ 4 - 45 залпов
    ТУ 5 - 50 залпов
    ТУ 6 - 55 залпов
    ТУ 7 - 60 залпов
    ТУ 8 - 65 залпов
  Примечание: Для всех типов ракетного оружия рост максимального числа зарядов по ТУ идентичен и линеен: 25 + 5 * ТУ.
MissilesToRearm - возвращает количество зарядов, которого не хватает ракетному оружию до полного комплекта, либо пополняет его боезапас:
  1 - оружие;
  Опционально:
  2 - на сколько пополнить боезапас (для разрядки орудия нужно указать отрицательное значение):
    ГТУ 1 - 10 cr.
    ГТУ 2 - 10 cr.
    ГТУ 3 - 28 cr.
    ГТУ 4 - 46 cr.
    ГТУ 5 - 64 cr.
    ГТУ 6 - 82 cr.
    ГТУ 7 - 100 cr.
    ГТУ 8 - 100 cr.
  Примечание: Стоимость пополнения одного заряда (любого) зависит от ГТУ (сама функция MissilesToRearm() деньги за пополнение не списывает).
MissileMinDamage - возвращает/устанавливает минимальный урон ракеты:
  1 - ракета;
  Опционально:
  2 - установить новое значение минимального урона;
MissileMaxDamage - возвращает/устанавливает максимальный урон ракеты:
  1 - ракета;
  Опционально:
  2 - установить новое значение максимального урона;
MissileWeaponID - возвращает Id ракеты, который всегда равен Id выпустившего ракету орудия (ракеты, рождённые через SpawnMissile(), имеют нулевой Id):
  1 - ракета;


Микромодули и акрины:
CreateMM - создаёт микромодуль в виде предмета и возвращает на него ссылку:
  1 - номер бонуса для создания ММ;
BonusCount - без аргументов, возвращает общее количество всех ММ и акринов в игре (а точнее всех загруженных в Галактику);
  Примечание: Оригинальные номера-названия разделов всех бонусов в Lang начинаются с '0' и заканчиваются '545' (в модах могут подставляться строкой, но в оригинале только цифры). "Нумерация" бонусов в Lang оригинальной игры имеет серьёзные пропуски (пропущены буквально сотни номеров). Бонусы микромодулей начинаются с 0 и завершаются на номере 306, плюс Акринатор (уникальный ММ с параметром Special=1) под номером 498. Бонусы оружейных модификаций начинаются с номера 500 и заканчиваются последним в списке бонусов номером 545.
FindBonusByName - ищет по названию и при успехе возвращает номер бонуса:
  1 - название бонуса (при неудаче вернёт -1);
FindBonusByCustomTag - ищет бонус по особому тэгу (параметр CustomTag в разделе бонуса в Lang) и при успехе возвращает его номер:
  1 - тэг бонуса строкой (при неудаче вернёт -1);
FindBonusByNameInCfg - ищет бонус по имени его раздела в Lang (все разделы оригинальных бонусов имеют сугубо числовые имена), что делает эту функцию крайне полезной при поиске бонусов из оригинальной игры, которые, в своём большинстве, не имеют кастомных тэгов:
  1 - имя раздела бонуса в Lang (при неудаче вернёт -1);
  Важно! Внутренняя игровая нумерация бонусов автоматически выстраивается при запуске игры из всех бонусов в разделе MicroModuls. Данная нумерация никак не привязана к названиям разделов конкретных бонусов, так что называть это разделы можно как угодно, лишь бы для разных бонусов они не повторялись.
BonusNumInCfg - возвращает имя раздела Lang, в котором прописана информация о конкретном бонусе строкой:
  1 - номер бонуса (при невалидном номере бонуса вернёт '');
BonusPriority - возвращает приоритет бонуса (от 0 до 100):
  1 - номер бонуса;
    Priority - параметр для акриновых бонусов от 0 до 100, определяющий, на каком ГТУ (а точнее на планетах с каким ПТУ) будет доступен для покупки данный акрин. Определяется по формуле 8 * N, где N - прописанный в Lang параметр Priority, умноженный на 0.01. Результат (например: 8 * 0.60 = 4.8) округляется всегда в большую сторону и означает точный ГТУ, с которого бонус станет доступным для наложения на предметы (в приведённом примере это будет 5 ГТУ).
    Примечание: Появление акринов по ПТУ аналогичным образом работает и для станции. При генерации акринов на станциях, те "подтягивают" в свой магазин акрины, случайным образом доступные для появления по ПТУ на разных обитаемых планетах своей системы.
  Отдельные (противоположные) значения данного параметра прописываются для микромодулей: 
  0-30 - микромодуль первого уровня (<color=255,0,0>), цифра приоритета (чем меньше, тем дороже) в данном диапазоне также определяет стоимость микромодуля в нодах и кредитах;
  31-69 - микромодуль второго уровня (<color=255,240,100>), цифра приоритета (чем меньше, тем дороже) в данном диапазоне также определяет стоимость микромодуля в нодах и кредитах;
  70-100 - микромодуль третьего уровня (<color=17,139,255>), цифра приоритета (чем меньше, тем дороже) в данном диапазоне также определяет стоимость микромодуля в нодах и кредитах;
  Примечание: Также приоритет ММ определяет, на каких ГТУ данный модуль может появиться у случайных кораблей. Чем выше (ниже) приоритет, тем более высокий ГТУ будет необходим данному ММ для появления на кораблях NPC. Определённый диапазон (minP - maxP) подбора ММ для конкретного ГТУ считается по формуле: maxP = PortionInDiapason(GalaxyTechLevel(), 3, 7, 70, 0); minP = maxP + 40; Однако далее, если в указанном диапазоне обнаружился хотя бы один подходящий для конкретного типа оборудки модуль, будет произведено расширение искомого диапазона, после чего код сравнит подобранные с широкой выборки ММ уже по их индивидуальным статам и подберёт лучший.
BonusIsSpecial - проверяет, что бонус это акрин:
  1 - номер бонуса;
BonusName - возвращает название бонуса (параметр Name):
  1 - номер бонуса;
BonusText - возвращает полное описание указанного бонуса (параметр Text):
  1 - номер бонуса;
BonusCustomTag - возвращает строковый тэг указанного бонуса (параметр CustomTag):
  1 - номер бонуса (при отсутствии у бонуса тэга, либо невалидном номере бонуса вернёт '');
BonusValue - возвращает значение какого-то конкретного усиления/штрафа в бонусе:
  1 - номер бонуса;
  2 - значение какого усиления/штрафа вернуть (например, bonSpeed);
HullSpecial - возвращает/накладывает акрин на корпус (вернёт -1, если акрина нет):
  1 - сам корпус или использующий его корабль;
  Опционально:
  2 - какой акрин наложить (-1 - снять акрин);
    Примечание: Данная функция лишь добавляет корпусу бонус, но не меняет его тип на акриновый. Следовательно, при наложении акрина данной функцией на не акриновый корпус его внешний вид изменён не будет. То же самое касается и функции EqSpecial(). Для полноценного наложения акрина на корпус используйте функцию SpecialToEquipment().
SpecialToEquipment - накладывает или снимает акрин с оборудования с учётом модификаторов Cost и Size (если прописаны в бонусе):
  1 - номер бонуса (если -1, то снять акрин);
  2 - оборудование (при повторной акринации акринированного предмета, наложит модификаторы Cost и Size поверх уже изменённых статов);
  Примечание: При деакринации корпуса он автоматически не получает для себя исходный тип, т.к. не знает каким этот тип должен быть. Необходимо вручную задать любой стандартный тип деакринированному корпусу (HullType()), чтобы при попытке отрисовки его графики не случился краш.
ModuleToEquipment - аналогично SpecialToEquipment(), только для установки/изъятия ММ, а также реально меняющая статы предмета согласно бонусу (нормальная установка ММ):
  1 - номер бонуса (если -1, то изъять ММ);
  2 - оборудование;
EqSpecial - возвращает (-1, если акрина нет), накладывает или снимает акрин с оборудования без учёта модификаторов на размер и стоимость:
  1 - оборудование;
  Опционально:
  2 - номер бонуса (если -1, то снять акрин);
EqModule - аналогично EqSpecial(), только для проверки/установки/изъятия ММ. Не изменяет (!) никакие статы предмета, однако блокирует дальнейшие улучшения на НБ (игра будет думать, что статы были занижены относительно их базового значения):
  1 - оборудование, либо микромодуль в виде предмета;
  Опционально:
  2 - номер бонуса (если -1, то изъять ММ);
  Примечание: Если вам необходимо полностью заменить текст в карточке предмета с определённым акрином, то в разделе бонуса данного акрина необходимо использовать параметры TextReplace по числу оригинальных строчек Text данного предмета. В этом случае строчки с TextReplace автоматически заменят собой все оригинальные строчки Text. Также с помощью акрина имеется возможность добавить дополнительный текст в описание любого артефакта, для чего нужно просто добавить ему соответствующий акрин или спецакрин. Акрин не окажет на артефакт иного влияния, кроме замены текста.
ItemExtraSpecials - возвращает общее количество всех спецакринов на предмете или конкретный спецакрин:
  1 - предмет;
  Опционально:
  2 - номер спецакрина на предмете (вернёт спецакрин);
ItemExtraSpecialsCountByType - возвращает количество конкретных спецакринов на предмете:
  1 - предмет;
  2 - спецакрин, количество которых необходимо вернуть;
ItemExtraSpecialsAddByType - добавляет спецакрин на предмет:
  1 - предмет;
  2 - спецакрин;
  Опционально:
  3 - сколько указанных спецакринов добавить (по умолчанию будет добавлен 1);
  Важно: Если таким образом повесить на предмет пустой акрин (-1), то статы предмета станут совершенно невменяемыми.
ItemExtraSpecialsDeleteByType - удаляет спецакрин с предмета:
  1 - предмет;
  2 - спецакрин;
  Опционально:
  3 - сколько указанных спецакринов удалить (по умолчанию будет удалён 1);
  Примечание: Фактически спецакрины почти ничем не отличаются от обычных, кроме способа наложения на предмет и возможностью накладывать сразу множество спецакринов, вместо одного основного. Также спецакрины не применяют к предмету модификаторы Cost и Size и, в отличие от простых акринов, будучи наложены на орудие, не суммируют бонус к урону/дальности со статами пушки, а прибавляют его как любой другой акрин (но всё равно только к той пушке, но которую были наложены). Количество одинаковых спецакринов на предмете хранится в виде числа, поэтому путём наложения нужного числа "пустых" спецакринов вы можете, фактически, записывать в любое оборудование числовую информацию. А для добавления дополнительного текста в карточку оборудования со спецакрином, в разделе бонуса этого спецакрина необходимо использовать параметры ExText, а не просто Text, как обычно. При добавлении на предмет более одного одинакового спецакрина, текст из параметра ExText в описании не дублируется.
  Тэги для подстановки значений бонусов в тексте основного акрина предмета (и любых других спецакринов), вида '<bonSpeed>' будут также суммировать в себя бонусы от всех наложенных на предмет спецакринов, что необходимо учитывать, если вы собираетесь использовать спецакрины для "динамической регулировки" бонусов на предмете.
MayAddBonusToEq - проверяет, можно ли установить бонус (акрин или ММ) на указанное оборудование (учитываются тип и раса-производитель оборудования):
  1 - номер бонуса;
  2 - оборудование;
BuildListOfMMByPriority - записывает в массив список номеров бонусов ММ (бонусы с тэгом Special=1 микромодулями не считаются) в указанном диапазоне значений их приоритета, после чего возвращает размер получившегося массива, по умолчанию не добавляет ММ с установленным параметром RacialRestriction:
  1 - массив (будет очищен автоматически), либо переменная типа unknown (будет превращена в массив);
  2 - стартовый приоритет модулей для добавления;
  3 - конечный приоритет модулей для добавления;
    Примечание: От того как вы расставите аргументы, от 100 до 0 или от 0 до 100 будет зависеть последовательность занесения модулей в массив. От 100 до 0 будут заноситься модули от худших (3-го уровня) до лучших (1-го уровня), и наоборот.
  Опционально:
  4 - маркер (0/1) для разрешения добавления в массив модулей с RacialRestriction;
SwitchToMirrorImage - используется для плавной смены анимации корабля/станции прямо на глазах у игрока:
  1 - корабль/станция;
  2 - номер акрина, на анимацию которого необходимо переключится (также будет заменён и сам корпусной акрин);
  Примечание: Если одна Hai анимация (Gai не подходит) использована сразу в нескольких корпусных акринах, и при этом в каждом акрине указан свой отдельный отрезок этой анимации, то при смене акрина корабля/станции на другой акрин с той же анимацией с помощью данной функции будет произведён плавный переход кадров (сперва завершится предыдущая анимация, а затем начнёт воспроизводиться следующая, уже с нового акрина). Если же переключать акрин корабля/станции на акрин, имеющий какую-то другую анимацию, то переход кадров будет резким, без плавного завершения предыдущей анимации (просто сразу же начнёт воспроизводиться анимация с нового акрина).


Операции с товарами:
UpsurgeGoods - на планете начинается распродажа определённого товара (если указанный товар закончился, может автоматически подкинуть на склады ещё 200-300 единиц, пока продолжается распродажа), автоматически отменяет его дефицит, если он есть:
  1 - планета;
  2 - тип товара;
DecayGoods - на планете начинается дефицит определённого товара, автоматически отменяет его распродажу, если такая есть:
  1 - планета;
  2 - тип товара;
GoodsRuinsForBuy - станция предлагает много определённого товара по дешёвке:
  1 - станция;
  2 - тип товара;
PlanetSetGoods - устанавливает количество определённого товара на планете:
  1 - планета;
  2 - тип товара;
  3 - какое количество установить;
GoodsAdd - добавляет или удаляет указанное количество определённого товара в магазин или в трюм корабля (возвращает общее количество товара после изменения):
  1 - планета, станция или корабль (для корабля будет проверять/изменять его трюм);
  2 - тип товара;
  3 - на сколько изменить количество товара в магазине (если подставить 0, то вернёт имеющееся количество без изменения);
GoodsCount - возвращает количество определённого товара в трюме корабля или трюме (не на складе) станции:
  1 - корабль;
  2 - тип товара;
ShipGoods - аналог GoodsAdd(), но изменяет количество товара исключительно в трюме корабля или трюме станции (при этом не возвращает ничего):
  1 - корабль;
  2 - тип товара;
  3 - на сколько изменить количество товара в трюме;
  Опционально:
  4 - какую цену задать всему добавляемому/вычитаемому стаку товара (вместе с товаром будет суммирована с ценой уже имеющегося стака товара данного типа, если такой в трюме есть), по умолчанию выставляет среднюю галактическую;
GoodsDrop - заставляет корабль выбросить товар (обратите внимание, что товар на корабле не существует в качестве предмета, поэтому выбросить его никакой другой функцией нельзя):
  1 - корабль (не работает с кораблём игрока);
  2 - тип товара;
  3 - сколько выбросить;
  Опционально:
  4 - скриптовый объект (выброшенный товар будет занесён в указанный скриптовый объект);
GoodsSellPrice - возвращает/устанавливает цену (за единицу товара), за которую планета или станция продаёт указанный товар:
  1 - планета или станция;
  2 - тип товара;
  Опционально:
  3 - установить новую цену;
GoodsBuyPrice - возвращает/устанавливает цену (за единицу товара), за которую планета или станция покупает указанный товар:
  1 - планета или станция;
  2 - тип товара;
  Опционально:
  3 - установить новую цену;
CreateGoods - создаёт товар:
  1 - тип товара:
     t_Food (0) - продукты;
     t_Medicine (1) - медикаменты;
     t_Technics (2) - техника;
     t_Luxury (3) - роскошь;
     t_Minerals (4) - минералы;
     t_Alcohol (5) - алкоголь;
     t_Arms (6) - оружие;
     t_Narcotics (7) - наркотики;
  2 - количество товара;
  Опционально:
  3 - маркер (0/1), чтобы созданные предметы по умолчанию получили вид своего родного контейнера, а не ящика (например, если предмет добавляется сразу в космос);
ShipGoodsIllegalOnPlanet - проверяет легальность определённого товара на планете для конкретного корабля:
  1 - корабль;
  2 - тип товара;
  3 - планета;

Оборудование и корабль (характеристики и параметры):
BuildListOfNewShips - делает перебор Галактики и заполняет массив только кораблями и станциями, родившимися с определённого момента, а в случае, если таковых нет, оставит массиву один пустой элемент. Функция заполняет массив, начиная с элемента под нулевым номером, и в конце возвращает число записанных в массив кораблей (при отсутствии таковых вернёт 0):
  1 - массив для заполнения (будет очищен автоматически), либо переменная типа unknown (будет превращена в массив);
  2 - Id самого старого корабля, с которого (включительно) начнётся занесение новых кораблей в массив;
  Опционально:
  3 - сет номерных типов кораблей (если 0 или отсутствует, то ищет всех, кроме транклюкаторов, т.к. искать последних для хардкода трудоёмко):
    t_Kling - 1
    t_Ranger - 2
    t_Transport - 4
    t_Pirate - 8
    t_Warrior - 16
    t_Tranclucator - 32
    t_RC - 64
    t_PB - 128
    t_WB - 256
    t_SB - 512
    t_BK - 1024
    t_MC - 2048
    t_CB - 4096
    t_UB - 8192
  4 - сет рас (если 0 или отсутствует, то ищет всех):
    Maloc - 1
    Peleng - 2
    People - 4
    Fei - 8
    Gaal - 16
    Kling - 32 (доминаторы)
    None - 64 (неизвестная раса)
    PirateClan - 128
  5 - добавлять 1 или нет 0 скриптовые корабли (корабли с установленным OrderLock() будут также считаться скриптовыми);
  6 - фильтр кастомных фракций вида: 'S1,S2,S3' в котором пустая строка '' будет считаться как фильтр на добавление кораблей без кастомной фракции (можно также составить фильтр вида ',S1,S2');
  7 - фильтр строковых типов кораблей (ShipType()), работающий аналогично фильтру фракций: ',Ranger,Pirate,Klissan';
  Важно: При установке строкового фильтра, все оригинальные корабли будут проходить в нём под значением ''. То есть если вы не хотите исключать оригинальные типы кораблей, обязательно оставьте в вашем фильтре место под пустую строку: '', 'CustomType1,,CustomType2' или ',CustomType1,CustomType2'
ShipCntWeapon - общее число экипированных на корабле орудий:
  1 - корабль;
ShipWeapon - возвращает экипированное на корабле орудие:
  1 - корабль;
  2 - номер орудия (1-5);
  Примечание: Номер орудия не соответствует нумерации орудийного слота, в котором оно установлено. Если вам необходима строгая предсказуемая нумерация от 1 до 5, используйте запросы вида: ShipEqInSlot(ship, t_Weapon1, weapon_slot_num). Конкретно функция ShipWeapon() нумерует орудия на корабле хрен пойми в каком порядке (вероятно, использует общую нумерацию вещей в трюме), что не имеет значения для простого перебора всех орудий, но может стать проблемой, если вам нужно подставлять/определять орудие в конкретном слоте.
WeaponTarget - возвращает или устанавливает цель орудия:
  1 - орудие;
  Опционально:
  2 - какую цель установить;
ShipEqInSlot - возвращает установленное в слоте оборудование/оружие (при его отсутствии вернёт 0):
    1 - корабль;
    2 - тип слота:
     t_Artefact - слот артефакта;
     t_Hull - слот корпуса;
     t_FuelTanks - слот топливного бака;
     t_Engine - слот двигателя;
     t_Radar - слот радара;
     t_Scaner - слот сканера;
     t_RepairRobot - слот дроида;
     t_CargoHook - слот захвата;
     t_DefGenerator - слот ГЗП;
     t_Weapon1 - орудийный слот;
  Опционально:
    3 - номер слота (для оружия 1-5, для артефактов 1-4);
  Примечание: Не пользуйтесь прямой нумерацией при указании слотов/типов оборудования, т.к. при её смещении (в связи с обновлениями хардкода) в коде появится неочевидная ошибка. Вместо этого используйте общие переменные типа t_Engine.
EnginePower - возвращает текущий перегрев двигателя (от 0 до 100):
  1 - конкретный двигатель или использующий его корабль;
  Опционально:
  2 - какое значение перегрева установить;
ShipSpeed - возвращает текущую фактическую скорость корабля:
  1 - корабль;
ShipFuel - возвращает и устанавливает количество топлива в установленном топливном баке:
  1 - корабль;
  Опционально:
  2 - какое количество топлива установить, если количество топлива изменено, то вернёт количество до изменения;
ShipFuelLow - проверяет, не отсутствует ли на корабле топливный бак, или количество топлива в нём меньше максимального:
  1 - корабль;
    Игровая формула расчёта стоимости топлива:
    За основу берётся текущий ход, а оригинальная формула имеет вид: Количество * PortionInDiapason(Galaxy.FTurn, 1000, 15000, 1, 10);
    Это означает, что для хода 1000 и ниже - стоимость единицы топлива составит 1 кредит, а для хода 15.000 и выше - 10 кредитов. Весь диапазон цены между данными значениями (от 1 до 10 кредитов) меняется линейно.
    Далее, на полученный округлённый результат, от стоимости общего количества пополняемого топлива, накладываются модификаторы. Модификатор расы накладывается, только если игрок заправляется на планете, а модификатор сложности накладывается в любом случае. Вне зависимости от результатов вычислений, одна единица топлива не может стоить дешевле 1 кредита. Округление итогового значения осуществляется, как обычно, функцией round(), в самом конце расчетов и после наложения всех возможных модификаторов.
    Модификаторы от расы планеты:
    0 (малоки) - 0.7
    1 (пеленги) - 0.9
    2 (люди) - 1.0 (доминаторы и неизвестная раса бы имели тот же коэффициент, если бы продавали топливо)
    3 (фэяне) - 1.15
    4 (гаальцы) - 1.30
    7 (пираты) - 0.8
    Модификаторы от сложности настройки удачи GalaxyDiffLevels(7):
     -30% на сложности 50%
       0% на сложности 100%
     +30% на сложности 150%
     +60% на сложности 200%
     +90% на сложности 250%
    +120% на сложности 300%
    +150% на сложности 350%
    +180% на сложности 400%
    +210% на сложности 450%
    +240% на сложности 500%
ShipJump - возвращает расстояние максимального прыжка корабля (только по двигателю!) с учётом всех бонусов:
  1 - корабль;
ShipArmor - возвращает броню корабля с учётом всех бонусов:
  1 - корабль;
ShipProtectability - возвращает % блокировки урона ГЗП корабля с учётом всех бонусов:
  1 - корабль;
ShipDroidRepair - возвращает эффективность дроида корабля с учётом всех бонусов:
  1 - корабль;
ShipRadarRange - возвращает радиус радара корабля с учётом всех бонусов:
  1 - корабль;
ShipScanerPower - возвращает мощность сканера корабля с учётом всех бонусов:
  1 - корабль;
ShipHookPower - возвращает мощность захвата корабля с учётом всех бонусов:
  1 - корабль;
ShipHookRange - возвращает радиус захвата корабля с учётом всех бонусов:
  1 - корабль;
ShipAverageDamage - возвращает средний урон корабля по одной цели с учётом всех орудий и всех бонусов:
  1 - корабль;
  Опционально:
  2 - вывести лимитное значение:
     0 - средний минимальный урон;
     1 - средний максимальный урон;
ShipOwner - возвращает или устанавливает расу корабля (но не пилота):
  1 - корабль;
  Опционально:
  2 - какую расу установить:
    0 или 'Maloc' - малок;
    1 или 'Peleng' - пеленг;
    2 или 'People' - человек;
    3 или 'Fei' - фэянин;
    4 или 'Gaal' - гаалец;
    5 или 'Kling' - доминатор;    
    6 или 'None' - неизвестный;
    7 или 'PirateClan' - клановый пират;
ShipStanding - возвращает/изменяет статус корабля или станции в противостоянии пиратов и Коалиции:
  1 - корабль;
  Опционально:
  2 - какой статус (Standing) выставить:
     0 - Kling - (доминаторы) считается доминатором, а потому всеми другими расами воспринимается враждебно;
     1 - None - (неизвестные) полностью безразличен к происходящему в системе, аналогичен транклюкатору без хозяина;
     2 - CoalMilitary - (военные Коалиции) соответствует военным, флагманам, ВБ и ЦР (неизбежно вызовет агрессию со стороны клановых пиратов и автоматически начнёт сражение за пиратскую систему);
     3 - CoalActive - (сочувствующие Коалиции) соответствует рейнджерам на стороне Коалиции (пока они находятся в пиратской системе), НБ и БЦ (может захватить/удержать систему для Коалиции в случае возникновения спорной ситуации);
     4 - CoalPassive - (гражданские) соответствует любым гражданским судам в пиратских системах и рейнджерам на стороне клана (пока они находятся в пиратской системе) (может захватить/удержать систему для Коалиции, но только если сам начнёт уничтожать корабли пиратов);
     5 - Neutral - (нейтралы) соответствует МЦ, перепрограммированному Блазеру и кораблям в тюрьме, игнорирует коалиционные и пиратские тёрки, но к доминаторам враждебен;
     6 - PiratePassive - (вольные пираты) соответствует вольным коалиционным пиратам, рейнджерам на стороне Коалиции (пока они находятся в Коалиционной системе) и ПБ (может захватить/удержать систему для клана, но только если сам начнёт уничтожать корабли военных);
     7 - PirateActive - (сочувствующие клану) соответствует рейнджерам на стороне пиратского клана (пока они находятся в Коалиционной системе) и странствующим клановым пиратам (может захватить/удержать систему для клана в случае возникновения спорной ситуации);
     8 - PirateMilitary - (клановые пираты) соответствует пиратским доминионам и запрещает посадку коалиционных кораблей (неизбежно вызовет агрессию со стороны военных и автоматически начнёт сражение за коалиционную систему);
     9 - Custom - будет враждебен ко всему, что не имеет той же кастомной фракции и абсолютно всему, если кастомная фракция у данного корабля отсутствует;
  С помощью данных типов можно определять, какие корабли клановые пираты или военные будут считать обязательными к уничтожению при захвате системы.
     Типы, к которым всегда враждебны военные:
        - Kling - доминаторы;
        - PirateMilitary - всё, что безоговорочно клановое;
        - PirateActive - сюда же переводятся рейнджеры, которые выступят на стороне клана (уничтожат хотя бы одного военного) во время обороны системы;
        - Custom - кастомные фракции (без приставки 'SubFaction');
     Типы, к которым всегда враждебны клановые пираты:
        - Kling - доминаторы;
        - CoalMilitary - всё, что безоговорочно коалиционное;
        - CoalActive - сюда же переводятся рейнджеры и гражданские, которые выступят на стороне военных (уничтожат хотя бы одного кланового пирата) во время обороны системы;
        - Custom - кастомные фракции (без приставки 'SubFaction');
  Примечание: Если выставить новый тип Standing для корабля, то он вскоре снова затрёт его своим, а вот станциям менять тип можно без особых проблем. Если же выставить определённый Standing кораблю всё же необходимо, то можно использовать наложение кастомной фракции, в качестве своеобразного маркера. Корабли, в названии кастомной фракции которых присутствует 'FixedStanding', изменять свой Standing автоматически не будут. Если же повесить на корабль кастомную фракцию 'SubFactionFixedStanding', то выставлять ему кастомную иконку и цвет цифр урона через Main будет не нужно, поскольку в таком случае кастомная фракция не будет заменять эти элементы.
OrderForsage - проверяет, не влючен ли у корабля форсаж, либо включает/выключает его:
  1 - корабль;
  Опционально:
  2 - если значение больше 0, то включить форсаж;
HullHP - возвращает или устанавливает запас прочности корпуса:
  1 - сам корпус или использующий его корабль;
  Опционально:
  2 - какое количество HP установить корпусу числом, либо процент строкой:
     'ToX' - где X - точный процент HP, который необходимо установить;
     'UpToX' - где X - максимальный процент HP, который необходимо установить (если число HP и так больше или равно указанному проценту, то их количество не изменится);
     'DownToX' - где X - минимальный процент HP, который необходимо установить (если число HP и так меньше или равно указанному проценту, то их количество не изменится);
     'PlusX' - где X - процент HP, который необходимо добавить к существующему количеству HP (не сможет поднять HP выше 100%);
     'MinusX' - где X - процент HP, который необходимо отнять от существующего количества HP (эта команда может опустить HP ниже 0);
   Примечание: При указании процента HP функция не имеет лимитных ограничений. То есть допустимо указывать процент выше 100 или ниже 0.
HullDamage - возвращает текущий процент повреждения корпуса корабля (от 0 до 100, где 0 - полностью целый корпус):
  1 - сам корпус или использующий его корабль;
Hitpoints - возвращает текущее значение структуры корабля:
  1 - сам корпус или использующий его корабль;
HullDamageSuspectibility - возвращает текущую восприимчивость корпуса к определённому типу урона (с учётом всех наложенных бонусов):
  1 - сам корпус или использующий его корабль;
  2 - тип восприимчивости числом или весь дамагсет для автоматического определения основного типа "входящего" урона:
     0 - энергетический;
     1 - осколочный;
     2 - ракетный;
ShipSlots - возвращает количество открытых слотов определённого типа в корпусе корабля (с учётом всех применённых штрафов и бонусов):
  1 - корабль;
  2 - номер типа слота:
     1 - st_Weapon;
     2 - st_Artefact;
     3 - st_Radar;
     4 - st_Scaner;
     5 - st_RepairRobot;
     6 - st_CargoHook;
     7 - st_DefGenerator;
     8 - st_Forsage;
ShipRefuel - восполняет запас топлива в установленном на корабле топливном баке до максимума:
  1 - корабль;
ShipRepairEq - полностью чинит всё установленное на корабле оборудование (но не структуру корпуса и артефакты):
  1 - корабль;
ShipImproveItems - улучшает оборудование на корабле:
  1 - корабль;
  2 - сколько раз улучшить (один заход на корабль - улучшение одного случайного предмета или вставка в него случайного ММ);
ItemImprovement - проверяет, улучшен ли данный предмет (значение одного из основных параметров выше, либо ниже нормы для данного ТУ), либо улучшает его:
  1 - предмет (проверит, улучшен ли он, что выражается в соотнесении стандартных статов предмета для данного ТУ с его текущими параметрами);
  Опционально:
  2 - степень улучшения:
     0 - стажёры;
     1 - обычные спецы;
     2 - лучшие спецы;
     3+ - случайные спецы (вариант по умолчанию);
  3 - какой параметр улучшать, если предмет имеет несколько характеристик:
     0 - случайный параметр из возможных (вариант по умолчанию), для предметов с одним параметром выберет только его;
     1 - первый параметр;
     2 - второй параметр;
  4 - Id предмета/зерно для определения рандомного модификатора в формуле улучшения (можно использовать, чтобы "стандартизировать" степень улучшения для разных предметов);
  Примечание: Данная функция игнорирует параметр BlockImp.
ItemCanBeBroken - проверяет, имеется ли у предмета шкала износа:
  1 - предмет;
ItemIsBroken - проверяет наличие флага полной сломанности на предмете (не идентично проверке ItemDurability(item) == 0):
  1 - предмет (0 - не сломан, 1 - сломан);
ItemDurability - возвращает текущий износ предмета в проценатх (от 0 до 100, где 0 полностью изношенный предмет) или устанавливает этот процент:
  1 - предмет;
  Опционально:
  2 - какой процент износа установить;
  Важно: Может возвращать нахер не нужные отрицательные значения прочности! Используйте ItemIsBroken() для надёжной проверки сломанности предмета.
ItemFragility - возвращает текущий показатель "хрупкости" предмета с учётом всех штрафов/бонусов, в виде float:
  1 - предмет;
    Игровая оценка надёжности предмета (выбирается ближайший к текущему Fragility показатель):
      0.70 - непревзойдённая надёжность (QualityGrade0 в Lang);
    0.80 - очень высокая надёжность (QualityGrade1 в Lang);
    0.90 - высокая надёжность (QualityGrade2 в Lang);
    1.00 - средняя надёжность (QualityGrade3 в Lang);
    1.20 - низкая надёжность (QualityGrade4 в Lang);
    1.40 - очень низкая надёжность (QualityGrade5 в Lang);
    1.60 - ужасная надёжность (QualityGrade6 в Lang);
ItemLevel - возвращает/устанавливает ТУ оборудования:
  1 - оборудование (в том числе корпус);
  Опционально:
  2 - какой ТУ установить (от 1 до 8);
ShipTechLevelKnowledge - возвращает/устанавливает кораблю разрешение на пользование оборудованием доминаторов указанного уровня вне зависимости от ГТУ (по умолчанию каждый ТУ оборудования доминаторов разблокируется для всех прочих кораблей только по мере роста ГТУ):
  1 - корабль;
  Опционально:
  2 - какой максимальный уровень допуска установить (от 1 до 8);
  Примечание: Если экипировать доминаторское оборудование на корабль без соответствующего разрешения у корабля через скрипт, то такое оборудование будет выделено в слоте как сломанное.
ShipSpecialBonuses - возвращает величину акринового бонуса определённого типа для указанного корабля или устанавливает эту величину (это значения дополнительных скриптовых бонусов на весь корабль, а не тех, что добавляются акриновым оборудованием):
  1 - корабль;
  2 - тип бонуса числом (пример: bonSpeed);
  Опционально:
  3 - какое значение бонуса установить, либо строка 'Total' для запроса общей текущей суммы данного бонуса на всём корабле, включая все акрины и ММ;


Задания:
StartTextQuest - запускает текстовый квест (для мгновенного запуска необходимо также перевести игрока на любую другую форму):
  1 - имя квеста строкой;
  2 - текст при победе (можно оставить '', тогда по умолчанию будет выводить 'Задание выполнено');
  3 - текст при поражении (можно оставить '', тогда по умолчанию будет выводить 'Квест провален');
StartRobots - запускает ПБ:
  1 - название файла карты ПБ вместе с расширением (пример: 'SeaBattle.cmap');
  2 - стартовый текст;
  3 - текст при победе;
  4 - текст при поражении;
  Опционально:
  5 - место проведения строкой (на случай, если в текстах используется подстановка названия планеты);
  6 - дополнительные настройки строкой (подставлять можно и в виде числа) из трёх цифр вида '621':
    Первая цифра - раса правителя в текстовых сообщениях (по умолчанию 6):
      1 - малоки;
    2 - пеленги;
    3 - люди;
    4 - фэяне;
    5 - гаальцы;
    6 - без портрета;
    Вторая цифра - сложность карты (по умолчанию 2):
      1 - 50%
    2 - 100%
    3 - 150%
    4 - 200%
    Третья цифра - дополнительный бонус (по умолчанию 1):
      1 - без бонуса;
    2 - ускоренная поддержка с воздуха;
    3 - усиленная броня;
  Примечание: Оригинальные номера карт в Lang: с 01 по 74 с учётом пиратских сюжетных.
MarkRobotsMapAsUsed - помечает конкретный планетарный бой, как уже выполненный игроком:
  1 - имя карты (пример: 'something.cmap');
  Опционально:
  2 - маркер для ресета таймера выдачи ПБ (чтобы в правительстве в тот же ход не выдавали задание на новый бой);
 Примечание: Для карт, имеющих возможность повторного прохождения за игру (параметр Reiteration), необходимо запускать MarkRobotsMapAsUsed несколько раз. Столько, сколько указано в Reiteration, так как один запуск этой функции равен одному прохождению конкретной карты.
PlayerQuestInProgress - без аргументов, проверяет, есть ли у игрока неоконченные правительственные задания;
BuildListOfQuestPossibleLocations - записывает в массив список коалиционных систем, находящихся на определённом расстоянии от указанной системы пропускает системы, где идет бой или куда летят доминаторы:
  1 - массив для записи результатов (будет очищен автоматически), либо переменная типа unknown (будет превращена в массив);
  2 - система;
  3 - минимальное расстояние;
  4 - максимальное расстояние;


Деньги:
GalaxyMoney - возвращает текущую среднюю галактическую сумму денег (результат пропорционален среднему капиталу рейнджеров), условно заданную разработчиками в градациях от незначительной до огромной:
  1 - размер суммы:
     0 - Galaxy.MiniMoney(own);
     1 - Galaxy.SmallMoney(own);
     2 - Galaxy.AverageMoney(own);
     3 - Galaxy.BigMoney(own);
     4 - Galaxy.HugeMoney(own);
  Опционально:
  2 - модификатор расы, от малоков (минимальный модификатор) до гаальцев (максимальный модификатор), по умолчанию выставлен на людей:
     0 - малокский модификатор;
     1 - пеленгский модификатор;
     2 - человеческий модификатор (выбирается по умолчанию);
     3 - фэянский модификатор;
     4 - гаальский модификатор;

function TGalaxy.MiniMoney(Owner:TOwner = People):integer;
begin
  Result := Round(FRangersAverageCapital * kMoneyMini * mOwner[Owner].kMargin);
  if Result > MiniItemCost then Result := MiniItemCost + Round((Result - MiniItemCost) * 0.3);
end;

  kMoneyMini    = 1 / 100;
  kMoneySmall   = 1 / 65;
  kMoneyAverage = 1 / 40;
  kMoneyBig     = 1 / 25;
  kMoneyHuge    = 1 / 15;

  MiniItemCost    = 000250;
  SmallItemCost   = 001000;
  AverageItemCost = 005000;
  BigItemCost     = 010000;
  HugeItemCost    = 025000;

FirstGiveMoney - без аргументов, возвращает сумму денег на счету игрока на момент начала игры;
RangersCapital - без аргументов, возвращает суммарный общегалактический капитал всех рейнджеров, кроме тех, что были исключены из рейнджерского рейтинга (используется во многих внутриигровых расчётах);
  Примечание: Если Коалиция побеждена, то к общему капиталу всех до сих пор существующих рейнджеров прибавляется также капитал всех странствующих клановых пиратов.
ShipMoney - возвращает или устанавливает текущее количество денег корабля:
  1 - корабль;
  Опционально:
  2 - какое количество денег установить, если количество денег изменено, то вернёт количество денег до изменения;
  Примечание: Функция не позволит установить количество денег ниже 0, так что дополнительные проверки на отрицательный баланс после его изменения не требуются.
ShipWealth - возвращает текущий капитал конкретного корабля:
  1 - корабль, его капитал складывается из:
     - Текущий счёт;
     - Депозит;
     - Стоимость оборудования на корабле;
     - Стоимость оборудования на складах;
PlayerDebt - возвращает или устанавливает долг игрока по кредиту:
  Без аргументов - возвращает долг игрока;
  Опционально:
  1 - установить сумму долга;
PlayerDebtDate - возвращает или устанавливает дату возврата кредита (0 означает, что кредита нет):
  Без аргументов - возвращает дату;
  Опционально:
  1 - устанавливает дату;
PlayerDebtCnt - возвращает или устанавливает количество просрочек по кредитам:
  Без аргументов - возвращает количество;
  Опционально:
  1 - устанавливает количество;
PlayerDeposit - возвращает или устанавливает изначальную (целую) сумму на депозите игрока:
  Без аргументов - возвращает сумму;
  Опционально:
  1 - какую сумму установить;
PlayerDepositDate - возвращает или устанавливает дату открытия депозита:
  Без аргументов - возвращает дату;
  Опционально:
  1 - устанавливает дату;
PlayerDepositDay - возвращает или устанавливает сколько дней прошло с открытия депозита:
  Без аргументов - возвращает количество дней;
  Опционально:
  1 - устанавливает количество дней;
  Примечание: Дни, в которые процент находился под кредитной заморозкой, игра вычитает автоматически.
PlayerDepositPercent - возвращает или устанавливает % депозита:
  Без аргументов - возвращает процент (в виде целого, например 30, которое следует понимать как 3.0%);
  Опционально:
  1 - устанавливает процент (также в виде целого);
  Примечание: Сам по себе депозит является статичной переменной integer, а накопленный процент рассчитывается только при запросе к этому числу. Если вы собираетесь самостоятельно менять сумму на депозите, то необходимо сперва рассчитать накопленный процент по оригинальной игровой формуле: round(FDeposit * Power(1 + 0.01 * FDepositPercent / BKkDepositPercentPeriod, FDepositDay / 365 * BKkDepositPercentPeriod)) - где функция Power - это возведение первого аргумента X в степень второго Y (скриптовыми функциями может быть записана как exp(Y * ln(X))). После этого необходимо изменить сумму депозита с учетом процента, и под конец переустановить дату открытия счёта на день его изменения.
  Пример готовой кастомной функции расчёта процентов в скрипте мода ExpBK:
  //Функция расчёта накопленных процентов для текущего состояния депозитного счёта
  function DepositPercentCalc()
  {
    temp_float = 1.0 + 0.0001 * PlayerDepositPercent() / 12; //Считаем X
    temp_float = exp((1.0 * PlayerDepositDay() / 365 * 12) * ln(temp_float)); //Считаем Y и возводим X в степень Y
    result = round(temp_float * PlayerDeposit()); //Применяем получившийся процент к сумме на счету и округляем результат
  }


Здоровье:
PlayerMedPolicy - возвращает или устанавливает количество дней до завершения действия медицинского полиса у игрока:
  Без аргументов - вернёт количество дней;
  Опционально:
  1 - установить количество дней;
ShipHealthFactor - возвращает/устанавливает срок действия болезни/стимулятора:
  1 - корабль, либо 0, если нужно просто вернуть стандартную длительность для данного типа болезни/стимулятора;
  2 - № болезни/стимулятора;
  Опционально:
  3 - какую длительность действия установить (число ходов), либо автоматически установить стандартную длительность для данного типа болезни/стимулятора (если передан -1);
ShipHealthFactorStatus - возвращает вирусный период болезни (проще говоря, её таймер до полноценного заражения):
  1 - корабль;
  2 - тип болезни;
  Опционально:
  3 - какой вирусный период установить (0 - нет вируса, 1-99 есть вирус, 100 - полноценная болезнь);
  Примечание: Чекумаш, Слепота и Святой фанатизм моментально накидываются на игрока при любом положительном значении вируса, но только если игрок при этом находится на планете/станции. При лечении болезни на МЦ, в 0 опускается как длительность болезни, так и её вирусный период. Аналогичная ситуация с Наркозависимостью, которая тут же разовьётся в полноценную болезнь при любом положительном значении вируса.
PlayerImmunity - возвращает/изменяет текущую устойчивость (иммунитет) игрока к болезням (уменьшается сам со временем и повышается при лечении на МЦ):
  Без аргументов - вернёт текущий показатель иммунитета игрока;
  Опционально:
  1 - какое значение иммунитета установить (0-100);
  Примечание: При лечении отдельной болезни на МЦ, иммунитет повышается на +40, а при лечении сразу всех имеющихся болезней скопом (уринотерапия) лишь на +80. Таким образом, с точки зрения максимального прироста иммунитета, лечить болезни по отдельности выгоднее, но только если на момент лечения у игрока имеется хотя бы 3 разных болезни, а показатель иммунитета ниже 20.

Номера болезней:
  0 - Лучевая болезнь (все расы: снижает получаемый опыт (штраф накапливается, но если повесить болезнь скриптом, то будет составлять 50%));
    Примечание: Лучевая болезнь не применяется в КР:HD, но всё ещё может быть наложена с помощью скрипта.
  1 - Ослепление (все расы: делает все силуэты космических объектов полупрозрачными, точность, манёвренность, техника и торговля по -3);
  2 - Чекумаш (все расы: появляются различные глюки в космосе);
  3 - Святой фанатизм (все расы: все корабли и оборудование начинают казаться доминаторскими, точность и манёвренность по +1, обаяние -1, лидерство +2);
  4 - Комплексный иммуноцид (все расы: практически моментальное заражение чем угодно, если в организм попадёт вирус);
  5 - Загадочная луатанция (все расы: невозможность заниматься рэкетом, периодические выплаты из фонда (только для игрока), точность -2, обаяние +3);
  6 - Наркозависимость (все расы: повышает износ оборудования в 2 раза (только для игрока), точность и манёвренность по -3, техника -2);
  7 - Вихревая контузия (все расы: накладывает скрытый дебаф* (только для игрока), точность -2, манёвренность -5, торговля -10);
  8 - Мышечное растяжение (все расы: накладывает скрытый дебаф* (только для игрока), точность, манёвренность и торговля по -2, обаяние и лидерство по -1);
  9 - Великий Малососус (только малоки: увеличивает массу корабля на 20% (только если заболевший - малок, но иное в нормальных условиях и невозможно), лидерство и торговля по +3);
  10 - Горькая пеленоша (только пеленги: повышает износ оборудования в 3 раза (исключая износ в бою) и накладывает скрытый дебаф* (только для игрока), техника -10);
  11 - Ака Сециянка (только фэяне: шанс случайных дропов товара из трюма в космосе (только для игрока), точность -1, техника -2, торговля +2);
  12 - Новый молизон (только гаальцы: торговля медикаментами и едой на планетах считается контрабандой, точность и манёвренность по +1);
Номера стимуляторов:
  13 - Малокская сижа (точность +4, манёвренность +3);
  14 - Одноглазый Хамас (любой рэкет всегда будет успешен (только для игрока), обаяние и лидерство по -1);
  15 - Звёздная пыль (точность, манёвренность, техника и торговля по +1);
  16 - Супер техник (снижает износ оборудования на 60% (только для игрока), техника +5);
  17 - Гаалистра времени (повышает скорость корабля на 30%, точность +4, манёвренность +2);
  18 - Кровяной джогар (повышает иммунитет);
  19 - Рагобамский шёпот (обаяние +10 (а ещё можно есть рагобамских жаб, лол));
  20 - Ведущий Шахманду (увеличивает срок найма других кораблей в 2 раза (только для игрока), обаяние +1, лидерство +4);
  21 - Психотропный кэш (увеличивает дальность радара в 2 раза (только для игрока), мощность сканера +12, обаяние -3);
  22 - Торговая маркировка (увеличивает получаемый торговый опыт в 1,5 раза (для игрока, транспортов и рейнджеров), торговля +8);
  23 - Дубльплекс (увеличивает награду за правительственные задания в 1.3 - 2.3 раза (только для игрока), точность и манёвренность по -1);
  24 - Абсолютный статус (сроки исполнения правительственных заданий становятся в 1,5 раза мягче (только для игрока), обаяние +2);
    *Важно: Если игрок (и только игрок) болеет вихревой контузией, мышечным растяжением или горькой пеленошей (эффект не суммируется), то наносимый им урон получает скрытый дебаф и случайно умножается (в момент атаки) на значение от 0% до 100%.
  Примечание: Обратите внимание, что в Lang.dat разделы болезней идут с дебильным смещением в -1 относительно приведённых выше номеров.

Ход (даты):
GameDateTxtByTurn - возвращает строку с датой указанного хода (к примеру - 21 апреля 3301):
  1 - номер хода;
CurTurn - без аргументов, возвращает текущий ход:
  Без аргументов - вернуть номер текущего хода;
  Опционально:
  1 - установить новый номер хода;
ForceNextDay - без аргументов, принудительный запуск следующего хода;
IsFilm - проверяет проигрывается ли сейчас отображение хода (т.е. летают/стреляют ли по экрану корабли), если летают, то операции со сменой шкурок могут работать некорректно
(а могут и корректно, после последнего рефакторинга, но я не проверял);
FilmFlags - проверяет и выставляет различные условия для автоматического прерывания фильма (отображения хода) между ходами:
  1 - тип флага, либо система, в которой нужно его установить (систему имеет смысл ставить лишь ту, в которой находится игрок, так что её указывать не обязательно);
  2 - включить/выключить флаг (0 или 1), либо тип флага;
  3 - только включить/выключить флаг (0 или 1);
  Примеры:
  - FilmFlags(N) - проверяет установленный флаг (N в данном случае пустые скобки по идее);
  - FilmFlags(N, val) - устанавливает нужный флаг на следующий ход, например FilmFlags(3, 1);
  - FilmFlags(star, N) - аналогично проверяет флаг, но для определённой системы;
  - FilmFlags(star, N, val) - устанавливает флаг для определённой системы;
  Типы флагов:
  0 FilmBuild, film is being made for this star, can't set value
  1 - данный флаг прерывает фильм с началом боевых действий (игрок получил урон, либо нанёс урон сам);
  2 - данный флаг прерывает фильм если игрок подобрал предмет, форсаж износил двигатель ниже предельно допустимого значения, либо другой NPC инициировал разговор с игроком;
  3 - данный флаг не прерывает фильм вообще никогда (не используется в оригинальной игре);
  Все значения флагов проверяются кодом в конце хода и автоматически сбрасываются с началом следующего. То есть если вам нужен непрерывный полёт корабля из точки А в точку Б, то нужно будет каждый ход задавать глобальный (или конкретно для данной системы) флаг типа 3. Любой из установленных флагов сам игрок может прервать нажатием кнопки "Конец хода";
  //star - no reason normally to set flags 1..3 for stars other than player's location, but can be used to skip checking

Транклюкаторы:
UseTranclucator - активирует и возвращает адрес одного транклюкатора на любом корабле:
  1 - корабль (корабль, запустивший транклюкатора, автоматически становится его хозяином);
  Опционально:
  2 - артефакт-транклюкатор, который нужно активировать;
PlayerTranclucators - возвращает количество активных транклюкаторов игрока, или корабль конкретного активного транклюкатора:
  Без аргументов - возвращает количество;
  Опционально:
  1 - номер транклюкатора, начиная с 0;
!!!Для возврата конкретного транка функция PlayerTranclucators() делает перебор всех кораблей в Галактике. Имейте это ввиду, когда будете работать над оптимизацией кода!!!
ArtTranclucatorToShip - возвращает корабль транклюкатора из транклюкатора-артефакта:
  1 - артефакт (неактивный транклюкатор);
TranclucatorData - возвращает или устанавливает определённый параметр транклюкатора:
  1 - транклюкатор;
  2 - параметр (строкой или номером);
  Опционально:
  3 - новое значение параметра;
    Параметры:
    0 или 'Proprietor' - хозяин транклюкатора;
    1 или 'ArtSize' - размер артефакта, в который превратится транклюкатор после сворачивания;
    2 или 'ArtSysName' - системное имя артефакта, в который превратится транклюкатор после сворачивания;
    3 или 'Docking' - маркер (0/1), при котором транклюкатор, имеющий приказ простого следования, залетит в трюм после сближения с хозяином;
    4 или 'SeekItems' - маркер, при котором транклюкатор будет заниматься сбором вещей;
    5 или 'AutoArrange' - маркер, при котором транклюкатор будет автоматически менять оборудование на более качественное из своего трюма;
    6 или 'LandStorage' - маркер, при котором транклюкатор после совершения посадки на любую планету или станцию, автоматически свернётся на склад в виде артефакта;
    7 или 'LandPermitPlanets' - маркер, при котором транклюкатору разрешены автоматические посадки на планеты при сборе вещей;
    8 или 'LandPermitRuins' - маркер, при котором транклюкатору разрешены автоматические посадки на станции при сборе вещей;
    9 или 'SeekPermitNone' - маркер, при котором транклюкатору разрешён сбор зондов, цистерн, карт сокровищ и корпусов (в оригинальной игре не используется);
    10 или 'SeekPermitArtefact' - маркер, при котором транклюкатору разрешён сбор артефактов (в т.ч. кастомных);
    11 или 'SeekPermitMicromodule' - маркер, при котором транклюкатору разрешён сбор микромодулей;
    12 или 'SeekPermitEquipment' - маркер, при котором транклюкатору разрешён сбор оборудования;
    13 или 'SeekPermitUseless' - маркер, при котором транклюкатору разрешён сбор ошмётков и прочих "юзлесов";
    14 или 'SeekPermitGoods' - маркер, при котором транклюкатору разрешён сбор товаров;
    15 или 'SeekPermitNode' - маркер, при котором транклюкатору разрешён сбор нодов и кастомных сыпучих;


Чёрные дыры:
GABStatus - локальная скриптовая переменная (по умолчанию имеется внутри каждого скрипта), отвечающая за заказ скриптом аркадного боя, значения:
  0 - АБ не заказан данным скриптом;
  1 - текущий скрипт заказал АБ;
  2 - заказанный текущим скриптом АБ завершён и скрипт получает внеплановое срабатывание тернкода (сразу же в день завершения АБ, а не в день вылета игрока из ЧД/гипера);
  Примечание: По умолчанию тернкод во всех скриптах срабатывает перед началом АБ для игрока, так что можно поймать любой "залёт" в ЧД проверкой функции ShipInHole. Также имейте ввиду, что каждый ход, который игрок проведёт внутри ЧД будет также аналогичным образом обработан тёрнкодом, что нужно учесть, особенно если вы собираетесь запускать собственный бой АБ вместо стандартного игрового.
HoleCreate - создаёт и возвращает "чёрную дыру":
  1 - скриптовое место для создания входа в ЧД;
  2 - скриптовое место для создания выхода из ЧД;
  Примечание: Скриптовые места заранее создаются только в скрипте.
HoleCreate2 - создаёт и возвращает "чёрную дыру" по упрощённой схеме, если нет необходимости задавать её координаты по скриптовым местам (вход и выход будут созданы в случайных точках системы):
  1 - система со входом в ЧД;
  2 - система с выходом из ЧД, остальное будет подобрано случайно;
HoleMap - возвращает или устанавливает карту аркадного боя для ЧД:
  1 - чёрная дыра;
  Опционально:
  2 - путь и название карты АБ ('ABMap.Map_name'), либо особый маркер:
    'SkipAB' - автоматически пропустит аркадный бой при влёте игрока в данную ЧД;
    'NoEntry' - запрещает игроку вход в данную ЧД, а также такая ЧД будет невидима на карте;
HoleTurnCreate - возвращает или устанавливает ход создания ЧД (фактически определяет день, когда она закроется):
  1 - чёрная дыра;
  Опционально:
  2 - какой ход создания установить;
  Примечание: Срок жизни обыкновенной ЧД (по умолчанию) составляет 200 дней со дня открытия. Допустимо указывать дату как раньше, так и позже фактического хода создания, чтобы не только уменьшить, но и, при желании, продлить стандартное время жизни ЧД.
HoleStar1 - возвращает или устанавливает систему со входом в конкретную ЧД:
  1 - ЧД;
  Опционально:
  2 - система, куда переместить точку входа;
HoleStar2 - возвращает или устанавливает систему с выходом из конкретной ЧД:
  1 - ЧД;
  Опционально:
  2 - система, куда переместить точку выхода из ЧД;
StarHoles - возвращает количество ЧД в системе, или конкретную ЧД из этого списка:
  1 - система;
  Опционально:
  2 - номер ЧД в списке;
GalaxyHoles - возвращает количество ЧД в галактике, либо конкретную ЧД из этого списка:
  Без аргументов - возвращает количество;
  Опционально:
  1 - номер ЧД в списке, вернёт конкретную ЧД;
HoleX1 - возвращает или устанавливает X координату входа в ЧД:
  1 - ЧД;
  Опционально:
  2 - новая X координата;
HoleY1 - возвращает или устанавливает Y координату входа в ЧД:
  1 - ЧД;
  Опционально:
  2 - новая Y координата;
HoleX2 - возвращает или устанавливает X координату выхода из ЧД:
  1 - ЧД;
  Опционально:
  2 - новая X координата;
HoleY2 - возвращает или устанавливает Y координату выхода из ЧД:
  1 - ЧД;
  Опционально:
  2 - новая Y координата;


Аркадный бой (все функции из данного списка применяются из тернкода, в момент влёта игрока в ЧД):
CreateABShip - создаёт (и возвращает указатель для изменения модификаторов) стандартный корабль для аркадного боя:
  1 - путь к анимации корабля в 'Main.dat\Data\SE' (например, 'Ship.Fei.Liner' создаст в АБ фэянский лайнер, а 'Ruins.Blazer' - Блазера);
  Опционально:
  2 - на чьей стороне будет сражаться корабль (1 - союзники игрока, 0, 2, 3, 4 и т.д. - враждебные игроку стороны);
  3 - процентный модификатор максимального количества HP корабля (по умолчанию 100%);
  4 - процентный модификатор наносимых повреждений (по умолчанию 100%);
  5 - строковая метка для корабля (чтобы можно было отследить его уничтожение/выживание через галактические события LabeledShipKilledInAB/LabeledShipSurvivedInAB);
  6 - что выпадет из этого корабля при его уничтожении, указатель на предмет, либо -1, чтобы задать стандартный дроп, как в оригинальной игре (по умолчанию не падает ничего);
ConvertToABShip - создаёт (и возвращает указатель для изменения модификаторов) корабль для АБ по шаблону реального игрового корабля:
  1 - корабль-шаблон;
  Опционально:
  2 - на чьей стороне будет сражаться корабль (1 - союзники игрока, 0, 2, 3, 4 и т.д. - враждебные игроку стороны);
  3 - процентный модификатор максимального количества HP корабля (по умолчанию 100%);
  4 - процентный модификатор наносимых повреждений (по умолчанию 100%);
  5 - строковая метка для корабля (чтобы можно было отследить его уничтожение/выживание через галактические события LabeledShipKilledInAB/LabeledShipSurvivedInAB);
  6 - что выпадет из этого корабля при его уничтожении, указатель на предмет, либо -1, чтобы задать стандартный дроп, как в оригинальной игре (по умолчанию не падает ничего);
ABShipModifiers - возвращает или устанавливает кораблю модификаторы для аркадного боя:
  1 - корабль;
  2 - модификатор строкой:
     'damage' - наносимый урон (базовое значение 100);
     'recharge' - скорость перезарядки орудий (базовое значение 100);
     'speed' - скорость корабля (базовое значение 100);
     'gravity' - то, как сильно на корабль будут действовать различные притягивающие объекты (базовое значение 100);
     'regen' - скорость восстановления здоровья (базовое значение 0):
        - Дроид младший: +100 (за каждого младшего дроида в слоте);
      - Бонус-аптечка: +1000;
     Примечание: Все перечисленные бонусы суммируются.
     'fragility' - модификатор получаемого урона (базовое значение 100);
     'luck' - шанс выпадения вещей из противников (базовое значение 100);
  Опционально:
  3 - какое значение установить (в теории принимает даже отрицательные значения, но как с ними будет работать код АБ неизвестно);
  Примечание: В обычной ситуации менять модификаторы можно самому игроку по событию t_OnStartAB или кораблям, создаваемым функцией CreateABShip(). Однако, принимать в качестве корабля указатель на игрока (Player()) функция  может в любой момент, но если игрок при этом не находится в ЧД (или не сработало t_OnStartAB), то изменить модификатор она не сможет (вернёт 0). Может быть полезно для того, чтобы менять игроку модификатор от кастомного артефакта уже в процессе идущей аркадной битвы, если, например, игрок решит его снять или надеть.
StartAB - запускает аркадный бой с установленными выше условиями:
  Без аргументов - вернёт число всех заказанных на данный момент АБ, включая заказанные другими скриптами;
  Опционально:
  1 - имя АБ карты, номер или строка пути в CacheData вида 'ABMap.Map_name';
  2 - используемый фон в виде номера (от 1 до 4, где 4 - особый небесный фон из КР:HD) или полный адрес в CacheData строкой;
  Примечание: При вызове данной функции в момент залёта игрока в ЧД, стандартный заданный игрой аркадный бой будет заменён на установленный игроком вариант, с учётом всех созданных ранее в том же обработчике АБ кораблей и применённых модификаторов. Данная функция запускает аркадный бой, попутно выставляя маркер GABStatus = 1, так что все настройки этого боя должны быть заданы непосредственно перед вызовом данной функции.


Операции с нодами:
CreateNodes - создаёт ноды и возвращает на них ссылку:
  1 - количество;
  Опционально:
  2 - серия доминатора (0 - 2);
  3 - вид в космосе (0 - контейнер, 1 - ноды);
GetNodesFromShip - возвращает общее количество нодов на корабле или удаляет некоторое их количество:
  1 - корабль (возвращает количество);
  Опционально:
  2 - сколько нодов изъять;
GetNodesFromStorage - возвращает общее количество нодов на складе (игрока) или удаляет некоторое их количество:
  Без аргументов - возвращает общее количество нодов на всех складах;
  Опционально:
  1 - планета/станция, возвращает количество нодов на конкретной базе/планете;
  2 - сколько нодов изъять со склада планеты/станции;
RangerBaseNodes - возвращает или изменяет состояние нод-счёта рейнджера:
  1 - рейнджер (возвращает текущее состояние нод-счёта);
  Опционально:
  2 - какое состояние нод-счёта установить;


Запреты:
NoDropToShip - запрет кораблю дропать любые предметы при гибели:
  1 - корабль;
  Опционально:
  2 - запретить/разрешить дроп;
NoTargetToShip - проверяет, устанавливает и снимает запрет атаковать корабль:
  1 - корабль;
  Опционально:
  2 - изменить состояние запрета:
     0 - разрешить атаковать корабль;
     1 - запретить атаковать корабль данный корабль (включая нацеливание пушек) всем, кроме безусловно враждебных кораблей (доминаторы, военные и т.д.);
     2 - запретить атаковать корабль данный корабль (включая нацеливание пушек) всем, кроме безусловно враждебных кораблей и игрока;
     3 - запретить пиратам и рейнджерам по своей инициативе нападать на этот корабль с целью ограбления;
     4 - запретить только рейнджерам по своей инициативе нападать на этот корабль с целью ограбления;
     5 - запретить только пиратам по своей инициативе нападать на этот корабль с целью ограбления;
     6 - повесить на корабль маркер квестовой цели, что будет привлекать повышенное внимание всяких пиратов и прочих грабителей;
NoTalkToShip - проверяет, устанавливает и снимает запрет разговаривать с указанным кораблём:
  1 - корабль (либо маркер 0/1 для игрока);
  Опционально:
  2 - запретить/разрешить переговоры;
NoScanToShip - проверяет, устанавливает и снимает запрет сканировать корабль:
  1 - корабль (либо маркер 0/1 для игрока);
  Опционально:
  2 - запретить/разрешить сканировать корабль;
  Примечание: Две вышеперечисленные функции могут ставить запрет на вызовы других кораблей (игрок не сможет самостоятельно вызывать/сканировать другие корабли) непосредственно для игрока. Для этого необходимо указать маркер 1 - установить запрет, или 0 - снять запрет, в качестве первого и единственного аргумента (пример: NoTalkToShip(1)). Соответственно, при вызове этих функций без аргумента, они вернут состояние конкретно данного запрета для игрока.
NoJump - проверяет, устанавливает и снимает запрет на совершение прыжков игроком:
  Без аргумента - проверяет наличие запрета;
  Опционально:
  1 - запретить/разрешить игроку совершать прыжки;
  Примечание: Чтобы скрытно повесить запрет совершения прыжков на NPC, можно использовать штраф bonFuel через функцию ShipSpecialBonuses() (либо bonJump, но такой штраф будет заметен в карточке двигателя). Учтите, однако, что такой "запрет" для NPC будет не безоговорочным, и в ряде случаев некоторые типы NPC (например, рейнджеры) будут нарушать данный запрет (например, если рейнджер стремится воссоединиться со своим напарником).
NoLanding - проверяет, устанавливает и снимает запрет игроку совершать посадку на конкретную планету или станцию:
  1 - планета/станция (проверяет состояние запрета);
  Опционально:
  2 - запретить/разрешить игроку посадку на указанный объект;
NoShopUpdate - проверяет, устанавливает и снимает запрет на автоматическое обновление магазина оборудования и/или товаров игрой:
  1 - магазин (планета или станция);
  Опционально:
  2 - установить или снять запрет на автоматическое обновление ассортимента:
     0 - автообновление разрешено для обоих магазинов;
     1 - автообновление запрещено для обоих магазинов;
     2 - автообновление запрещено только для магазина товаров;
     3 - автообновление запрещено только для магазина оборудования;
  Примечание: Запрет на обновление магазина товаров не исключает вероятности того, что станция выставит на продажу минералы, которые она притянула своим захватом.
NoDropItem - проверяет, устанавливает и снимает запрет выбрасывать/перемещать предмет:
  1 - предмет (вернёт состояние запрета);
  Опционально:
  2 - запретить/разрешить выбрасывать;
RuinsAllowModernization - проверяет или устанавливает разрешение у игрока на модернизацию базы:
  1 - база (проверяет наличие разрешения);
  Опционально:
  2 - разрешить/запретить игроку модернизацию базы;


Статистические данные:
DomikKilledInCurSystem - количество домиков, убитых в текущей системе (обнуляется при прыжке):
  1 - корабль;
ShipKillFactionInCurSystem - возвращает/устанавливает число конкретных кораблей и станций, уничтоженных кораблём в текущей системе (счётчики обнуляются если корабль ушёл в гипер, попал в тюрьму, а также сразу после захвата системы или снятии с неё StarCustomFaction()):
  1 - корабль;
  2 - тип уничтоженных им кораблей:
    -1 - корабли с враждебной кастомной фракцией (а конкретнее, любые корабли и станции с ShipStanding() равном 9);
     0 - коалиционные корабли;
     1 - доминаторы;
     2 - клановые пиратские корабли;
  Опционально:
  3 - какое число уничтоженных кораблей данного типа установить;
  Примечание: Завышая с помощью данной функции число уничтоженных кораблей Коалиции или доминаторов можно "подбодрить" пирата (а заодно и всех остальных пиратов, т.к. успехи одного повышают общий процент успешности идущего боя) и, тем самым, снизить вероятность пиратского бегства из обороняемой системы. Также данную функцию можно использовать для определения, какие корабли кроме военных должны быть уничтожены пиратами для захвата системы (все корабли, успевшие убить хотя бы одного кланового пирата).
ShipStatistic - возвращает/изменяет указанные статистические данные корабля:
  1 - корабль;
  2 - тип статистики:
     0 - уничтожил кораблей всего;
     1 - уничтожил пиратов;
     2 - уничтожил доминаторов;
     3 - освободил систем;
     4 - уничтожил гражданских;
     5 - уничтожил военных;
     6 - уничтожил рейнджеров;
     7 - уничтожил кораблей в ЧД;
     8 - уничтожил кораблей в гипере (гиперпираты при перелётах между системами);
     9 - текущее "торговое пенальти" игрока (накапливается при торговле в убыток и до тех пор, пока не будет полностью компенсировано прибылью, опыт и рейтинг за торговлю игроку начисляться не будет);
     10 - родная планета корабля (в третьем аргументе её можно изменить);
     11 - ход рождения корабля;
  Опционально:
  3 - новое значение выбранной статистики;
  Примечание: При изменении количества уничтоженных кораблей в какой-либо конкретной категории (военные, пираты и т.д.), необходимо также изменять и общее число уничтоженных кораблей. В противном случае игровые счётчики начнут показывать неверный результат. Часть кораблей не заносятся игрой ни в какую категорию, кроме общей: транклюкаторы, станции, корабли с враждебной кастомной фракцией - в игровой статистике все они числятся в разделе "Другие".
PlayerDominatorStatistic - возвращает/изменяет число доминаторов конкретного подтипа, уничтоженных игроком:
  1 - подтипы доминаторов:
     0 - боссы;
     1 - эквенторы;
     2 - урганты;
     3 - смерши;
     4 - менки;
     5 - штипы;
     6 - берторы;
     7 - клиги;
  Опционально:
  2 - установить новое число уничтоженных подтипов доминаторов;
  Примечание: Если нужно добавить игроку в статистику уничтоженных доминаторов, то сперва необходимо два раза вызывать функцию ShipStatistic(), повысить общее число уничтоженных кораблей и число уничтоженных доминаторов, после чего вызвать PlayerDominatorStatistic() и распределить новые корабли по конкретным подтипам (хотя прямой связи между числом уничтоженных доминаторов всего и их подтипами в статистике нет).
PlayerQuestsCompleted - возвращает число выполненных игроком правительственных заданий:
  Без аргументов - вернёт общее число всех выполненных правительственных заданий;
  Опционально:
  1 - определённый тип заданий:
     0 - доставка грузов;
     1 - убийства кораблей;
     2 - текстовые квесты;
     3 - защита систем;
     4 - защита кораблей;
PlayerPlanetaryBattlesCompleted - без аргументов, возвращает число успешно выполненных игроком планетарных битв;
QuestsStatusByNom - принимает тип и номер правительственного задания (включая несюжетные ТК), и возвращает его статус:
  1 - тип квеста:
     0 - SendLetter;
     1 - KillShip;
     2 - PlanetQuest;
     3 - DefSystem;
     4 - DefShip;
  2 - номер квеста (есть в Lang в разделе Quest);
     Возвращаемые типы статусов:
        0 - квест не взят;
      1 - квест взят;
        2 - квест выполнен;
      3 - квест выполнен и за него уже получена награда;
      4 - квест провален;
GalaxyDominatorResearchPercent - возвращает процент исследования доминаторов на НБ:
  Без аргументов - вернёт общий процент исследования доминаторов на НБ;
  Опционально:
  1 - число, вернет процент исследования конкретной расы доминатора;
  2 - установить новое значение;
GalaxyDominatorResearchMaterial - возвращает количество материала для исследования доминаторов на НБ:
  Без аргументов - вернёт общее количество материала для исследования доминаторов на НБ;
  Опционально:
  1 - число, вернёт количество материала для исследования конкретной расы доминатора;
  2 - установить новое значение;
GalaxyTechLevel - возвращает текущий ГТУ;
GalaxyDiffLevels - возвращает среднюю сложность игры, либо значение одной из конкретных настроек (от 50 до 500), без аргументов возвращает общую сложность, номера отдельных настроек:
  0 - пираты;
  1 - разброс цен;
  2 - учёные;
  3 - поломки;
  4 - оборудование;
  5 - задания;
  6 - чёрные дыры;
  7 - удача;
  Примечание: Общая сложность непосредственно влияет на следующие моменты:
          - Качество улучшений экипировки боссов;
        - Общая сложность (крутость) доминаторов (если не выставлена ТН, которая замещает собой влияние общей сложности);
        - Навыки доминаторов;
        - Опыт, получаемый за уничтожение доминаторов;
        - Сложность планетарных боёв;


Стандартные операторы:
Стандартные скриптовые переменные в дабокоде условно делятся на три основных типа: временные, постоянные и глобальные.
  - Временные переменные - это переменные (и массивы), которые можно объявлять в процессе исполнения кода (акткода, юзкода, стейткода, диалогкода, глобалкода, интерфейскода, а также любые переменные, объявленные внутри скриптовых функций), однако по завершении исполнения данного блока кода эти переменные навсегда удаляются из памяти.
  - Постоянные переменные - это переменные (и массивы), которые объявляются с помощью объектов "на доске" скрипта (в виде объектов), либо из иниткода или тернкода (будут доступны только внутри тернкода, но при этом сохраняются в сейв) скрипта. Такие переменные не удаляются по завершении кода и сохраняются непосредственно в игровые сейвы, что позволяет использовать их как долговременные хранилища скриптовых данных.
  - Глобальные переменные - это постоянные переменные (и массивы), которые можно объявить только "на доске" скрипта, путём выставления специальной галки в объекте любой переменной. От обычных постоянных переменных "глобалки" отличаются тем, что их могут видеть и изменять любые скрипты (а также глобалкод, акткод и юзкод), а не только тот, в котором они были объявлены. Глобалку с идентичным именем допустимо объявлять сразу в нескольких скриптах (код будет считать её одной переменной), на её функциональность это не повлияет, а вот использовать для постоянной или временной переменной имя уже существующей глоаблки не стоит, т.к. в таком случае обращения к глобалке для кода, в котором была объявлена "тёзка", будут недоступны. В принципе, злоупотреблять глобальными переменными в скриптах не стоит, поскольку они "засоряют" код лишними проверками и обращениями от всех прочих кодов и скриптов, в том числе от тех, которые эти переменные никогда не используют.
unknown - объявляет переменную неопределённого типа (нужна для последующего объявления/зачистки массивов или внешних функций);
  Примечание: Если приравнять значение unknown переменной любой другой (при помощи функции copy()), то вторая переменная также получит значение unknown. Это может быть полезно, если необходимо, например, зачистить массив без удаления его структуры (что особенно актуально для многомерных массивов) для последующей перезаписи его значениями другого типа.
int - объявляет переменную типа integer;
dword - объявляет переменную типа dword;
str - объявляет переменную типа string;
float - объявляет переменную типа double (название не соответствует фактическому типу в дабоязыке);
  Примечание: При объявлении переменных в скрипте, переменные, объявленные визуальным объектом, равны по валидности переменным, объявленным внутри кода, однако для улучшения читабельности и во избежание путаницы, все скриптовые переменные желательно объявлять как визуальные объекты. В прочих кодах (Act, Use и т.д.) объявлять переменные возможно только в коде, однако место их объявления не имеет никакого значение для определения переменной, поскольку компилятор запоминает все объявленные переменные в момент своего первого прохода по коду, благодаря чему конструкции вида: if(!var){int var = 1;} - не приведут к крашу.
    Примечание: Помимо стандартных переменных в дабокоде существую и скрытые типы, вроде array, function, library, class и другие. Тем не менее, использовать и объявлять такие переменные вручную из кода нельзя, для этого используются специальные скриптовые функции.
ref - указатель на необходимость получения в качестве аргумента скриптовой функции не переданного в качестве аргумента переменной, а только указателя не неё (особенно полезно при необходимости передачи указателя на массивы);
if - стандартный оператор условия;
else - стандартный оператор, исполняющий условие, если предыдущий if исполнен не был, всегда должен стоять после if и допускает конструкции вида:
  if(...)
  { ... }
  else if(...)
  { ... } и т.д.
for - стандартный цикл перебора по определённому счётчику с условием:
  1 - начальное значение числа (например, i = 0);
  2 - условие с числом (например, i <= 3);
  3 - операция с числом после каждого прохода цикла (например, i = i + 1);
  Примечание: Аргументы цикла for разделяются символом ';'.
while - стандартный цикл перебора до тех пор, пока исполняется указанное в нём условие:
  1 - условие (например, i != 0);
exit - вызывается без скобок, прерывает дальнейшее исполнение кода в текущем операторе;
continue - вызывается без скобок, прерывает дальнейшее исполнение текущего круга цикла - переводит цикл на следующий круг;
break - вызывается без скобок, прерывает дальнейшее исполнение текущего цикла, завершает его;
function - объявляет функцию, которая будет доступна только внутри конкретного скрипта, пример: function MyFun(X, Y){ ... }
  Примечание: По умолчанию все получаемые функцией аргументы имеют тип передаваемого в них значения, однако, при желании, можно указать им заранее определённый тип, чтобы при передаче они конвертировались в него автоматически. Переменные функции существуют лишь внутри самой функции, однако внешние глобальные переменные и переменные скрипта функция может использовать без каких-либо ограничений.
result - обозначает возврат внутренней скриптовой функции и записывается внутри неё, пример: result = X + Y;
throw - выбрасывает эксепшен и вызывает краш игры, выносит в лог указанный текст:
  1 - текст или число для вывода в лог (пример: throw 'No, no, no!';);
== - равно;
!= - неравно;
! - знак неравенства, обозначает проверку на возврат 'false', которое в дабокоде обозначается исключительно числом 0 (поскольку булевы переменные в нём отсутствуют). Аналогичная проверка на 'true' будет срабатывать при возврате от условия любого положительного или отрицательного числа, кроме 0.
~ - побитовое отрицание, которое можно использовать для быстрой (точнее более оптимальной) проверки неравенства значения переменной числу -1. Пример: if(~N), где N == -1 вернёт 0, а во всех остальных случаях не 0.
  Важно: С точки зрения оптимизации проверки вида if(!(~N)) как аналог if(N == -1) по быстродействию неэффективны, а их использование в данном случае неоправданно.
> - больше;
>= - больше или равно;
< - меньше;
<= - меньше или равно;
% - производит деление числа на указанное значение и возвращает только остаток (целый, без учёта возможной дробной части) от такого деления, пример: 123 % 10 = 3, 1000 % 10 = 0;
& - побитовое сравнение И;
| - побитовое сравнение ИЛИ;
&& - логическое сравнение И;
|| - логическое сравнение ИЛИ;
<< - побитовый сдвиг на определённую позицию вперёд (запись 1 << N в данном случае будет эквивалентна 2 ^ N (2 в степени N), а 4 << N эквивалентна 4 * 2 ^ N);
>> - побитовый сдвиг на определённую позицию назад (запись 1 >> N в данном случае будет эквивалентна 1 / 2 ^ N с отбрасыванием дробной части);
\\ - комментирование строки;
\ - экранирование символа " ;
\\\ - экранирование символа ' ;


Служебные:
GalaxyPtr - без аргументов, возвращает указатель на текущий объект-галактику;
Rnd - возвращает псевдослучайное целое число из диапазона (без включения ТН на полный рандом, данная функция использует общее галактическое зерно, так что каждый вызов функции будет влиять на исход всех глобальных событий в игровом мире):
  1 - нижняя граница диапазона;
  2 - верхняя граница диапазона (границы могут быть отрицательными);
  Опционально:
  3 - задать своё зерно для текущего "броска";
  Примечание: Установка собственного зерна не отменяет полную рандомизацию броска при выставлении ТН на рандом. Иными словами, в этом случае третий аргумент тупо не работает.
rnd - возвращает псевдослучайное целое число, начиная с нуля:
  1 - верхняя граница диапазона минус один (то есть rnd(5) будет возвращать результаты только от 0 до 4);
  Примечание: В отличие от Rnd(), rnd() всегда возвращает случайный результат, т.к. зерно определяется рандомно. А ещё, в отличие от Rnd(), rnd() полное говно и никому не рекомендую использовать эту кривую дельфийскую поделку!
randomize - автоматически перемешивает зерно для функции rnd;
randseed - позволяет узнать или задать текущее зерно для функции rnd:
  Без аргументов - узнать текущее зерно;
  Опционально:
  1 - задать новое зерно;
loadlibrary - загружает в память dll-библиотеку и записывает её адрес в переменную dword, которую потом можно использовать в функции libraryfunction:
  1 - путь загрузки относительно папки с игрой (строкой);
  Пример: dword lib = loadlibrary('Mods\YourMod\YourLib.dll');
freelibrary - очищает память, занятую под dll-библиотеку, и возвращает int с результатом:
  1 - dword с адресом dll-библиотеки;
libraryfunction - загружает из переменной с адресом dll-библиотеки в указанную переменную функцию, и устанавливает ей значение скрытого типа LibraryFun, поэтому присваивать функцию нужно всегда переменной с типом unknown:
  1 - dword с адресом dll, полученный через функцию loadlibrary;
  2 - тип возвращаемого загружаемой функцией значения строкой (доступны только int, dword, str и float), а если возврата нет, то без разницы;
  3 - название функции в dll, которую необходимо загрузить в переменную;
  4, 5, 6, и т.д. - типы аргументов загружаемой функции (также строкой) по порядку;
  Пример: unknown fun = libraryfunction(lib, 'dword', 'FunctionName', 'str', 'dword', 'dword');
  В результате, объявленную переменную с функцией можно будет использовать в качестве обычной функции: fun(arguments);
  Примечание: Возврат значения из данных функций возможен только для переменных типа int, dword, str (получение str в C++ должна производиться типом wchar_t* с типом самой функции const wchar_t*, подробности в примере ниже) и float (получение и передача float в C++ должна производиться типом unsigned int, подробности в примере ниже). Передавать в качестве аргументов можно переменные любых типов.
    Пример функции в C++ для получения, изменения и возврата строки скрипту:
    //Для использования типа string
    #include <string>
    //Для конвертации wstring
    #include <locale>
    #include <codecvt>

    //Для записи всех необходимых функций внутрь самой библиотеки необходимо использовать следующую настройку:
    //Configuration Properties > C/C++ > Code Generation > Runtime Library > Multi - threaded(/ MT) (для релиза)
    //Configuration Properties > C/C++ > Code Generation > Runtime Library > Multi - threaded Debug(/ MTd) (для дебага)
    //Подробнее: https://stackoverflow.com/questions/3162325/after-building-exe-using-vs-2010-c-missing-msvcp100-dll

    using namespace std;
    //Объявляем экспортируемость функции (актуально в VS 2019 для сборки dll на C++)
    extern "C" __declspec(dllexport)
    //Объявляем саму функцию и получаемый из скрипта аргумент в виде str
    const wchar_t* StringChange(wchar_t* script_str)
    {
      //Для дальнейшего успешного возврата строки в игру нам потребуется статичная переменная
      //Статичные переменные объявляются лишь раз, поэтому обязательно выносим объявлением на отдельную строку
      //Также для удобства статичную переменную можно объявить и вне конкретной функции, что актуально, если вы собираетесь писать сразу несколько разных экспортных функций с возвратом строки в игру
      static wstring wide_string;
      //Если нам необходимо преобразовать wchar_t*, полученный из игры, в string, то подойдёт следующий способ
      //Для удобства данный класс можно объявлять и вне функции в общем пространстве dll
      static wstring_convert<codecvt_utf8<wchar_t>> convert;
      //Применив его, на выходе получим простую string
      string basic_string = convert.to_bytes(script_str);
      //Производим необходимые действия с полученной строкой
      basic_string += "Some text";
      //Аналогичную операцию проводим для преобразования string в статичный wstring для последующего возврата значения в игру
      wide_string = convert.from_bytes(basic_string);
      //После чего возвращаем скрипту wstring в виде константы (также необходимое условие)
      return wide_string.c_str();
    }
    Пример функций в C++ для преобразования float ИЗ и В скриптовый формат:
    //Функция для преобразования переменной типа float из C++ в тип unsigned int, распознаваемый скриптом
    unsigned int FloatToGame(float a)
    {
      return *(unsigned int*)&a;
    }
    //Функция для преобразования переменной типа unsigned int, полученной как float из скрипта, в стандартный double, используемый в C++
    double FloatFromGame(unsigned int a)
    {
      return *(float*)&a;
    }
      Примечание: Обратите внимание, переменная float в дабоязыке на самом деле double, однако передача значений в DLL доступна лишь в 32-битном формате, поэтому фактически обмен идёт в виде реальных типов float.
ImportAll - производит автоматическое объявление и загрузку в переменные всех функций из объявленной в Main dll-библиотеки:
  1 - имя библиотеки строкой;
  Примечание: Данную функцию удобно использовать для подключения внешних функций конкретному интерфейсному, Act- или Use- коду. Все объявленные таким образом функции будут автоматически выгружены из памяти при перезагрузке или выходе из игры. Для сокращения обращений к данной функции (и сокращения лишних переобъявлений функций) при повторных срабатываниях кода допустимо использовать следующую конструкцию в начале нужного кода (объявление LibInit должно оставаться внутри условия):
  01=if(!LibInit)
  02 ^{
    01=int LibInit = 1;
    02=ImportAll('LibName');
  }
ImportedFunction - производит упрощённое объявление новой функции из dll, при условии предварительного указания библиотеки и нужной функции из неё в Main.dat:
  1 - название объявленной в Main библиотеки строкой;
  2 - название конкретной функции строкой (пример: unknown PortionInDiapason = ImportedFunction('UtilityFunctions', 'PortionInDiapason'););
  Пример объявления dll с функциями в Main.dat:
  Data {
    ScriptLibs ^{
      UtilityFunctions ^{ //Название библиотеки для подстановки в ImportedFunction
        Path=Mods\Tweaks\UtilityFunctionsPack\DATA\UtilityFunctions.dll //Путь до файла dll
        RoundTo=float,RoundTo,float,float,int //Название и объявление функций из библиотеки (аналогично libraryfunction)
        PortionInDiapason=float,PortionInDiapason,float,float,float,float,float
        IsShiftCtrlPressed=int,IsShiftCtrlPressed
        DeclareBonusArray=void,DeclareBonusArray,int
      }
      ScriptName=UtilityFunctions,LibName2,LibName3 //И т.д., объявление библиотек и полного набора их функций для конкретного скрипта ScriptName, при этом при подобном объявлении никаких дополнительных операций в самом скрипте производить не нужно, все функции из объявленных в Main библиотек будут доступны в скрипте с самого начала его инициализации
    }
  }
  Примечание: Первым в списке указателя функции идёт тип её возврата, однако если функция не подразумевает возврата вовсе (void), то вместо типа можно указать любое невалидное значение. Тот же 'void' для этого вполне подойдёт. Также в качестве аргументов (наряду с int, str и т.д.) либовых функций допустимо указывать 'ref' и 'code'. Первая передаст в либу не значение переданной переменной, а только указатель на неё, а вторая передаст в либу указатель на текущий исполняемый объект скриптового кода (для скриптов это будет иниткод, тернкод, либо диалогкод), через который можно, при желании, получить указатели на все связанные переменные скрипта и менять их напрямую из либы.
new - создаёт и записывает в переменную новый экземпляр класса:
  1 - название нового класса строкой (запоминать нужно в переменную с типом unknown, т.к. вернётся в неё тип class);
delete - удаляет экземпляр класса из переменной:
  1 - переменная с типом class;
round - применить банковское (стандартное для игры) округление к дробному:
  1 - число;
  Опционально:
  2 - к какому целому числу округлять (по умолчанию округляет к единицам):
     1 - к единицам;  
     10 - к десяткам;
     100 - к сотням;
abs - возвращает модуль числа:
  1 - число (int или float);
min - возвращает наименьшее число из представленных (float, int или str):
  1 - первое число;
  2 - второе число;
  3 - третье число и т.д.;
max - возвращает наибольшее число из представленных (float, int или str):
  1 - первое число;
  2 - второе число;
  3 - третье число и т.д.;
  Примечание: Данные функции чувствительны к типу аргументов. Преобразование аргументов происходит по первому типу в списке аргументов, однако имеются особые приоритеты в порядке: float, int, str. Так, при подстановке аргументов типа min(int, float) все сравниваемые аргументы будут сперва преобразованы к float, а при подстановке min(str, int) все аргументы будут приведены к int. Если необходимо сравнить две и более строки (по какой бы то ни было причине), то необходимо передавать в виде строк, как минимум, два первых аргумента.
int - возвращает целое, отбрасывая дробную часть (аналогично округлению в меньшую сторону, но в целом как функция почти бесполезна):
  1 - число;
frac - возвращает дробную часть, отбрасывая целое:
  1 - число;
sqr - возводит число в квадрат:
  1 - число;
sqrt - извлекает из числа квадратный корень:
  1 - число;
pi - не функция (!!!), а просто общая переменная, в которой записано число Пи (точное значение в переменной: 3.14159265516356);
sin - вычисляет синус:
  1 - число;
cos - вычисляет косинус:
  1 - число;
arctan - вычисляет и возвращает в радианах арктангенс числа:
  1 - число;
exp - вычисляет экспоненту:
  1 - число;
ln - вычисляет натуральный логарифм:
  1 - число;
count - возвращает число символов в строке:
  1 - строка;
trim - удаляет все пробелы, табуляции и переносы строк с правого и левого края строки:
  1 - строка;
substr - выделяет и возвращает указанный набор символов из строки:
  1 - строка;
  2 - номер отсчётного символа (начиная с 0), по умолчанию вернёт весь остаток строки, начиная с символа под указанным номером;
  Опционально:
  3 - сколько символов из строки вернуть, начиная с отсчётного (пример - substr('wxyz', 1, 2) вернёт 'xy', а без указания третьего аргумента вернёт весь остаток строки 'xyz');
findsubstr - ищет в строке определённую строку и при успехе возвращает номер первого символа найденной строки:
  1 - строка;
  2 - какую строку ищем (пример - findsubstr('xyz', 'y') вернёт 1) - при неудаче возвращает -1;
lowercase - превращает все буквы в строке в строчные:
  1 - строка;
uppercase - превращает все буквы в строке в заглавные:
  1 - строка;
copy - копирует одну переменную в другую с сохранением типа:
  1 - в какую переменную копировать;
  2 - из какой переменной копировать (допустимо копировать переменную "из" и "в" ячейку массива, включая переменные типа unknown);
ord - возвращает числовой код символа:
  1 - символ;
toansi - переводит кодировку строки в ANSI:
  1 - строка;
tounicode - переводит кодировку строки в UTF-16 (стандартная кодировка для игры, BlockPar по умолчанию сохраняет в ней все .dat):
  1 - строка;
Sound - воспроизводит указанный звук:
  1 - строка пути к звуку в 'CacheData.Bm', пример: Sound('Sound.QuestOk') воспроизведёт звук выполненного задания;
Format - ищет в первом аргументе (строке) сочетание символов из второго аргумента и заменяет на третий, допускается использование множества замен в одной операцией:
  1 - исходная строка;
  2 - что заменить в исходной строке;
  3 - на что это заменить;
  4, 5 аналогично 2, 3 и т.д.;
  6 - либо любой чётный аргумент (строкой) в конце списка задаёт, либо выключает тэги цвета, которые будут автоматически подставлены вокруг всех замен:
    '' - отключить подстановку цветовых тэгов;
    '255,255,255' - какой цвет задать подстановкам в формате RGB;
  Пример: Format('Траляля#0# - мне на всё плевать!', '#0#', '-ляля'); - вернёт строку: 'Траляля<color=0,50,200>-ляля</color> - мне на всё плевать!';
CT - возвращает значение указанного параметра (всегда в виде строки) из Lang.dat (имеет альтернативный запрос при наличии второго аргумента):
  1 - путь к параметру в Lang, пример: CT('Items.Engine.Type.8') вернёт слово 'Темпоральный';
  Опционально:
  2 - переменная типа unknown (будет превращена в массив) или массив (будет очищен автоматически), который будет заполнен названиями всех параметров и/или блоков обнаруженных по пути, указанному в первом аргументе (логично, что указывать путь в таком случае нужно до блока, а не до параметра), после чего функция вернёт число обнаруженных по данному пути параметров и/или блоков в виде int;
GetMainData - функция аналогичная CT, позволяет получить значение параметра (всегда в виде строки) по адресу его элемента из Main.dat (имеет альтернативный запрос при наличии второго аргумента):
  1 - путь к параметру в Main, пример: GetMainData('Data.SE.Planet.001.BG') - вернёт '312';
  Опционально:
  2 - переменная типа unknown (будет превращена в массив) или массив (будет очищен автоматически), который будет заполнен названиями всех параметров и/или блоков обнаруженных по пути, указанному в первом аргументе (логично, что указывать путь в таком случае нужно до блока, а не до параметра), после чего функция вернёт число обнаруженных по данному пути параметров и/или блоков в виде int;
  Примечание: Даже если функциям CT() и GetMainData() не удастся обнаружить ни одного параметра и/или блока по указанному в первом аргументе пути (при наличии второго аргумента, естественно), то в переданный массив всё равно будет записан один пустой элемент, просто потому, что дабокод не способен работать с массивами без элементов.
GetGameOptions - возвращает значение указанного параметра (всегда в виде строки) из общего игрового конфига CFG.TXT:
  1 - название параметра;
  Пример: 'ResolutionX' или 'ResolutionY' - вернёт разрешение экрана по X или Y (в виде int). Если запросить 'VideoMode', то вернет их же, но одной строкой через запятую (соответственно в виде str);
  Примечание: Функция берёт значения из уже загруженной в память копии конфига, поэтому изменение .txt файла при запущенной игре не даст видимого результата.
BlockExist - проверяет наличие указанного раздела в Lang (по умолчанию):
  1 - путь к разделу в Lang.dat или другом датнике (например, 'Artefacts.CustomArtefacts.EMP_bomb');
  Опционально:
  2 - в каком файле искать указанный блок:
     'Lang' - итоговый сборный игрового Lang (по умолчанию);
     'Main' - итоговый сборный игрового Main;
     'Config' - игровой CFG.TXT в корневой папке;
ResourceExist - ищет в CacheData указанный ресурс (не путь до файла, а уже объявленный ресурс) и при успехе возвращает 1:
  1 - путь к разделу в CacheData.dat, начиная с самого корня (например, 'Bm.FormShip2.YourResourceName');
CurrentMods - возвращает общее количество подключённых модов или путь к конкретному подключённому моду:
  Без аргументов - вернёт общее количество подключённых модов;
  Опционально:
  1 - номер мода в списке (начиная с 0), вернёт путь к конкретному подключённому моду;
  Примечание: Моды в списке располагаются в том же порядке, что и в логе. Возвращаемые пути имеют вид 'Evolution\EvoBalance'.
SFT - выводит в лог-файл любое значение (например, SFT(ShipName(Player())) выведет в лог имя игрока), допускается множество аргументов, незаменимая функция для отладки:
  1 - какое значение или строку вывести в игровой лог;
  Примечание: Если указать в аргументе массив без индекса - выведет в лог всё содержимое указанного массива.
CreateActCodeEvent - вручную запускает заданный акткодовый эвент определённой инфошки или предмета:
  1 - тип эвента, например t_OnStep, t_OnTakingDamage и т.д.;
  2 - предмет или корабль, из акткода которого будет исполнено событие (для корабля событие сработает сразу во всех его инфошках, в которых оно есть);
  3 - корабль, т.е. то, что будет возвращать функция ScriptItemActShip() в обработчике;
  4 - то, что будет возвращать функция ScriptItemActObject1();
  5 - то, что будет возвращать функция ScriptItemActObject2();
  6 - параметр, т.е. ScriptItemActParam() (при желании, через ScriptItemActParam в самом акткоде события можно что-нибудь вернуть, возвращаемый параметр будет являться результатом вызова CreateActCodeEvent);
GenerateCodeStringFromBlock - сжимает код из блока Lang в единую непрерывную строку, тем самым подготавливая его к исполнению скриптом:
  1 - путь к разделу с кодом (ActCode или UseCode) в Lang;
  Примечание: Готовую строку кода можно подставлять в скриптовые объекты функцией ItemOnActCode или ItemOnUseCode;
ExecuteCodeFromString - исполняет код из строки, позволяет передавать код между скриптами с помощью глобальных переменных или создать таким образом полноценную глобальную функцию:
  1 - строка с кодом;
  Опционально (для создания функции):
  2 - первый аргумент для исполняемой строки в виде строки (имя переменной-аргумента внутри создаваемой функции);
  3 - значение первого аргумента для исполняемой строки (можно подставить сюда любое значение или другую переменную);
  4 - второй аргумент для исполняемой строки в виде строки, либо (если не добавлять 5 аргумент) результат возврата вызова основной функции ExecuteCodeFromString, то есть, по сути, возврат функции из исполняемой строки (имя возвратной внутренней переменной указывать также строкой);
  Примечание: Аргументов для исполняемой строки можно задать сколько угодно, но при этом правило следующее: при нечётном числе аргументов функции ExecuteCodeFromString возврата не будет, а при чётном - последний аргумент всегда будет считаться её возвратом. Если последний возвратный аргумент объявлен как новая переменная, то его непосредственное объявление (присвоение типа int, str и т.д.) должно происходить в самой исполняемой строке. Если же для возврата указан один из ранее указанных аргументов, например: ExecuteCodeFromString('NewsAdd(X);', 'X', 1, 'X') - то дополнительно объявлять возвратную переменную не нужно.
  Наглядный пример использования: tempVar = ExecuteCodeFromString('varZ = varX + varY; int result = varZ;', 'varX', 2, 'varY', 2, 'varZ', 0, 'result'); - где tempVar в конечном итоге получит значение из временного аргумента varZ, то есть 4 (возвратная переменная result здесь так названа чисто для удобства, но на самом деле может иметь любое имя). Также в данном конкретном примере можно было обойтись и без объявления возвратной переменной, указав вместо неё напрямую 'varZ'.
  Ещё примечание: Для передачи кода между скриптами, вместо глобальных переменных можно использовать обычные переменные и функцию GetValueFromScript(). Также, вместо использования переменных, общий код можно записывать прямиком в Lang, после чего извлекать его функцией CT и получать готовую исполняемую строку, которую, при желании, будет легко изменить даже без обращения к скрипту.
GetValueFromScript - позволяет узнать значение конкретной переменной (в т.ч. вернуть скриптовый предмет, но не группу, т.к. скриптовая группа - это просто внутренний скриптовый номер) или элемента массива из конкретного скрипта (в случае отсутствия скрипта вернёт unknown). Работает в том числе и из акткода:
  1 - имя скрипта строкой (путь указывать не нужно);
  2 - имя переменной или массива строкой (не указывать глобалки, иначе крашнет, однако можно указывать общие игровые переменные типа t_Weapon1);
  Опционально:
  3 - индекс массива, если проверяется массив (номер ячейки числом или присвоенное ей имя строкой);
  4, 5, 6 и далее - дополнительные индексы для многомерных массивов;
  Примечание: При запросе общих игровых переменных вроде t_Weapon1 (иногда бывает полезно) скрипт указывать не обязательно. Вместо него можно оставить пустую строку ''. Если же вы запрашиваете переменную из конкретного скрипта, то этот скрипт должен быть обязательно активен (в момент срабатывания своего иниткода скрипт уже считается активным). Если указанный в первом аргументе скрипт отсутствует или неактивен - вернёт ''.
GetVariableName - возвращает имя любой переменной или имя ячейки указанного массива (собственно, для массивов и используется):
  1 - переменная, массив или стандартный указатель на элемент массива (пример: arr[0, 'Name', 1]);
GetVariableType - возвращает тип любой переменной в виде числа (для конкретной ячейки массива вернёт её тип, а не тип Array):
  1 - переменная, массив или стандартный указатель на элемент массива:
     0 - (Unknown) - переменная типа unknown;
     1 - (Int) - переменная типа int;
     2 - (DW) - переменная типа dword;
     3 - (Float) - переменная типа float;
     4 - (Str) - переменная типа str;
     5 - (ExternFun) - переменная для всех внешних функций из ScriptFun (включая саму GetVariableType());
     6 - (LibraryFun) - переменная для внешних функций из подключаемых сторонних dll;
     7 - (Fun) - внутренняя скриптовая функция;
     8 - (Class) - переменная класса, которая в скриптах есть (и её можно там самому объявлять), но почти никогда не используется;
     9 - (Array) - основной тип объекта массива, включая подмассивы из которых состоит многомерный массив;
     10 - (Ref) - внутренний тип, вероятно, для переменной result;
StartVideo - добавляет видеоролик в список на воспроизведение, либо возвращает число роликов в очереди:
  Без аргументов - возвращает количество скриптов, которые показывали видео (или количество скриптов, ожидающих показа видео);
  Опционально:
  1 - путь к видеофайлу;
  2 - название (путь) звуковой дорожки в разделе 'Bm.Sound' (пример: StartVideo('data\record.vdo', 'Record'));
GVideoStatus - общая глобальная переменная, используемая для показа видеороликов скриптом, возможные значения:
  0 - ролик не воспроизводится;
  1 - ролик был заказан данным скриптом;
  2 - ролик завершился;


Для работы с интерфейсом:
CurrentForm - возвращает текущую открытую форму строкой (все игровые формы прописаны в Main.dat, в разделе ML):
  Оригинальные формы:
  'StarMap' - форма общего экрана космоса;
  'Film' - форма просмотра повтора хода(ов) в космосе;
  'AB' - форма аркадных боёв и перелёта между системами, при включении соответствующей ТН;
  'Talk' - дочерняя форма диалога с кораблём/станцией в космосе;
  'Planet' - форма основного экрана обитаемых планет;
  'PlanetNO' - форма экрана необитаемых планет (вызываемое меню для размещения зондов также находится здесь);
  'PlanetQuest' - форма прохождения текстового квеста;
  'Gov' - форма планетарного правительства;
  'RuinsTalk' - правительство и общий экран станции (а также все мостики);
  'GoodsShop' - дочерняя форма магазина товаров;
  'EquipmentShop' - дочерняя форма магазина оборудования;
  'Info' - дочерняя форма инфоцентра;
  'Hangar' - дочерняя форма ангара;
  'Ship' - дочерняя форма, изменяемое игроком меню корабля (его собственный корабль, его транклюкатор, станция с проплаченным взносом на изменение);
  'Scaner' - дочерняя форма, не изменяемое игроком меню корабля (при сканировании других NPC);
  'Rewards' - дочерняя форма меню просмотра правительственных наград/медалей, открываемое через форму 'Ship';
  'Rating' - дочерняя форма рейтинга рейнджеров;
  'Galaxy' - дочерняя форма галакарты;
  'Journal' - дочерняя форма бортового журнала игрока;
  'SelectFace' - дочерняя форма выбора расы, лица и имени, вызываемая из 'RuinsTalk' при смене подданства на ПБ;
  'Quest' - неиспользуемая в игре (и, видимо, недоделанная) дочерняя форма со списком всех текущих заданий игрока;
  'Count' - дочерняя форма вызова интерфейсного элемента CountBox;
  'Number' - дочерняя форма вызова интерфейсного элемента NumberBox;
   Примечание: Элементы MessageBox, TextBox и ListBox конструируются кодом в момент вызова, а потому отдельных форм не имеют.
  'GameMenu' - дочерняя форма игрового меню, вызываемого по Esc;
  'MainForm' - главное (первое) меню игры;
  'SaveManager' - форма экрана сохранения/загрузки игры;
  'CfgSettings' - форма основных игровых настроек;
  'Achievements' - дочерняя форма просмотра игровых достижений;
  'LoadRobot' - дочерняя форма выбора планетарных боёв в главном меню;
  'LoadQuest' - дочерняя форма выбора текстовых квестов в главном меню;
  'LoadAB' - дочерняя форма выбора аркадных боёв в главном меню;
  'ModsManager' - дочерняя форма выбора подключённых модов в главном меню;
  'Score' - форма экрана результатов игры (очки и таблица рекордов);
  'GameSettings' - форма экрана настроек перед началом новой игры;
  'Introduction' - форма экрана загрузки новой игры с введением: "Добровольцы! Вы сделали правильный выбор...";
  'GameEnd' - форма экрана конца игры (когда игрок победил или проиграл/погиб);
  'GameLoad' - форма экрана загрузки игры из главного меню;
  'Jump' - форма экрана загрузки во время прыжков между системами (но не в ЧД);
  'Load' - форма экрана загрузки во всех остальных случаях;
  'About' - форма экрана игровых титров;
  'Style' - вспомогательная служебная форма, содержащая в себе различные элементы (вроде скролл-бара), из которой все прочие формы могут выдёргивать необходимые им куски (но это не точно);
  Кастомные формы:
  'AutoSearch' - форма оформления запроса автопоиска из мода ExpAutoSearch;
FormChange - выполнить переход на другую форму:
  1 - имя формы строкой;
  Опционально:
  2 - конкретный корабль/станция, если вызывается открытие формы 'Ship' (будет открыта форма 'Ship' для указанного корабля);
RunChildForm - выполнить переход на другую форму, которая будет считаться дочерней по отношению к текущей, и при закрытии вернётся на неё же. Используется для переходов на формы, которые изначально не имеют возможности открываться друг за другом (например, с 'Ship' на 'Galaxy'):
  1 - форма строкой;
  Опционально:
  2 - режим, в котором откроется форма Galaxy:
    0 - fgm_Teleport (телепортирует корабль в указанную систему после закрытия формы, есть базовая анимация);
    1 - fgm_Show (режим простого просмотра без возможности совершить прыжок);
    2 - fgm_Move (будет отдавать приказ на обычный прыжок между системами);
    3 - fgm_BlackHole (будет открывать ЧД, как на ТИ);
  По умолчанию дочерняя форма 'Galaxy' откроется в режиме fgm_Teleport;
UpdateFormShip - без аргумента, обновляет форму 'Ship'. Используется для быстрого обновления формы корабля после различных действий (например, после выброса предмета в космос);
FormCurShip - без аргументов, возвращает корабль, для которого в данный момент открыта форма 'Ship' или 'Scaner' (помогает определить, что форма 'Ship' открыта для станции или транклюкатора, а не для корабля игрока);
UICheckElement - проверяет текущее состояние элемента (Panel, GraphButton, Image и т.д.):
  1 - название формы строкой (или '', если проверяется элемент на открытой кастомной форме);
  2 - имя элемента;
  3 - тип проверки;
    Возможные типы:
      'IsActive' - возвращает состояние элемента, скрыт/виден;
      'IsDisable' (только для кнопок) - вернёт 1, если кнопка видна, но заблокирована (аналогично кнопке связи, когда у корабля отсутствует радар);
    'IsDown' - проверка состояния кнопки, нажата ли она в текущий момент (полезно для проверки состояний кнопок-чекбоксов);
    'PosX' - текущая позиция элемента по оси X (учитывает скорректированное значение, если автокоррекция имела место быть);
    'PosY' - текущая позиция элемента по оси Y (учитывает скорректированное значение, если автокоррекция имела место быть);
      'Text' (только для Label и Edit) - позволяет вернуть текущий текст элемента или задать текст для Edit четвёртым аргументом;
      'Image' (только для Image, GI или GAI) - позволяет вернуть путь к изображению или выставить этот путь четвёртым аргументом;
      'CurFrame' (только для GAI) - возвращает текущий активный кадр анимации (нумерация начинается с 0);
  Опционально:
  4 - задаёт текст или путь к изображению для элемента, если 3-м аргументом выбран 'Text' или 'Image', либо меняет состояние нажатости кнопки, если выбран 'IsDown' (привязанный к кнопке обработчик при таком переключении исполнен не будет);
  Примечание: В отличие от функций описанных ниже, способных работать только с установленными оверрайдами элемента, UICheckElement может возвращать информацию для любых игровых элементов вне зависимости от наличия на них скриптового оверрайда.
InterfaceState - добавляет элементу (Panel, GraphButton, Image и т.д.) скриптовый оверрайд состояний или возвращает состояние уже имеющегося оверрайда:
  1 - название формы строкой;
  2 - имя элемента строкой;
  Опционально:
  3 - установить оверрайд:
    -1 - убрать оверрайд;
     0 - скрыть элемент;
     1 - показать элемент;
     2 - заблокировать кнопку (Disable);
     3 - разблокировать кнопку (Enable);
     Примечание: Блокирование и разблокирование элемента не меняет состояние основного оверрайда. Для визуального отображения блокировки элемента, у него в параметрах должен быть прописан путь к соответствующему изображению.
InterfaceText - возвращает/устанавливает текст элемента (вешает оверрайд), если ранее текст в элементе не изменяли данной функцией, то вернёт пустую строку:
  1 - название формы строкой;
  2 - имя элемента (только для типов Label и Edit);
  Опционально:
  3 - новый текст;
InterfaceImage - возвращает/устанавливает картинку элемента (вешает оверрайд), если ранее изображение в элементе не изменяли данной функцией, то вернёт пустую строку:
  1 - название формы строкой;
  2 - имя элемента (только для классов GI, GAI или Image, либо любого элемента в случае замены параметра);
  Опционально:
  3 - путь к новому изображению, либо указатель на замену конкретного параметра выбранного элемента, подробности ниже;
  Примечание: Данная функция может заменять значения любых параметров в любом элементе, для чего третьим аргументом необходимо указать 'Style:Полный путь к разделу с изменяемым параметром', который должен быть расположен где-то в общем разделе 'ML' (в пути 'ML' указывать не требуется). Путь к параметру должен указывать на раздел, содержащий только необходимый параметр и его новое значение, пример:
  ChangeParam ^{
    Param=NewValue
  }
  С помощью данного метода можно менять любые "статичные" параметры, вроде Help или StyleBarY.
InterfacePos - устанавливает (вешает оверрайд) новые координаты указанного элемента:
  1 - название формы строкой;
  2 - имя элемента;
  3 - смещение по оси Х;
  4 - смещение по оси Y (под смещением подразумевается смещение относительно текущего местоположения элемента);
  5 - позиция элемента по оси Z (здесь всегда точная позиция, а не смещение);
  Примечание: Слои в КР работают довольно дебильно, и верхним будет считаться слой с наименьшим значением. То есть, например, слой 1 будет расположен выше слоя 2 и т.д. Также для слоя возможно выставление отрицательных и дробных значений по тому же правилу, чем меньше - тем выше. Также обратите внимание, что если вы вызываете оверрайд позиции элемента на форме, на которой Галактики ещё не существует (например, на 'GameSettings'), то указанные параметры X, Y и Z будут задавать не смещение относительно текущих параметров, а фактическую позицию элемента относительно родительского элемента, как если бы вы изменяли его позицию напрямую через Main.
InterfaceSize - устанавливает (вешает оверрайд) параметр Size элемента:
  1 - название формы строкой;
  2 - имя элемента;
  3 - размер по оси Х;
  4 - размер по оси Y;
ButtonClick - запускает кодовый обработчик клика указанной кнопки (не изменяет состояние нажатости кнопки, для этого нужно воспользоваться функцией UICheckElement):
  1 - название формы строкой (или '', если проверяется элемент на открытой кастомной форме);
  2 - имя кнопки;
SetFocus - задаёт фокус указанному элементу (в частности элементу типа Edit):
  1 - название формы строкой (или '', если проверяется элемент на открытой кастомной форме);
  2 - имя элемента;
StarMapCenterView - центрирует камеру на определённой точке космоса (без звука):
  1 - координата Х;
  2 - координата Y;
  Опционально:
  3 - число циклов анимации сходящейся на целевой точке окружности, по умолчанию воспроизводится три раза (можно указать дофига, но проигрываться оно будет очень долго);
StarMapCurPosX - без аргументов, возвращает текущую координату X позиции камеры на форме 'StarMap' (в космосе);
StarMapCurPosY - без аргументов, возвращает текущую координату Y позиции камеры на форме 'StarMap' (в космосе);

Для работы с кастомными формами:
OpenCustomForm - открывает кастомную форму: путь к кастомной форме, начиная из папки "Main.ML" (если кастомная форма прописана сразу в разделе 'ML', то просто указать её имя);
CloseCustomForm - закрывает открытую кастомную форму:
   - Без аргументов, либо 1 - закрыть текущую открытую кастомную форму;
   - 0 или любой другой аргумент - отмена выхода с кастомной формы (отменить закрытие из блока CodeAfterRun невозможно, так что хз зачем оно нужно вообще);
   - 255 - закрыть родительскую форму (не знаю нафига нужно);
CustomInterfaceState - добавляет элементу на текущей открытой кастомной форме (Panel, GraphButton, Image и т.д.) скриптовый оверрайд состояний или возвращает состояние имеющегося оверрайда:
  1 - имя элемента строкой;
  Опционально:
  2 - установить оверрайд:
    -1 - убрать оверрайд;
     0 - скрыть элемент;
     1 - показать элемент;
     2 - заблокировать кнопку (Disable);
     3 - разблокировать кнопку (Enable);
CustomInterfaceText - возвращает текст элемента на текущей открытой кастомной форме, если текст не изменяли модом, то вернёт пустую строку:
  1 - имя элемента (только для типов Label и Edit);
  Опционально:
  2 - новый текст;
CustomInterfaceImage - возвращает/устанавливает картинку элемента на текущей открытой кастомной форме, если изображение не изменялось модом, то вернёт пустую строку:
  1 - имя элемента (только для классов GI, GAI или Image, либо любого элемента в случае замены параметра);
  Опционально:
  2 - путь к новому изображению, либо указатель на замену конкретного параметра выбранного элемента, подробности ниже;
  Примечание: Данная функция может заменять значения любых параметров в любом элементе, для чего третьим аргументом необходимо указать 'Style:Полный путь к разделу с изменяемым параметром'. Путь к параметру должен указывать на раздел, содержащий только необходимый параметр и его новое значение, пример:
  ChangeParam ^{
    Param=NewValue
  }
  С помощью данного метода можно менять любые "статичные" параметры, вроде Help или StyleBarY.
CustomInterfacePos - возвращает/устанавливает новые координаты элемента на текущей открытой кастомной форме:
  1 - имя элемента;
  2 - смещение по оси Х;
  3 - смещение по оси Y;
CustomInterfacePosZ - возвращает/устанавливает позицию элемента на текущей открытой кастомной форме по оси Z (слой);
  1 - имя элемента;
  2 - позиция элемента по оси Z;
  Примечание: Слои в КР работают довольно дебильно, и верхним будет считаться слой с наименьшим значением. То есть, например, слой 1 будет расположен выше слоя 2 и т.д. Также для слоя возможно выставление отрицательных и дробных значений по тому же правилу, чем меньше - тем выше. Также обратите внимание, что если вы вызываете оверрайд позиции элемента на форме, на которой Галактики ещё не существует (например, на 'GameSettings'), то указанные параметры X, Y и Z будут задавать не смещение относительно текущих параметров, а фактическую позицию элемента относительно родительского элемента, как если бы вы изменяли его позицию напрямую через Main.
CustomInterfaceSize - устанавливает параметр Size элемента на текущей открытой кастомной форме:
  1 - имя элемента;
  2 - размер по оси Х;
  3 - размер по оси Y;
  Примечание: Проще всего запускать все необходимые функции для изменения размеров и позиций элементов кастомной формы в прикреплённом к ней блоке интерфейсного кода (просто размещаете его внутри кастомной формы) 'CodeBeforeRun'. Аналогично, перед уходом с кастомной формы внутри неё срабатывает обработчик 'CodeAfterRun'.


Для работы с массивами:
newarray - превращает в массив переменную типа unknown (также можно использовать сразу после функции free):
  1 - начальное число элементов в новом массиве (пример: unknown array = newarray(7)), 2, 3 и далее (опционально) - сколько подэлементов будет в каждом из предыдущих элементов массива (для объявления многомерного массива);
  Примечание: Раньше данная функция часто использовалась в иниткоде скриптов, т.к. невозможно было объявить массив как-то иначе, но в последних версиях RScript эта необходимость отпала, т.к. появилась возможность объявлять массив напрямую в объекте переменной. При необходимости, этой функцией можно переобъявлять уже объявленные массивы через тернкод (массивы будут очищены автоматически).
  Примечание: При добавлении значения в ячейку с неинициализированным типом, тип ячейки будет автоматически приравнен к типу значения, однако все последующие изменения значения данной ячейки уже будут по умолчанию получать инициализированный в ней тип. Для изменения инициализированного типа значения в ячейке массива можно использовать функцию copy.
  Расширение многомерных массивов: Данная функция также используется при необходимости расширить многомерный массив. Сперва необходимо расширить массив обычной функцией ArrayAdd(arr, dummy), где dummy - переменная типа unknown. После этого новый пустой элемент массива можно разбить на нужное число подэлементов вызвав данную функцию: arr[N] = newarray(2, 3, 4 и т.д. сколько подэлементов вам необходимо объявить в новом элементе).
free - очищает массив (в отличие от ArrayClear, затирает массив полностью, удаляя даже нулевой элемент):
  1 - массив;
  Важно: В тип unknown данная функция массив не превращает, поэтому если обратиться к нему после чистки чем-либо кроме функций newarray или arraychange, то получится краш (в дабокоде массивы без элементов использоваться не могут). Также после чистки можно просто превратить пустой массив в unknown, посредством функции copy (нужно просто скопировать в него переменную с типом unknown). Попытка сохранить игру пока в памяти содержится пустой массив, приведёт к ошибке.
arraychange - меняет размер массива (также можно использовать сразу после функции free):
  1 - массив;
  2 - какой размер установить;
  Примечание: В том числе работает для многомерных массивов, но возможны ошибки в связи с дабокодом (!!!).
ArrayAdd - добавляет новый (следующий по нумерации) элемент в массив и возвращает размер массива после добавления элемента (нельзя использовать после функции free до восстановления нулевого элемента):
  1 - массив;
  2 - добавляемое значение;
  Опционально:
  3 - название нового элемента массива строкой (в дальнейшем такой элемент можно будет вызывать по его имени, пример: Array['ElName']);
  Примечание: Допустимо добавлять в конец в том числе элементы верхнего порядка из многомерных массивов, пример: ArrayAdd(array, array[1]) - где array[1] на самом деле содержит в себе подмассивы array[1, 2, 3].
ArrayDelete - удаляет элемент из массива со сдвигом остального содержимого:
  1 - массив;
  2 - номер или название элемента для удаления (для многомерных массивов удалит данный элемент и все его подэлементы);
  Примечание: В том числе этой функцией допустимо удалять элементы в многомерных массивах. В этом случае для удаления элемента не из первого порядка необходимо строить запрос вот так: ArrayDelete(array[first, second], third). Однако, при удалении многомерного элемента, его подмассивы сами не очищаются, что может привести к утечке памяти. Если необходимо полностью удалить "ветку" из многомерного массива, то перед вызовом ArrayDelete необходимо вызвать функцию вида free(array[first]), либо free(array[first, second]) и т.д.
ArrayClear - очищает массив от данных, удаляя все элементы, кроме нулевого (которому присваивается тип unknown):
  1 - массив;
ArrayDim - возвращает размер массива:
  1 - массив;
ArrayFind - ищет в массиве номер элемента по указанному содержимому:
  1 - массив;
  2 - содержимое элемента, который необходимо найти (будет искать по 4-м основынм типам, dword, int, str и float);
  Примечание: Поиск по типам не ограничивается проверкой только конкретных типов переменных в массиве. То есть если, например, передать для поиска число int 737, то значение 'Boeing737' также будет переведено в int и посчитано искомым (аналогично с типами int, dword и float).
ArrayFindInSorted - ищет в массиве номер элемента по указанному содержимому, предполагая, что указанный массив уже был отсортирован (работает быстрее чем ArrayFind, что может быть полезно для больших массивов):
  1 - массив;
  2 - содержимое элемента, который необходимо найти (перед поиском будет в любом случае переведено в тип int);
  Примечание: Сортировка массивов (и вообще любых списков) в дабоязыке производится путём перестановки нумерации, аля: 1,10,11,12,2,3,4,5,6,7,8,9 и т.д. То есть и перебирать полученный массив функция будет по иному алгоритму. Если, при этом, она наткнётся на искомое содержимое в элементе под номером 2, то вернёт она назад номер 10, хотя в случае с неотсортированным массивом там будет фактически находиться номер 2.
  Важно: Обе функции ArrayFind() и ArrayFindInSorted() бесполезны при работе с многомерными массивами, т.к. содержимое всех подмассивов они даже не проверяют.
ArraySort - сортирует массив, либо несколько массивов (сортировка идёт по значениям первого);
ArraySortPartial - частично сортирует массив или несколько массивов (не слишком актуально, но если есть ну очень большой массив, то его сортировку можно делать по частям, чтобы не провоцировать задержку хода, для чего сперва вызывается с первым аргументом 1, потом 2, и так далее до N, где N - количество элементов в массиве, начиная с нулевого);
ArrayRandomize - хаотично, но согласованно перетасовывает содержание архива или нескольких массивов:
  1 - сколько раз перетасовать;
  2 - первый массив;
  3 - второй массив ... N-ый массив;


OnUseCode и OnActCode:
ScriptActionsRun - форсирует обработку запрошенных скриптовых действий, которые выполняются в другом потоке. Квесты, ПБ, взлеты и т.д. Все, что заказывается функциями, содержащими GScriptThread.MakeRun(); Предназначено для использования из OnUseCode (в остальных случаях обработка запустится и так);
ShowEffect - используется в OnUseCode и OnActCode, воспроизводит эффект:
  1 - строка пути к эффекту выстрела конкретного орудия в Main.dat\SE (чтобы эффекта выстрела не было (если, например, нужно отрисовать только цифры урона), нужно выставить 'Weapon.NoGraph');
     Примечание: Выстрел а'Эгиса лежит по пути 'Weapon.PDTurret'.
  2 - номер палитры эффекта для оружия, ShotVisual в Lang (при использовании вместе с 'Weapon.NoGraph' - выставляйте на 0);
  3 - объект-цель для воспроизведения анимации (корабль, база и т.д.);
  Опционально:
  4 - диллер эффекта (кто якобы наносит выстрел по цели, может быть 0);
  5 - сколько урона нанести (выводимые цифры), реальный урон цели не наносится, это нужно делать функцией DealDamageToShip() или прописывать через HullHP();
  6 - показать или нет анимацию взрыва. Если значение больше 0, то будет показан взрыв с плавным исчезанием "взорванного" корабля, цифры от 1 до 7 определяют, какая именно анимация взрыва будет показана;
  7 - воспроизвести или нет (0/1) звук выстрела (актуально для эффектов в Main.dat\SE\Weapon\***);
  8, 9, 10 - RGB цвета для показа урона (если выставить на 0,0,0, то цифры урона показаны не будут, а по умолчанию цвет цифры урона будет равен цвету расы корабля-цели);

ShowStaticEffect - проиграть gai-эффект:
  1 - строка в Main.dat ('SE.Effect');
  2 - координата X;
  3 - координата Y (ВАЖНО! Не воспроизводить эффект в отсутствие в системе игрока, т.к. это может привести к крашу с ошибкой деления на ноль!);
FilmSound - используется в OnUse и OnActcode, воспроизводит звук, позволяя указать его источник:
  1 - строка пути к звуку (например 'Sound.Drop');
  2 - источник звука (объект) - также желательно проверять, находится ли игрок в момент воспроизведения на планете/станции/в системе, чтобы звук не проигрывался игроку в неподобающих местах;
CurItem - используется в OnUseCode и OnActCode, возвращает текущий предмет (предмет, для которого сработал данный код);
CurInfo - возвращает прямой указатель на текущую инфошку (только для акткода в инфошках);
ScriptItemActShip - используется в OnActCode, возвращает текущий корабль (корабль, на котором сработал данный акткод);
ScriptItemActObject1 - используется в OnActCode, возвращает первый объект действия (подробности ниже);
ScriptItemActObject2 - используется в OnActCode, возвращает второй объект действия (подробности ниже);
ScriptItemActParam - используется в OnActCode, возвращает и/или изменяет текущий параметр акткодового события (подробности ниже);
ScriptItemActionType - используется в OnActCode, возвращает тип текущего сработавшего акткодового события;
(!!!) В целях оптимизации старые виды записи проверок: if(ScriptItemActionType() == t_OnStep && ScriptItemActParam() == 0)
необходимо заменять на более быстрые и новые вида: if(ScriptItemActionType(t_OnStep, 0)) (!!!)
Для выставления фильтров акткоду, накладываемому из блока на скриптовые объекты, необходимо использовать особую запись вида:
  00=[t_OnItemEquip,t_OnItemDeEquip,t_OnItemDestroy,t_OnStep|0,9]
Где '00=' - обязательное название параметра (должен быть расположен выше всех строчек кода, но внутри блока этого кода), а через '|' записываются фильтры этапов для OnStep. Наличие разделителя '|' обязательно даже тогда, когда фильтры и/или само событие OnStep в коде не используется.
  Список всех возможных событий ScriptItemActionType:
  t_OnStep - выполняется 12 раз за ход, опрашивая все акткодовые предметы и инфошки в Галактике, начинает с 0 и заканчивает 11 шагом:
    ScriptItemActShip() - если акткод исполняется для корабля или предмета, лежащего на корабле, то возвращает соответствующий корабль;
    ScriptItemActObject1() - система, где лежит предмет (только если предмет с исполняемым акткодом находится в открытом космосе);
    ScriptItemActParam() - текущий шаг (число от 0 до 11);
  t_OnWeaponShot - выполняется для стреляющего корабля и орудия в момент выстрела из неракетного оружия:
    ScriptItemActShip() - стреляющий корабль;
    ScriptItemActObject1() - цель выстрела;
    ScriptItemActObject2() - оружие, из которого стреляют;
    ScriptItemActParam() - если выстрел был сделан по кораблю/станции, то возвращает (без аргумента) или меняет наносимый цели урон (до применения к нему защиты цели);
    ScriptItemActParam() - если выстрел был сделан по ракете, то возвращает/устанавливает маркер (0 - попал, 1 - промазал);
    ScriptItemActParam() - если выстрел был сделан по предмету, то возвращает или устанавливает дополнительный урон от сплеша (как если бы стреляли по цистерне с топливом);
  t_OnWeaponShot2  - выполняется для стреляющего корабля непосредственно перед нанесением урона цели из неракетного оружия (перед t_OnDealingDamage):
    ScriptItemActShip() - стреляющий корабль;
    ScriptItemActObject1() - цель выстрела;
    ScriptItemActObject2() - оружие, из которого был произведён выстрел;
    ScriptItemActParam() - возвращает (без аргумента) или меняет дамагсет наносимого урона;
  t_OnMissileShot - выполняется для стреляющего корабля в момент выстрела из ракетного оружия:
    ScriptItemActShip() - выпускающий ракету корабль;
    ScriptItemActObject1() - ракета (цель выстрела можно получить через MissileTarget());
    ScriptItemActObject2() - оружие, из которого она была выпущена;
      Примечание: В момент срабатывания данного события ракета уже считается потраченной из боекомплекта, так что, восполняя его в этот же момент, можно получить бесконечное ракетное оружие.
  t_OnMissileShot2 - выполняется для стрелявшего корабля непосредственно перед нанесением урона цели (кораблю/станции) ракетой (перед t_OnDealingDamage):
    ScriptItemActShip() - выпустивший ракету корабль (если к этому моменту уже был уничтожен, то вернёт 0);
    ScriptItemActObject1() - цель ракеты;
    ScriptItemActObject2() - ракета;
    ScriptItemActParam() - возвращает (без аргумента) или меняет дамагсет наносимого урона;
  t_OnMissileHittingObject - выполняется, когда ракета попадает в предмет/астероид (срабатывает для хозяина ракеты):
    ScriptItemActShip() - выпустивший ракету корабль;
    ScriptItemActObject1() - объект-цель;
    ScriptItemActObject2() - ракета;
    ScriptItemActParam() - ракета промахнулась (0) или попала (1) по предмету (так можно сейвить предметы);
    Примечание: Пять вышеперечисленных событий срабатывают также и для всех предметов на борту корабля (у которых есть акткод), однако для экипированных пушек они сработают только в том случае, если выстрел производился именно из данной конкретной пушки (другие экипированные пушки на "чужой" выстрел не среагируют).
  t_OnGettingWeaponHit - выполняется, когда по кораблю наносят урон оружием:
  t_OnGettingMissileHit - выполняется, когда по кораблю наносят урон ракетой:
    ScriptItemActShip() - атакуемый корабль;
    ScriptItemActObject1() - атакующий корабль/хозяин ракеты;
    ScriptItemActObject2() - оружие/ракета;
    ScriptItemActParam() - возвращает (без аргумента) или меняет дамагсет получаемого урона;
      Примечание: Если атакующий корабль пользуется оружием со сплешом (или AOE типа Вертикса), то событие t_OnGettingWeaponHit сработает на всех кораблях, попавших в зону поражения, в том числе на дружественных и не получивших урон.
  t_OnDealingDamage - выполняется для стрелявшего корабля при нанесении урона другому кораблю или станции до непосредственного применения урона к цели (но при этом вся защита цели на данном этапе уже пройдена, то есть событие отображает чистый урон, который будет применён к корпусу цели):
    ScriptItemActShip() - корабль/станция, наносящая урон;
    ScriptItemActObject1() - цель;
    ScriptItemActParam() - возвращает (без аргумента) или меняет наносимый цели урон;
  t_OnDealingFatalDamage - выполняется для стрелявшего корабля при нанесении смертельного урона другому кораблю или станции до непосредственного применения урона к цели, спасти цель от уничтожения на данном этапе уже нельзя:
    ScriptItemActShip() - корабль/станция, наносящая урон;
    ScriptItemActObject1() - цель;
    Примечание: Можно использовать, например, для добавления в дроп цели каких-то особых вещей, которые требуют уничтожения цели от "руки" конкретного корабля.
  t_OnTakingDamage - выполняется для корабля при получении любого урона неопределённого типа: от звезды, астероида, бомбы и т.д. (урон от орудий не учитывается):
  t_OnTakingDamageEn - выполняется для корабля при получении энергетического урона:
  t_OnTakingDamageSp - выполняется для корабля при получении осколочного урона:
  t_OnTakingDamageMi - выполняется для корабля при получении ракетного урона:
    ScriptItemActShip() - корабль/станция, получающая урон;
    ScriptItemActObject1() - источник урона (корабль/станция, ракета/торпеда, астероид, звезда, предмет или 0);
    ScriptItemActParam() - возвращает (без аргумента) или меняет полученный урон;
      Примечание: Все указанные события срабатывают уже после вычитания из цифры урона всей имеющейся защиты корабля. При проверке на получение ракетного урона именно от ракеты (!), нужно дополнительно проверять ScriptItemActObject1() функцией MissileOwner(), чтобы вернуть атакующий корабль, который, однако, к тому моменту, может быть уже мёртв.
  t_OnScan - выполняется при сканировании корабля (срабатывает для игрока и сканируемого корабля, т.к. сами боты сканировать не умеют):
    ScriptItemActShip() - корабль игрока;
    ScriptItemActObject1() - сканируемый корабль;
  t_OnDroidRepair - выполняется для корабля при починке его дроидом:
    ScriptItemActParam() - возвращает/устанавливает количество отремонтированных HP;
  t_OnAnotherItem - выполняется, когда предметом с акткодом кликают по какому-то другому предмету:
  t_OnAnotherItem2 - выполняется, когда по предмету с акткодом кликают каким-то другим предметом:
    CurItem() - предмет с акткодом, для которого выполняется событие;
    ScriptItemActObject1() - другой предмет;
    ScriptItemActParam() - результат клика, аргументы (по умолчанию обработает как 0):
      0 - предмет останется в руке (t_OnAnotherItem) / будет перемещён в трюм (t_OnAnotherItem2);
      1 - предмет будет потрачен (удалён);
      2 - предмет останется висеть в руке, даже если кликнули по другому предмету в трюме;
      3 - предмет будет потрачен (удалён), а форма 'Ship' автоматически закроется;
  t_OnAnotherGoods - аналогичное t_OnAnotherItem2 событие с той лишь разницей, что срабатывает оно исключительно для товаров (продукты, минералы и т.д.), поскольку товары в трюме не являются предметами и требуют особого подхода в определении их "подбора в руку" (соответственно, t_OnAnotherItem и t_OnAnotherItem2 для товаров срабатывать не будут):
    CurItem() - предмет с акткодом, для которого выполняется событие;
    ScriptItemActObject1() - тип товара в руке;
    ScriptItemActObject2() - количество товара в руке;
    ScriptItemActParam() - результат клика, аргументы:
      0 - не делать ничего (по умолчанию);
    > 0 - удалить (потратить) указанное количество товара из руки игрока (потратить больше того что висит в руке невозможно);
    < 0 - удалить (потратить) указанное количество товара из руки игрока (минус отбрасывается автоматически) и закрыть форму 'Ship';
  t_OnItemHit - выполняется когда по предмету чем-то попали (срабатывает только для предмета):
    CurItem() - предмет, по которому был сделан выстрел;
    ScriptItemActShip() - стреляющий по предмету корабль (если в предмет попала ракета, то корабль к этому времени может быть уже уничтожен и тогда вернётся 0);
    ScriptItemActObject1() - стреляющее оружие или ракета;
    ScriptItemActObject2() - система, в которой находится предмет;
    ScriptItemActParam() - значение урона при взрыве, если данный предмет взрывоопасен (детонирует как топливный бак или цистерна);
    Примечание: Если в момент срабатывания данного события выставить орудию, из которого производится выстрел, цель 0, то выстрел по предмету произведён не будет. При этом, однако, занулить маркер ItemDestroy() (будет выставлен кодом в +1 ещё до применения отменённого выстрела) для предмета всё равно придётся вручную. Аналогичная ситуация и со случайным попаданием в предмет ракет, только там необходимо выставить ItemDestroy() в -1, если ранее вы не выставили отрицательное значение предмету "про запас". При этом, если целью ракеты являлся сам предмет, то выставление -1 уничтожит такую ракету всё равно (хотя предмет и останется цел). Если же вам нужно создать эффект полной неуязвимости предмета к попаданию любых ракет (напомню, что сами боты никогда ракетами по предметам не стреляют), то необходимо при попадании ракеты выставлять И маркер ItemDestroy() в -1 И занулять цель самой ракеты. С помощью данной инструкции можно полностью экранировать от уничтожения любой предмет, даже без занесения его в скрипт.
  t_OnEnteringForm - выполняется при открытии формы, срабатывает для игрока и всех прочих кораблей, чья форма может быть открыта:
  t_OnLeavingForm - выполняется при закрытии формы, срабатывает для игрока и всех прочих кораблей, чья форма может быть открыта:
    CurrentForm() - возвращает текущую открытую форму (не акткодовый параметр, но очень удобно использовать вместе с событиями входа/выхода для определения нужной формы);
      Примечание: Данные события при открытии формы 'Ship' срабатывают исключительно для игрока и не могут сработать для, например, транклюкатора игрока (или улучшаемой игроком станции), хотя фактически для него при просмотре эквипа также открывается форма 'Ship'.
  t_OnReEnteringForm - выполняется при автоматическом перезаходе на форму Ship (автообновление формы Ship после любого изменения формы, происходит почти на каждое действие игрока в меню корабля):
    FormCurShip() - возвращает корабль, для которого в текущий момент открыта форма 'Ship'.
  t_OnShipBuysGoods - при покупке товара кораблём:
  t_OnShipSellsGoods - при продаже товара кораблём:
    ScriptItemActShip() - корабль, совершающий сделку;
    ScriptItemActObject1() - возвращает указатель на "информационный" предмет товара, из которого можно получить все основные данные о совершённой сделке:
       - Тип купленного/проданного товара ItemType(ScriptItemActObject1());
         Типы товаров:
           t_Food (0) - продукты;
           t_Medicine (1) - медикаменты;
           t_Technics (2) - техника;
           t_Luxury (3) - роскошь;
           t_Minerals (4) - минералы;
           t_Alcohol (5) - алкоголь;
           t_Arms (6) - оружие;
           t_Narcotics (7) - наркотики;
       - Количество купленного/проданного товара ItemSize(ScriptItemActObject1());
       - Общая стоимость купленного/проданного товара (сумма сделки) ItemCost(ScriptItemActObject1());
    ScriptItemActObject2() - имеет возврат только для события t_OnShipSellsGoods и также возвращает "информационный" предмет, но имеющий другие характеристики, из которых можно получить информацию о прибыльности совершённой продажи:
       - Количество проданного товара с учётом того, сколько товара данного типа было реально закуплено кораблём на свои деньги. Прибыль/убыль с продажи краденного или найденного в космосе/гипере товара не будет учтена в формуле начисления опыта за торговлю/пенальти за торговлю себе в убыток:
         * Если размер данного предмета окажется 0, значит, весь проданный товар является краденным/найденным и его продажа не будет засчитана в качестве торговой прибыли.
         * Если размер предмета меньше, чем размер предмета из ScriptItemActObject1(), значит, кораблём была закуплена только часть проданного товара, а полученная с такой сделки прибыль/убыль должна быть пропорционально снижена для данного количества товара.
         * Если же товар имеет размер равный размеру предмета из ScriptItemActObject1(), значит, весь товар был честно куплен кораблём и 100% от его стоимости будет учтено в качестве прибыли/убыли от продажи.
       - Непосредственно прибыль/убыль от совершённой продажи:
         * Если размер первого и второго предмета совпадают, то разница между их стоимостью и будет считаться чистой прибылью (если стоимость первого предмета выше стоимости второго) или убылью (если стоимость первого предмета ниже стоимости второго) от продажи.
         * Если же размер второго предмета меньше, чем у первого (но не равен 0, т.к. в таком случае считать бессмысленно), то сперва необходимо будет получить фактическую стоимость продажи, которая реально участвует в учёте игрой прибыли/убыли. Сперва поделите стоимость первого предмета на его размер (определите стоимость единицы товара) и затем помножьте полученную стоимость единицы товара на размер второго предмета. Далее необходимо просто сравнить полученную "валидную" стоимость сделки с полной стоимостью второго предмета. Если полученное число выше стоимости второго предмета, значит при продаже была получена прибыль, а иначе на лицо явная убыль, которая будет зачислена игрой в "торговое пенальти".
            Примечание: Торговое пенальти - общая сумма убыли, полученной игроком (другие корабли пенальти не получают) от торговли в убыток. До тех пор, пока пенальти не будет полностью компенсировано торговой прибылью (любая прибыль вычитается из накопленного пенальти), опыт и рейтинг за прибыльную торговлю начисляться не будут. Начисление и списание пенальти (равно как и начисление рейтинга и опыта) происходит уже после срабатывания описываемых акткодовых событий. Проверить и изменить текущую сумму пенальти можно с помощью функции ShipStatistic(Player(), 9).
      Примечание: Менять характеристики "информационных" предметов, возвращаемых через ScriptItemActObject1() и ScriptItemActObject2() бессмысленно, т.к. на параметры совершённой сделки они не повлияют. Также попытка удаления или переноса "информационных" предметов в другое место приведёт к крашу.
    ScriptItemActParam() - возвращает/изменяет маркер о легальности совершённой сделки (0 - легальна, 1 - нелегальна);
  t_OnPlayerTalkedWithShip - когда игрок закончил разговор с кораблём, которого вызвал сам:
  t_OnShipTalkedWithPlayer - когда игрок закончил разговор с вызвавшим его кораблём:
    ScriptItemActShip() - корабль игрока (предположительно);
    ScriptItemActObject1() - корабль, с которым закончил говорить игрок;
  t_OnStartAB - срабатывает перед началом любой аркадной битвы, в которую вступает игрок:
    ScriptItemActShip() - всегда возвращает корабль игрока (бесполезный возврат);
    ScriptItemActObject1() - тоже корабль игрока, но уже исключительно АБ-шный. Возврат из этой функции можно использовать только для подстановки первым аргументом в ABShipModifiers, чтобы установить желаемые модификаторы игроку (удобно использовать в акткоде кастомных артефактов);
    Примечание: Данное событие можно использовать исключительно для изменения аркадных модификаторов игрока (ABShipModifiers). Добавить/удалить корабли NPC в бой в этот момент уже нельзя.
  t_OnABItemDrop - срабатывает при получении игроком предмета из убитого в аркадном бою противника (перед добавлением предмета в трюм и перед выводом уведомления о полученных предметах):
    ScriptItemActShip() - корабль игрока;
    ScriptItemActObject1() - предмет, который будет добавлен в трюм к игроку (можно поменять ему цену, вес, акрин и т.д.);
  t_OnItemPickUp - выполняется когда предмет подняли захватом (срабатывает для поднявшего корабля и для поднятого предмета):
    CurItem() - предмет, для которого исполняется код (обратите внимание, что это далеко не всегда будет именно сам подобранный предмет);
    ScriptItemActShip() - поднявший корабль;
    ScriptItemActObject1() - поднятый предмет (в момент срабатывания уже находится на корабле, не сработает для товаров);
    ScriptItemActParam() - что сделать с поднятым предметом:
                1 - изъять предмет с корабля, но больше не делать ничего (подразумевается, что дальше скриптовый код распорядится предметом сам);
                0 - не делать ничего (по умолчанию);
                 -1 - полностью удалить предмет (если удалить его здесь через FreeItem(), игра может крашнуть при попытке обращения по пустому адресу);
    если передать значение не равное нулю, то удалит поднятый предмет (если здесь использовать FreeItem(), то хардкод может крашнуть при попытке обратиться к уже исполняемому коду предмета);
  t_OnDropItem - предмет выкинули из трюма и он движется (для детекта дропов из кораблей NPC):
  t_OnDropItemFixed - предмет выкинули из трюма и он неподвижен (для детекта дропов из корабля игрока):
    CurItem() - предмет, для которого исполняется код (обратите внимание, что это далеко не всегда будет именно сам дропнутый предмет);
    ScriptItemActShip() - дропнувший корабль (детектится даже после своего "уничтожения");
    ScriptItemActObject1() - дропнутый предмет;
    ScriptItemActParam() - что сделать с дропнутым предметом:
                1 - изъять предмет из системы, но больше не делать ничего (подразумевается, что дальше скриптовый код распорядится предметом сам);
                0 - не делать ничего (по умолчанию);
                 -1 - полностью удалить предмет (если удалить его здесь через FreeItem(), игра может крашнуть при попытке обращения по пустому адресу);
  t_OnReduceEqBattle - срабатывает для предмета, когда происходит его износ в бою:
  t_OnReduceEqUse - срабатывает для предмета, когда происходит его износ от обычного использования:
  t_OnReduceEqForce - срабатывает для предмета, когда происходит его износ от воздействия бертора:
  t_OnReduceEqForsage - срабатывает для двигателя, когда происходит его износ в результате форсажа:
    ScriptItemActShip() - корабль, на котором установлен предмет;
    ScriptItemActObject1() - предмет, который изнашивается;
    ScriptItemActParam() - количество вычитаемых у предмета очков износа, которое необходимо поделить на 1000, для получения точного процента "урона" (полностью исправный предмет имеет стойкость в 100 тысяч очков износа (100%), а полностью изношенный - 0);
  t_OnTrancPacking - срабатывает при сворачивании транклюкатора для корабля хозяина и для транклюкатора:
    ScriptItemActShip() - транклюкатор-корабль, если акткод исполняется для транклюкатора, либо принимающий транка корабль, если акткод исполняется для него;
    ScriptItemActObject1() - транклюкатор-предмет (при необходимости, можно вернуть самого транка по функции ArtTranclucatorToShip());
    ScriptItemActObject2() - куда сворачивается транклюкатор (корабль, планета, станция);
  t_OnDeath - срабатывает для корабля перед его уничтожением:
    ScriptItemActShip() - погибающий корабль;
    Примечание: Это событие срабатывает уже после записи галактических эвентов, так что в нём без проблем можно определить, был ли данный корабль уничтожен игроком или его союзниками.
  t_OnPlayerChangeHull - срабатывает при смене корпуса игроком:
    ScriptItemActObject1() - новый корпус (на который меняем);
    ScriptItemActObject2() - старый корпус (экипированный);
    Примечание: Исполняется для корабля игрока, а также последовательно для старого (до установки), а затем для нового (после установки) корпуса.
  t_OnPlayerUseMM - срабатывает, когда игрок устанавливает микромодуль в оборудование:
    ScriptItemActShip() - корабль игрока, транклюкатор игрока, или станция, с проплаченным взносом на изменение;
    ScriptItemActObject1() - оборудование, в которое вставляется ММ;
    ScriptItemActObject2() - микромодуль в виде предмета;
  t_OnPlayerSkillIncrease - срабатывает при повышении навыка игроком для самого игрока, его транклюкатора или улучшаемой станции:
    ScriptItemActShip() - корабль игрока, транклюкатор игрока, или станция с проплаченным взносом на изменение;
  t_OnItemEquip - выполняется, когда предмет в скриптовом объекте или артефакт надевается (не срабатывает для корабля);
  t_OnItemDeEquip - выполняется, когда предмет в скриптовом объекте или артефакт снимается (не срабатывает для корабля);
    CurItem() - предмет;
    Эти два события - сраное дерьмо! Они не видят корабль, на который экипируется/с которого снимается предмет, и способны работать исключительно для предметов в скриптовых объектах, что делает их бесполезными в 99% случаев.
  t_OnNonStandartEqChange - срабатывает при смене любого оборудования на корабле нестандартным путём, а именно функцией ItemIsInUse (и только ей, т.к. различные функции типа Get и Drop событием не фиксируются) или при смене комплектаций;
    ScriptItemActShip() - корабль, на котором произошла смена оборудования;
  t_OnItemDestroy - выполняется перед уничтожением предмета (срабатывает только для уничтожаемого предмета);
    CurItem() - уничтожаемый предмет;
  t_OnShowingItemInfo - срабатывает перед отображением карточки предмета или инфошки с данным событием;
    CurItem() - предмет, для которого отображается карточка;
    CurInfo() - инфошка, для которой отображается карточка;
    ScriptItemActShip() - если предмет на корабле или складе планеты/станции, то возвращает корабль, для которого в данный момент открыта форма 'Ship' или 'Scaner';
    ScriptItemActObject1() - возвращает звезду, если предмет находятся в открытом космосе и планету/станцию, если предмет закопан на необитаемой планете или продаётся в магазине обитаемой планеты/станции (если предмет на корабле или складе, вернёт 0);
  t_OnShowingShipInfo - аналогично t_OnShowingItemInfo, но только срабатывает перед отображением карточки корабля (вызывается для корабля и для всех предметов у него на борту):
    ScriptItemActShip() - корабль, для которого отображается карточка;
  t_OnCheckingUsability - выполняется, когда игрок курсором пикает предмет, по очереди возвращая все эквипнутые на корабле предметы. Если получает в ответ на очередной предмет 1, то подсвечивает слот этого предмета, как если бы игрок мог установить в него микромодуль;
  t_OnCheckingUsability2 - то же, что и t_OnCheckingUsability, только выполняется для экипированного предмета, а не для взятого "в руку" игроком (исполняется после t_OnCheckingUsability, поэтому если первое событие уже выставило маркер на подсветку, то для подсвеченного предмета t_OnCheckingUsability2 исполнено не будет);
    CurItem() - предмет с акткодом, для которого исполняется событие;
    ScriptItemActObject1() - очередной экипированный предмет (для t_OnCheckingUsability) / предмет "в руке" игрока (для t_OnCheckingUsability2);
    ScriptItemActParam(1) - отправляет маркер, что слот текущего экипированного предмета необходимо подсветить;
  t_OnCheckingUsabilityGoods - аналогичное t_OnCheckingUsability2 событие с той лишь разницей, что срабатывает оно исключительно для товаров (продукты, минералы и т.д.), поскольку товары в трюме не являются предметами и требуют особого подхода в определении их "пика" (соответственно t_OnCheckingUsability и t_OnCheckingUsability2 для товаров срабатывать не будут):
    CurItem() - предмет с акткодом, для которого выполняется событие;
    ScriptItemActObject1() - тип товара в руке;
    ScriptItemActObject2() - количество товара в руке;
    ScriptItemActParam(1) - отправляет маркер, что слот текущего экипированного предмета необходимо подсветить;
    Примечание: Определить стоимость и прочие параметры товара "в руке" можно через функцию FormShipCurItem().

  Важно!!! В целях оптимизации акткода, после его написания необходимо создать специальные параметры-фильтры с указанием всех событий, задействованных в этом коде, пример:
      OnActCodeTypes=t_OnDeath,t_OnItemDestroy,t_OnStep - тэг для указания самих событий (t_OnStep здесь указывать не обязательно, если ниже вы указали второй тэг);
      OnActStepTypes=0,5,11 - конкретные этапы срабатывания события t_OnStep, в данном примере будут обработаны только этапы 0, 5 и 11 (если в вашем коде нет событий t_OnStep, либо они занимают полный диапазон шагов от 0 до 11, то указывать данный тэг не требуется);
  Данная оптимизация крайне важна, т.к. позволяет убрать из акткода все лишние и заведомо холостые проверки, тем самым значительно повышая скорость расчёта хода. Тэги необходимо ставить в разделе предмета, либо инфошки, наряду с прочими тэгами вроде Name, Text и т.д. Указать подобные тэги для акткода, который затем будет подставлен в скриптовый объект, невозможно, но т.к. подобных объектов во всей игре довольно мало, делать этого и не требуется.
  Примечание: Все события "для корабля" также срабатывают и для всех установленных и лежащих в его трюме предметов с поправкой на то, что для получения акткода оборудование должно быть сперва занесено в скрипт, артефакты обрабатывают акткод только будучи установленными в слот, а юзлесные предметы работают всегда, в том числе и из трюма (и, при желании, даже могут быть эквипнуты в несуществующий слот).


Функции, активирующие активные способности артефактов из оригинальной игры:
OnUseCodeTranclucator - без аргументов, запускает транклюкатора и возвращает его указатель;
  Примечание: При первом вызове данной функции, будет запущен транклюкатор, для которого был непосредственно запущен юзкод (если функция применялась из юзкода), но если запустить функцию несколько раз, либо не из юзкода транклюкатора, то будет запущен случайный имеющийся транклюкатор из трюма игрока.
OnUseCodeTransmitter - активирует трансфакторный маяк:
  Без аргументов - активирует ТМ, для которого сработал данный юзкод (должна быть вызвана из юзкода ТМ);
  Опционально:
  1 - конкретный маяк, активирует указанный ТМ;
  2 - маркер для отключения звука и сообщения об активации ТМ (если 0, то сообщения и звук воспроизведены не будут);
OnUseCodeBlackHole - без аргументов, активирует Субпортал при использовании, возвращает созданную ЧД (должна быть вызвана из юзкода Субпортала);
OnUseCodeMissileDef - без аргументов, активирует активное свойство Ракетанга - уничтожение своих ракет (должна быть вызвана из юзкода Ракетанга);


Виды эффектов в дамагсете (присваиваются в параметре WeaponMods):
  'Energy' (1) - энергетический урон;
  'Splinter' (2) - осколочный урон;
  'Missile' (4) - ракетный урон;
  'Decelerate' (8) - снижает скорость цели, технически перегревает её двигатель (эффект Третона);
  'Destruct' (16) - разрушает оборудования цели (эффект Электронного резака);
  'Drain' (32) - восстанавливает по единице структуры за каждую единицу нанесённого урона (100% вампиризм, эффект Третона);
  'Shock' (64) - вешает на цель эффект ионизации (эффект Кафаситора);
  'Acid' (128) - снижает броню цели (эффект Эсодафера);
  'Magnetic' (256) - вешает на цель ЭМ-помехи (которые снижают дальность радара, дальность орудий, мощность сканера и силу ГЗП цели - эффект Лирекрона);
  'DecelerateA' (512) - полный аналог простого замедления 'Decelerate' (эффект артефакта Вжик);
  'DecelerateAEx' (1024) - полный аналог простого замедления 'Decelerate' и 'DecelerateA' (доп. эффект артефакта Вжик в режиме совместимости);
 Примечание: Замедления 'Decelerate', 'DecelerateA' и 'DecelerateAEx' полностью идентичны друг другу, однако при совместном использовании кратно увеличивают замедляющий эффект. К примеру, Вжик в режиме совместимости использует одновременно 'DecelerateA' и 'DecelerateAEx', что увеличивает его замедляющий эффект ровно в два раза.
  'Undefendable' (2048) - применяет к цели урон, считающийся отражённым Поляризатором (наносимый урон игнорирует броню и ГЗП, не не резисты);
  'NonLethal' (4096) - применяет эффект, как от непосредственного воздействия ионизации (наносит урон корпусу, но полностью уничтожить корабль не может)
  'ScanBonus' (8192) - повышает урон оружия на 15% (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'BonusToDamaged' (16384) - повышает урон по повреждённой цели вплоть до 33% (если у цели остался 1 HP) в зависимости от степени повреждения цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
    Примечание: kdamage := kdamage * (1 + 0.33 * (1 - FHull.FHitPoints / FHull.FSize));
  'MoreDrop' (32768) - повышает шанс дропа оборудования при уничтожении цели, аналогично ЛВВ (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'DropCargo' (65536) - добавляет 5% шанс дропа товара из трюма при нанесении урона цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'ReduceEngine' (131072) - наносит повреждения двигателю цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'BlockWeapon' (262144) - имеет шанс (обратно пропорционален размеру корпуса цели) блокировки оружия цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'BlockDroid' (524288) - имеет шанс (обратно пропорционален размеру корпуса цели) блокировки дроида цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'NoDelta' (1048576) - отключает разброс урона (оружие с данным эффектом всегда наносит максимальный урон, эффект Эсодафера, не имеет смысла добавлять в дамагсет наносимого урона, т.к. этот эффект применяется только к предмету орудия, а не к самому урону);

Примечание: Для проверки наличия определённых эффектов в дамагсете конкретного орудия, необходимо сперва узнать его полный дамагсет (GetEquipmentStats(weapon, 6)), а затем применить к нему одну из проверок следующего вида:
  if((damageset & 64)) - проверит, имеется ли в дамагсете эффект, вешающий на цель ионизацию (в случае наличия эффекта, выражение в скобках вернёт проверке 64);
  if(!(damageset & 64)) - проверит, что в данном дамагсете эффекта, вешающего на цель ионизацию, нет (вернёт 0);
  if((damageset & 64) || (damageset & 256)) - проверит, имеется ли в дамагсете эффект, вешающий ионизацию или эффект, вешающий ЭМ-помехи;
  if((damageset & (64+256)) == (64+256)) - проверит, имеются ли в дамагсете одновременно оба этих эффекта;
  if((damageset & 1+2+4+8+16+32+64+128+256)) - проверит, имеется ли в дамагсете хоть один из перечисленных в проверке эффектов (записывать проверочный сет в виде суммы не обязательно, но удобно для читабельности кода);
  Также имейте в виду, что вешать эффекты с требованием к мощности сканера на всякие посторонние объекты (не на оружие) типа акринов ракет бессмысленно, т.к. работать они там всё равно не будут.
Примечание: Эффекты 'Shock', 'Acid' действуют на доминаторов слабее, эффект 'Magnetic' действует сильнее, а эффект 'Destruct' не действует на них совсем.

Галактические события (запоминаются игрой сразу же в момент совершения и могут быть просмотрены из любого кода в любой момент):
GalaxyEvents - без аргументов, возвращает все последние сохранённые в памяти галактические события (самые старые из них постепенно удаляются);
  Примечание: Для проверки последних галасобытий желательно делать перебор от конца к началу списка, и останавливать цикл по достижении первого же события от прошлого хода.
GalaxyEventDate - возвращает дату галактического события:
  1 - номер события из списка;
GalaxyEventType - возвращает тип галактического события в виде строки:
  1 - номер события из списка;
GalaxyEventData - возвращает числовые данные галактического события:
  1 - номер события из списка (возвращает количество доступных типов данных для этого события);
  Опционально:
  2 - номер типа данных (возвращает значение указанного типа данных события);
GalaxyEventsTextData - возвращает текстовые данные галактического события:
  1 - номер события из списка (возвращает количество доступных типов строковых данных для этого события);
  Опционально:
  2 - номер типа данных (возвращает значение указанного типа строковых данных события);

Типы галактических событий:
  'PlayerKillsShip' - игрок кого-то уничтожил:
  'PlayerAssistKillsShip' - игрок оказал помощь в уничтожении:
      Числовые данные GalaxyEventData():
        0 - числовой тип уничтоженного корабля (ShipTypeN());
        1 - Id системы;
        2 - Id уничтоженного корабля;
        3 - раса уничтоженного корабля;
        4 - относительная крутизна уничтоженного корабля (100 соответствует среднему рейнджеру);
        5 - подтип уничтоженного корабля;
      Текстовые данные GalaxyEventsTextData():
        0 - имя уничтоженного корабля;
        1 - полное имя уничтоженного корабля;
        2 - строчный кастомный тип уничтоженного корабля (ShipType());
  'PlayerTranclucatorKillsShip' - транклюкатор игрока кого-то уничтожил:
  'PlayerTranclucatorAssistKillsShip' - транклюкатор игрока оказал помощь в уничтожении:
      Числовые данные GalaxyEventData():
        0 - тип уничтоженного корабля номером (ShipTypeN());
        1 - Id системы;
        2 - Id уничтоженного корабля;
        3 - раса уничтоженного корабля;
        4 - Id транклюкатора игрока;
        5 - раса транклюкатора игрока;
        6 - относительная крутизна уничтоженного корабля (100 соответствует среднему рейнджеру);
        7 - подтип уничтоженного корабля;
      Текстовые данные GalaxyEventsTextData():
        0 - имя уничтоженного корабля;
        1 - имя транклюкатора игрока;
        2 - полное имя уничтоженного корабля;
        3 - строчный кастомный тип уничтоженного корабля (ShipType());
  'PlayerCompanionKillsShip' - компаньон игрока кого-то уничтожил:
  'PlayerCompanionAssistKillsShip' - компаньон игрока оказал помощь в уничтожении:
      Числовые данные GalaxyEventData():
        0 - тип уничтоженного корабля;
        1 - Id системы;
        2 - Id уничтоженного корабля;
        3 - раса уничтоженного корабля;
        4 - тип корабля компаньона;
        5 - Id корабля компаньона;
        6 - раса корабля компаньона;
        7 - относительная крутизна уничтоженного корабля (100 соответствует среднему рейнджеру);
        8 - подтип уничтоженного корабля;
      Текстовые данные GalaxyEventsTextData():
        0 - имя уничтоженного корабля;
        1 - имя компаньона;
        2 - строчный кастомный тип уничтоженного корабля (функция ShipType());
    Важно!!! Возврат строчного типа корабля для оригинальных типов кораблей ('Ranger', 'Warrior' и т.д.) всегда будет возвращать пустую строку.
  'LabeledShipKilledInAB' - аркадный противник/союзник с особой текстовой меткой (которую можно выставить при его создании) был уничтожен:
      Текстовые данные GalaxyEventsTextData():
        0 - строковая метка корабля;
  'LabeledShipSurvivedInAB' - аркадный противник/союзник с особой текстовой меткой (которую можно выставить при его создании) выжил в бою:
      Числовые данные GalaxyEventData():
        0 - оставшееся после боя здоровье в единицах HP;
        1 - максимальный уровень здоровья (сколько было в начале боя) в единицах HP;
      Текстовые данные GalaxyEventsTextData():
        0 - строковая метка корабля;
  'PlayerAcceptsMoneyForTruce' - игрок согласился принять деньги за примирение с другим кораблём:
  'PlayerExtortsMoney' - игрок вытребовал деньги у другого корабля (имеется в виду, вытребовал успешно):
  'PlayerExtortsGoods' - игрок вытребовал груз у другого корабля:
      Числовые данные GalaxyEventData():
        0 - количество полученных денег или стоимость груза;
        1 - тип другого корабля;
        2 - Id системы;
        3 - Id другого корабля;
        4 - раса другого корабля;
      Текстовые данные GalaxyEventsTextData():
        0 - имя другого корабля;
  'PlayerDebtNullified' - кредитный долг игрока обнулился из-за уничтожения всех БЦ (срабатывает, если игрок имел долг):
      Числовые данные GalaxyEventData():
        0 - обнулённый долг;
  'PlayerNodesNullified' - нод-счёт игрока обнулился из-за уничтожения всех ЦР (срабатывает, если на счету имелся хоть 1 нод):
      Числовые данные GalaxyEventData():
        0 - обнулённые ноды;
  'PlayerUsesSubportal' - игрок активировал субпортал:
      Числовые данные GalaxyEventData():
        0 - Id ЧД;
        1 - дата открытия ЧД;
  'PlayerJumpsThroughSubportal' - игрок совершил прыжок через субпортал:
      Данные отсутствуют;
  'PlayerUsesBeacon' - игрок активировал трансфакторный маяк:
      Числовые данные GalaxyEventData():
        0 - Id системы, в которой был активирован маяк;
  'PlayerChangesNationality' - игрок сменил расу:
      Числовые данные GalaxyEventData():
        0 - новая раса;
  'PlayerChangesSide' - игрок сменил сторону конфликта:
      Числовые данные GalaxyEventData():
        0 - на чью сторону перешёл игрок (0 - Коалиция, 1 - пиратский клан);
  'PlayerOrdersPirateRaid' - игрок заказал пиратский набег:
      Числовые данные GalaxyEventData():
        0 - Id атакуемой системы;
  'PlayerDeath' - игрок погиб:
      Данные отсутствуют;
  'PlayerBuysEquipment' - игрок приобрёл предмет в магазине оборудования:
  'PlayerSellsEquipment' - игрок продал оборудование или юзлесный предмет:
      Числовые данные GalaxyEventData():
        0 - тип предмета;
        1 - цена предмета;
        2 - вес предмета;
        3 - Id предмета;
        4 - тип магазина (0 - планета, 1 - станция);
        5 - Id магазина;
      Текстовые данные GalaxyEventsTextData():
        0 - название предмета;
  'PlayerBuysGoodsFromPlanet' - игрок приобрёл товары на планете:
  'PlayerSellsGoodsToPlanet' - игрок продал товары на планете:
      Числовые данные GalaxyEventData():
        0 - тип товара;
        1 - количество товара;
        2 - общая стоимость товара;
        3 - Id планеты;
  'PlayerBuysMissiles' - игрок зарядил ракетное орудие (купил заряды):
      Числовые данные GalaxyEventData():
        0 - потраченные деньги;
        1 - число купленных зарядов;
  'PlayerFinishesQuest' - игрок завершил текстовый квест (возможно, имеются ввиду вообще все задания, кроме ПБ):
      Числовые данные GalaxyEventData():
        0 - тип квеста;
        1 - номер квеста;
        2 - полученные деньги;
        3 - полученный опыт;
  'PlayerFinishesPlanetaryBattle' - игрок завершил планетарный бой:
      Числовые данные GalaxyEventData():
        0 - номер ПБ;
        1 - полученные деньги;
        2 - полученный опыт;
  'PlayerReceivesMM' - игрок приобрёл микромодуль (видимо, только на ЦР):
      Числовые данные GalaxyEventData():
        0 - Id микромодуля;
        1 - тип микромодуля (уровень);
        2 - цена микромодуля в нодах;
  'PlayerReceivesMMAsReward' - игрок получил микромодуль в качестве награды:
      Числовые данные GalaxyEventData():
        0 - Id микромодуля;
        1 - тип микромодуля;
  'PlayerReceivesMMOnNewYear' - игрок получил микромодуль в качестве новогоднего подарка:
      Числовые данные GalaxyEventData():
        0 - Id микромодуля;
        1 - тип микромодуля;
  'PlayerLiberatesSystem' - игрок освободил систему:
      Числовые данные GalaxyEventData():
        0 - Id системы;
        1 - новый владелец (овнер) системы;
        2 - бывший владелец (овнер) системы;
        3 - количество сбитых (игроком?) кораблей;
        4 - Id планеты награждения;
  'RuinsCreated' - построена новая станция:
  'RuinsDestroyed' - станция уничтожена:
      Числовые данные GalaxyEventData():
        0 - числовой тип станции;
        1 - Id станции;
        2 - Id системы;
      Текстовые данные GalaxyEventsTextData():
        0 - имя станции (без приставки типа);
        1 - строчный кастомный тип станции (ShipType);
    Важно!!! Возврат строчного типа станции для оригинальных станций всегда будет возвращать пустую строку.
  'PlayerEntersCheatCode' - игрок ввёл чит-код:
      Числовые данные GalaxyEventData():
        0 - стоимость чита в очках;
      Текстовые данные GalaxyEventsTextData():
        0 - название чита;
  'SaveLoaded' - игрок загрузил сохранённую игру:
      Числовые данные GalaxyEventData():
        0 - флаг загрузки дампа для загруженного сейва (да/нет);
      Текстовые данные GalaxyEventsTextData():
        0, 1, 2 и т.д. - перечисление всех подключённых в сейве модов в формате 'Expansion\ExpArts' (название раздела \ название мода);
  'GlobalChangeToPlayerReputation' - произошло глобальное изменение отношения планет к игроку (например, выплатил пособие пострадавшим семьям, сменил подданство, сменил сторону конфликта, вышел из тюрьмы, а также, если какой-нибудь скрипт вызвал ChangeGlobalRelationsPlanets()):
      Числовые данные GalaxyEventData() (как именно хардкод изменил отношение в данном событии):
         0 - тип произведённого изменения отношения (диапазон от 0 до 100):
            0 - понизить отношение до указанного значения (но не ниже);
            1 - повысить отношение до указанного значения (но не выше);
            2 - прибавить указанное значение к уже имеющемуся, но не выше 100;
            3 - отнять указанное значение от уже имеющегося, но не ниже 0;
            4 - отнять указанное значение от уже имеющегося, но не ниже 10 (то есть не доводить до враждебного уровня);
         1 - само значение для изменения отношения;
         2 - сет рас, для планет и кораблей которых было применено данное глобальное изменение репутации;
      Уточнения по срабатыванию данного события:
        Спонсирование проектов на БЦ:
          - Спонсировать бедных рейнджеров, событие 'GlobalChangeToPlayerReputation' не вызывается;
          - Спонсировать транспортный комитет, событие 'GlobalChangeToPlayerReputation' не вызывается;
          - Субсидировать пиратов, событие 'GlobalChangeToPlayerReputation' не вызывается;
          - Строительство НБ, событие 'GlobalChangeToPlayerReputation' не вызывается;
          - Строительство МЦ, событие 'GlobalChangeToPlayerReputation' не вызывается;
          - Строительство БЦ, событие 'GlobalChangeToPlayerReputation' не вызывается;
          - Строительство ЦР, +10 к отношению всех рас Коалиции, сет рас 1+2+4+8+16 (тип изменения отношения 2);
          - Строительство ВБ, +30 к отношению всех рас Коалиции, сет рас 1+2+4+8+16 (тип изменения отношения 2);
          - Строительство ПБ, три последовательных вызова:
           +20 к отношению пеленгов, сет рас 2 (тип изменения отношения 2);
           -10 к отношению малоков и людей, сет рас 1+4 (тип изменения отношения 4);
           -30 к отношению фэян и гаальцев, сет рас 8+16 (тип изменения отношения 4);
          - Спонсирование строительства военного флота для планеты, +20 к отношению всех рас Коалиции, сет рас 1+2+4+8+16 (тип изменения отношения 2);
          - Пособие семьям, пострадавшим от войны, +30 к отношению всех рас Коалиции, сет рас 1+2+4+8+16 (тип изменения отношения 2);
        Смена подданства на ПБ:
          - Повысить отношение всех рас, но не выше 70, сет рас 1+2+4+8+16 (тип изменения отношения 1);
          (для пиратских планет также повышает отношение Роджерии до 45 (но не выше), но не через общую функцию, т.к. менять отношение пиратских планет ChangeGlobalRelationsPlanets() почему-то не может)
        Смена стороны на ПБ (при первом вступлении в клан отношение не меняется):
          - При выходе из клана, повысить отношение всех рас, но не выше 45, сет рас 1+2+4+8+16 (тип изменения отношения 1);
          (для пиратских планет также понижает отношение Роджерии до 20 (но не ниже), но не через общую функцию, т.к. менять отношение пиратских планет ChangeGlobalRelationsPlanets() почему-то не может)
        - При вступлении в клан, понизить отношение всех рас, но не ниже 20, сет рас 1+2+4+8+16 (тип изменения отношения 0);
          (для пиратских планет также повышает отношение Роджерии до 45 (но не выше), но не через общую функцию, т.к. менять отношение пиратских планет ChangeGlobalRelationsPlanets() почему-то не может)
        Отсидка в тюрьме:
          На коалиционной планете:
          - Повысить отношение всех рас, но не выше 20, сет рас 1+2+4+8+16 (тип изменения отношения 1);
          - Также повышает отношение всех планет сектора, в котором игрок отбывал срок, на ещё +30 + (обаяние * 6), но для этого событие 'GlobalChangeToPlayerReputation' уже не вызывается;
          (планета, на которой игрок непосредственно отсидел, всегда получает отношение 100, но если игрок сбежал из тюрьмы, то она получит 0)
          На пиратской планете:
          - Отношение всех пиратских планет (Роджерии) увеличивается на +80 + (обаяние * 16) к текущему отношению, естественно, событие 'GlobalChangeToPlayerReputation' не вызывается;
          (если игрок сбежал из пиратской тюрьмы, то все пиратские планеты (Рождерия) получает отношение 0)
        Помимо этого, вызовы данного события происходят в начале игры, на стартовом ЦР (возможно, из обучающего скрипта):
        - Последовательно несколькими вызовами (сверху-вниз, от гаальцев до малоков) снижается отношение к игроку определённых рас, в зависимости от расы и стартового характера, выбранного игроком (тип изменения отношения 0);
          (вероятно, что смена отношения на старте также происходит и для пиратов (Роджерии), но подробно не проверял)
        Подкуп правителя планеты (вызова 'GlobalChangeToPlayerReputation' не происходит, но тем не менее отношение меняется):
        - Все планеты коалиционной системы, кроме подкупленной (которая сразу получает отношение 100), получают фиксировано по +24 отношения к игроку;
          (правителей пиратских планет подкупить нельзя)


Стейткод (то есть код, привязанный к любому стейту посредством if/Op):
ShipJoin - присоединяет корабль к скриптовой группе:
  1 - название переменной или номер группы (код определяет все группы по их внутреннему номеру в конкретном скрипте);
  2 - корабль;
  Опционально:
  3 - маркер (если подставить что угодно, кроме строки) запрета на автоматический перевод корабля в первый привязанный к группе стейт, что подразумевает дальнейший его перевод в какой-либо стейт вручную через ChangeState(), либо, если была передана не пустая строка, перевод корабля сразу в указанный (строкой) стейт, либо, если сюда была передана пустая строка, то будет присвоен стандартный стейт по умолчанию;
  4, 5, 6, 7 - стартовые значения переменных в GetData()/SetData() данного скриптового корабля (по умолчанию имеют 0), тип dword;
  Важно: При добавлении корабля в скриптовую группу, любой прикреплённый к стейту (в который попадёт корабль) код будет в первый раз исполнен сразу же в момент добавления!
ShipOut - выводит корабль из его текущей скриптовой группы (любой NPC может быть одновременно записан лишь в одну скриптовую группу, так что указывать её не требуется):
  1 - корабль (если указать игрока, то он будет выведен из своей текущей группы в данном конкретном скрипте);
AllShipOut - без аргументов, выводит все корабли из всех групп в текущем скрипте (по сути, является функцией для полного отключения скрипта);
ChangeState - сменить State корабля на другой, игнорируя обычную схему переходов:
  1 - стэйт (название строкой в кавычках или номер);
  Опционально:
  2 - корабль (по умолчанию стэйт будет изменён для корабля в текущем стэйте CurShip);
  Примечание: При смене стейта будет сразу же исполнен любой прикреплённый к нему код. Если изменить стейт корабля на тот же самый стейт, в котором корабль находится в настоящий момент, то прикреплённый к стейту код также будет исполнен.
StateIs - проверяет наличие скриптового корабля в определённом стейте/стейтах (вернёт 1, если корабль находится в одном из перечисленных):
  1 - корабль в скриптовой группе (для нескриптовых кораблей будет всегда возвращать 0);
  2, 3, 4 ... N - номера, либо названия стейтов в виде строк, наличие в которых корабля необходимо проверить;
Hit - проверяет, атаковал/был ли атакован игрок скриптовым кораблём (после выставления маркер уже не обнуляется):
  1 - скриптовый корабль (вернёт 1, если игрок, его транк или партнёр нанесли урон по данному скриптовому кораблю);
  Опционально:
  2 - если подставлена 1, то функция вернёт 1 только в том случае, если по игроку (и только по нему) нанёс урон скриптовый корабль из первого аргумента;
  Примечание: После выставления маркера Hit на скриптовом корабле, сброшен он с него уже не будет, что делает эту функцию, по сути, одноразовой проверкой на случившуюся агрессию между конкретным скриптовым кораблём и игроком.
CurShip - переменная, в которую записан корабль, для которого в данный момент исполняется стейткод;
EndState - переменная, которая приравнивается к 1, когда текущий стейт завершает своё основное дествие (например, корабль прибыл в точку назначения, указанную для него в стейте с типом Move);
GetData - получить числовые данные типа dword (по 4 переменные на каждый скриптовый корабль) для скриптового (находящегося в группе) корабля:
  Без аргументов - вернёт значение в первой переменной для корабля в текущем стейте;
  Опционально:
  1 - номер переменной, значение которой нужно вернуть (0-3);
  2 - корабль (при вызове из стейткода корабль можно не указывать);
SetData - задать числовые данные типа dword для скриптового (находящегося в группе) корабля:
  1 - новое значение переменной (если не указан второй аргумент, то задаёт значение первой переменной);
  Опционально:
  2 - номер переменной, значение которой нужно задать (0-3);
  3 - корабль (при вызове из стейткода корабль можно не указывать);
  Примечание: Если запрашиваемый корабль - игрок, то его данные можно получать исключительно из скрипта, в котором находится конкретная группа с игроком (из акткода и юзкода по данным игрока всегда будет возвращаться unknown).
ShipData - то же, что и GetData/SetData, но объединённое в одной функции и только для первой переменной:
  Без аргументов - вернуть текущее значение первой переменной;
  Опционально:
  1 - задать новое значение первой переменной;
  Примечание: Данную функцию можно вызывать исключительно из стейткода.
ShipInCurScript - проверяет, находится ли корабль в одной из скриптовых групп в текущем скрипте (естественно, нужно вызывать из конкретного скрипта):
  1 - корабль;
  Примечание: Функция ShipInCurScript() является внутренней скриптовой проверкой и может быть вызвана только внутри какого-либо скрипта.
ShipInScript - делает проверку, находится ли корабль в одной из скриптовых групп в любом скрипте и/или имеет на себе включённый OrderLock():
  1 - корабль;
  Опционально:
  2 - если 0, то отключить проверку на OrderLock(), оставив проверку только на нахождение в скриптовой группе (по умолчанию проверка на OrderLock включена);
  Примечание: Функция ShipInScript() является универсальной проверкой и может быть вызвана откуда угодно.
  Общее примечание: Обработка стейткода может происходить множество раз за ход и включается тогда, когда кораблю нужно использовать собственную логику для определения дальнейших действий. Также при работе со стейткодом внутренняя переменная CurShip всегда будет возвращать корабль, для которого в данный момент обрабатывается стейткод. То есть весь привязанный к стейтам код можно смело писать через CurShip вне зависимости от количества кораблей в группе, т.к. все они будут обрабатываться последовательно.

Интерфейс и кастомные инфошки:
CurInfo - без аргументов, возвращает прямой указатель на инфошку при вызове из её акткода;
ShipCustomShipInfosCount - возвращает общее количество кастомных инфошек на корабле:
  1 - корабль;
ShipAddCustomShipInfo - добавляет на корабль/станцию кастомную инфошку и возвращает её указатель аналогично функции CurInfo():
  1 - корабль;
  2 - строка с системным именем инфошки (из Lang);
  Опционально:
  3 - строка с описанием инфошки (заменит собой описание из Lang) или маркером 'NoShow' (не будет отображаться в разделе состояний корабля), также можно оставить пустой '', если менять стандартное описание данной инфошки не нужно;
  4 - числовая переменная инфошки №1 (тип int);
  5 - числовая переменная инфошки №2;
  6 - числовая переменная инфошки №3;
  7 - строковая переменная инфошки №1 (тип str);
  8 - строковая переменная инфошки №2;
  9 - строковая переменная инфошки №3;
ShipDeleteCustomShipInfo - удаляет одну указанную кастомную инфошку с корабля (одинаковых инфошек там может висеть и несколько):
  1 - корабль;
  2 - строка с системным именем или номер инфошки, либо прямой указатель CurInfo();
ShipFindCustomShipInfoByType - возвращает номер инфошки по её имени в списке инфошек корабля:
  1 - корабль;
  2 - системное имя инфошки;
ShipCustomShipInfoDescription - возвращает или устанавливает описание инфошки:
  1 - корабль;
  2 - номер или системное имя инфошки;
  Опционально:
  3 - строка, которая заменит собой текущее описание;
ShipCustomShipInfoData - возвращает или устанавливает числовые данные переменной (тип int) для инфошки:
  1 - корабль;
  2 - номер или имя инфошки (или сама инфошка CurInfo() при вызове из акткода инфошки, в таком случае вместо корабля можно поставить 0);
  3 - номер переменной (1-3);
  Опционально:
  4 - какое значение установить (при подстановке тэга вида <Data1> в описание этой инфошки, автоматически подставляет в то место значение соответствующей ячейки данных);
ShipCustomShipInfoTextData - возвращает или устанавливает текстовые данные переменной (тип str) для инфошки:
  1 - корабль;
  2 - номер или имя инфошки;
  3 - номер переменной (1-3);
  Опционально:
  4 - какое значение установить (при подстановке тэга вида <TextData1> в описание этой инфошки, автоматически подставляет в то место значение соответствующей ячейки текстовых данных);
StarMapLabel - добавляет к названию системы на галакарте текстовую метку:
  1 - система;
  2 - строковая метка;
StarCustomStarInfosCount - возвращает общее количество кастомных инфошек системы (один объект в списке системы (планета/станция и т.д.) - одна инфошка):
  1 - система;
StarAddCustomStarInfo - добавляет кастомную инфошку для системы:
  1 - система;
  2 - текстовая метка инфошки для дальнейшего поиска её номера в списке кастомных инфошек системы (можно добавлять сюда тип и Id станции, например, чтобы было удобно потом удалять инфошку в случае её гибели);
  3 - название объекта в списке объектов системы (находится слева от главной иконки);
  4 - удалённость изображаемого инфошкой объекта от центра системы, определяет положение кастомной инфошки в списке объектов системы;
  5 - путь к главной иконке объекта (обычно иконка самой планеты/станции) строкой вида: 'Bm.YourPath' (будет автоматически отмасштабирована до нужного размера, если передать большую картинку);
  6 - текст справа от главной иконки, либо путь к дополнительным картинкам (для планеты сюда обычно подставляются картинки расы, отношения и т.д.);
  Примечание: Справа от главной иконки можно добавить либо текст, либо картинки/картинку. И то и другое добавить не получится. Путь к дополнительным картинкам/картинке добавляется в четвёртый аргумент строкой вида: 'Image:Bm.Path1,Bm.Path2', и т.д.
StarFindCustomStarInfoByType - ищет номер кастомной инфошки системы по её текстовой метке (если не найдёт, вернёт -1):
  1 - система;
  2 - текстовая метка инфошки;
StarDeleteCustomStarInfo - удаление кастомной инфошки для системы:
  1 - система;
  2 - номер кастомной инфошки;
StarCustomStarInfoData - возвращает/устанавливает нужное значение в кастомной инфошке звезды:
  1 - система;
  2 - номер кастомной инфошки;
  3 - запрашиваемый параметр:
     'Dist' - удалённость изображаемого инфошкой объекта от центра системы, определяет положение кастомной инфошки в списке объектов системы;
     'Name' - название объекта в списке объектов системы (находится слева от главной иконки);
     'Icon' - путь к главной иконке объекта (обычно иконка самой планеты/станции) строкой вида: 'Bm.YourPath' (будет автоматически отмасштабирована до нужного размера, если передать большую картинку);
     'Info' - текст справа от главной иконки, либо путь к дополнительным картинкам (для планеты сюда обычно подставляются картинки расы, отношения и т.д.);
   Примечание: Справа от главной иконки можно добавить либо текст, либо картинки/картинку. И то и другое добавить не получится. Путь к дополнительным картинкам/картинке добавляется в четвёртый аргумент строкой вида: 'Image:Bm.Path1,Bm.Path2', и т.д.
  Опционально:
  4 - новое значение параметра;


Прочее:
HoleMamaCreate - осталось от КР1, чёрная дыра Махпеллы;
RobotSupport - поддерживаются планетарные битвы, на особо слабых машинах могут не работать;
StarListToPlanetList - вспомогательная функция для пиратской сюжетки, из списка систем строит список планет по критериям, которые я уже сам не помню (evilcoward);
StarListToTransitPlanetList - вспомогательная функция для пиратской сюжетки, составляет список планет находящихся где-то по дороге от одной системы к другой, с учетом модификаторов, которые я уже не помню (evilcoward), пример:
  int counter = StarListToTransitPlanetList(locations, ShipStar(Player()), ShipStar(Player()), 70, 150, 200, 100, 90, 75, array_chosen_planets, 0);
EndGame - завершает партию:
  Без аргументов - перекинет сразу на экран титров;
  Опционально:
  1 - тип выводимой на экран пиратской победной концовки (числа 5-18):
CustomWin - кастомная победа;
  1 - текст, который будет выведен на экране победы;
  Опционально:
  2 - номер картинки, которая будет установлена на экране победы (по умолчанию ставится стандартная расовая);
CustomLose - кастомное поражение:
  1 - текст, который будет выведен на экране поражения;
  Опционально:
  2 - номер картинки, которая будет установлена на экране поражения (по умолчанию ставится стандартная расовая);
PirateWin - возвращает или устанавливает тип завершения пиратской сюжетной ветки:
  Без аргументов - вернёт текущий статус пиратской сюжетки;
  Опционально:
  1 - какой статус пиратской сюжетки установить (положительная/отрицательная подразумевается с точки зрения пиратов):
     0 - пираты воюют с Коалицией (начальный статус);
     1 - пираты проникли во власть (положительная);
     2 - пираты вернулись к истокам (положительная);
     3 - Коалиция спасена от пиратов (отрицательная);
     4 - пиратов преследуют неудачи (отрицательная);
     5 - пираты поработили Коалицию (положительная);
ShipInPrison - проверяет начинает/заканчивает время тюремной "отсидки" рейнджера или пирата:
  1 - корабль рейнджера или пирата (если запросить время "отсидки" корабля любого другого типа, вернёт 0);
  Опционально:
  2 - сколько дней "отсидки" установить;
  Примечание: Вроде как если установить срок "отсидки", пока корабль не на планете, он "сядет" сразу же после приземления.
CapitalShipStats - проверяет наличие, либо добавляет/изменяет мостик для указанного корпуса:
  1 - сам корпус или использующий его корабль (вернёт номер установленного мостика, либо 0, если мостик не установлен);
  Опционально:
  2 - какой номер мостика установить (для мостика ТИ восстанавливает запас энергии до 1000 при любом числе, кроме 0);
  Только для мостика ТИ:
  3 - какой максимальный лимит энергии установить (по умолчанию 1000);
  Примечание: Для того, чтобы подключить к корпусу мостик ТИ (и, фактически, сделать из него ТИ, которому можно навесить любой акрин), нужно установиться мостик корпуса на 1. Для корпуса с мостиком 1, любое положительное значение второго аргумента будет расцениваться как маркер для полного восстановления энергии. При этом снять такой мостик с корпуса всё ещё можно, если выставить вторым аргументом 0. Нумерация мостиков записана в переменной типа byte (ограничена значениями от 0 до 255).
PlayerBridge - возвращает номер мостика, на котором находится игрок, либо переводит игрока на него:
  Без аргументов - вернёт номер текущего мостика (либо 0, если игрок не на мостике);
  Опционально:
  1 - номер мостика, на который нужно перевести игрока (если 0, то выйти с мостика);
  2 - какой фон установить для мостика, на который будет переведён игрок;
  Примечание: Мостик корабля технически является скрытой военной базой, со всеми вытекающими последствиями. При проверке начала диалога, необходимо иметь это в виду, если вы собираетесь добавлять диалоги на военную базу. Без дополнительной проверки активности мостика вы можете случайно вывести на него диалоги, предназначенные для ВБ.
WeaponHit - конкретный корабль производит выстрел по конкретной цели (не отрисовывает никаких эффектов):
  1 - стреляющий корабль/станция;
  2 - объект-цель (только корабль/станция или ракета);
  3 - конкретное орудие, которое производит выстрел (может находиться где угодно в Галактике (или в хранилище), но должно существовать в виде предмета, степень износа орудия не важна);
FireWeapon - полноценный выстрел, принимает любые цели, сам применяет и отрисовывает всё эффекты:
  1 - стреляющий корабль/станция;
  2 - объект-цель (корабль/станция, астероид, предмет или ракета);
  3 - конкретное орудие, которое производит выстрел (может находиться где угодно в Галактике (или в хранилище), но должно существовать в виде предмета, степень износа орудия не важна);
  Примечание: Если выстрел производится по предмету (астероидам и ракетам всё же нужен указатель на орудие), то показатель урона конкретного орудия не будет иметь никакого значения. Таким образом, третий аргумент можно задать как 0 (что также отменит и анимацию выстрела), и не париться с поисками подходящей для выстрела пушки. Учтите, однако, что выстрел по предмету без указания пушки всё равно вызовет в этом предмете срабатывание события t_OnItemHit, однако в возврате функции ScriptItemActObject1() в таком случае будет закономерно записано 0. Также данные функции не смогут произвести полноценный запуск ракеты из ракетного орудия. Для запуска ракет необходимо использовать функции LaunchMissile() или же непосредственно SpawnMissile().
LaunchMissile - производит запуск ракеты/торпеды из указанного ракетного орудия и возвращает указатель на выпущенную ракету (не расходует и не проверяет текущий боезапас, но можно делать это вручную):
  1 - стреляющий корабль/станция;
  2 - объект-цель (корабль/станция, астероид, предмет или ракета);
  3 - конкретное ракетное (не проверял с другими типами) орудие, которое производит выстрел (может находиться где угодно в Галактике (или в хранилище), но должно существовать в виде предмета, степень износа орудия не важна);
  Опционально:
  4 - порядковый номер ракеты (начиная с 0), нужен чтобы можно было производить "веерные" запуски, для чего необходимо вызвать функцию несколько раз, каждый раз задавая последующий номер;
  Примечание: Если запустить торпеду с помощью данной функции, но не менять значение боезапаса вручную, то потеряв цель, торпеда вернётся обратно на корабль и пополнит боезапас запустившего её орудия, если оно находится на корабле (проверяет по Id), но выше максимума пополнить всё равно не сможет.
DealDamageToShip - наносит урон кораблю не учитывая броню и ГЗП, но учитывая процентные модификаторы артефактов и оружейных модификаций, а также резисты корпуса:
  1 - цель (корабль/станция);
  2 - источник урона, любой объект (может быть 0);
  3 - урон;
  4 - дамагсет;
  Опционально:
  5 - радиус урона от сплеша;
    Важно: При вызове из акткода данная функция прерывает исполнение акткода и наносит урон кораблю/предмету у которого также может сработать акткод с аналогичным событием (в том числе с такой же инфошки, что приведёт к перезаписи значения переменных уже в изначальном акткоде), что может в итоге привести к неконтролируемой циклической реакции срабатываний акткода между разными кораблями/предметами. Используйте данную функцию с должной осторожностью!
    Примечание: Имеется в виду, что сама функция наносит указанной цели сплешевый урон, а не раздаёт сплеш на все окружающие цели. Радиус здесь - это лишь расстояние до условной основной цели (которой урон нужно наносить отдельно). При этом если указана дружественная цель, то такой урон будет автоматически занулён (т.к. весь сплеш в игре именно так и работает). Не задавайте этот аргумент, либо установите его в -1, если подразумевается, что вы наносите урон по основной цели.
RuinsMicromoduleChain - возвращает подходящий* микромодуль (номер бонуса) из цепочки предлагаемых станцией (любой, не обязательно ЦР) на текущий момент:
  1 - станция;
  2 - уровень микромодуля, который необходимо вернуть:
     0 - ММ третьего уровня;
     1 - ММ второго уровня;
     2 - ММ первого уровня;
  Опционально:
  3 - номер ММ из текущей цепочки (0-50), *по умолчанию вернёт ММ, подходящий игроку по хардкодовым условиям выдачи (проверит содержимое корабля);
  4 - маркер (0/1) для возврата ММ из альтернативной цепочки;
    Примечание: Альтернативная цепочка отличается от основной только (!) более редким списком микромодулей первого уровня. Получить микромодули первого уровня из альтернативной цепочки игрок может в каждый кратный 33 номер хода. Альтернативная цепочка обновляется одновременно с основной.
  Примечание: Хардкодовая логика предусматривает выдачу ММ строго по списку, однако также она учитывает содержимое корабля игрока. Если на корабле игрока имеется оборудование, в которое можно вставить очередной ММ в цепочке (начиная с нулевого), а также данного ММ на его корабле ещё нет (уже вставленные ММ не в счёт), то к покупке будет предложен именно он. В противном случае игра переходит к следующему ММ в цепочке и повторяет проверку. Никакой "истории покупок" у игры нет, благодаря чему можно бесконечно получать один и тот же ММ в цепочке, просто перекладывая только что купленный ММ на склад. В случае если игрок за раз скупил все ММ в цепочке (либо проверка не обнаружила на его корабле подходящего оборудования (оборудование с уже установленным ММ также считается неподходящим) и прокрутила цепочку в конец списка), то ему будет до бесконечности предлагаться последний ММ в цепочке. Все цепочки ММ для всех станций в Галактике обновляются одновременно, раз в 57 дней (каждый кратный 57 номер хода).


Функции для получения игровых достижений (тех же, что есть и в Steam):
GetAchievementSHU - без аргументов, получить достижение "Клонобоец";
GetAchievementGIRLSHIRE - без аргументов, получить достижение "Если б я был султан...";
GetAchievementGIRLSQUEST - без аргументов, получить достижение "Подкаблучник";
GetAchievementPIRATEWIN - без аргументов, получить достижение "Рачехан и все-все-все";
GetAchievementCOALLITION - без аргументов, получить достижение "За коалицию!";
GetAchievementHULL - без аргументов, получить достижение "Мир и порядок!";

Типы товаров:
  t_Food (0) - продукты;
  t_Medicine (1) - медикаменты;
  t_Technics (2) - техника;
  t_Luxury (3) - роскошь;
  t_Minerals (4) - минералы;
  t_Alcohol (5) - алкоголь;
  t_Arms (6) - оружие;
  t_Narcotics (7) - наркотики;

Типы предметов:
  t_Artefact (8) кастомный артефакт
  t_Artefact2 (9) неломаемый кастомный артефакт (создаётся добавлением в его раздел в Lang параметра NoWear=1)
  t_ArtefactHull (10) Железные жупи, минимальный размер 11
  t_ArtefactFuel (11) Чёрная жижа, минимальный размер 4
  t_ArtefactSpeed (12) Пси-ускоритель материи, минимальный размер 11
  t_ArtefactPower (13) Отморозки, минимальный размер 7
  t_ArtefactRadar (14) Пролонгер, минимальный размер 9
  t_ArtefactScaner (15) Сканерный кэш, минимальный размер 8
  t_ArtefactDroid (16) Дроид младший, минимальный размер 9
  t_ArtefactNano (17) Нанитоиды, минимальный размер 3
  t_ArtefactHook (18) Эриметр, минимальный размер 3
  t_ArtefactDef (19) Поляризатор, минимальный размер 11
  t_ArtefactAnalyzer (20) Вероятностный анализатор, минимальный размер 5
  t_ArtefactMiniExpl (21) Локализатор взрывной волны, минимальный размер 10
  t_ArtefactAntigrav (22) Антигравитатор, минимальный размер 18
  t_ArtefactTransmitter (23) Трансфакторный маяк, минимальный размер 3
  t_ArtefactBomb (24) Кварковая бомба, минимальный размер 5
  t_ArtefactTranclucator (25) Транклюкатор, минимальный размер 45
  t_ArtDefToEnergy (26) Пропорционар, минимальный размер 5
  t_ArtEnergyPulse (27) Пятерик, минимальный размер 8
  t_ArtEnergyDef (28) Проглот, минимальный размер 5
  t_ArtSplinter (29) Навинт, минимальный размер 9
  t_ArtDecelerate (30) Вжик, минимальный размер 5
  t_ArtMissileDef (31) Ракетанг, минимальный размер 6
  t_ArtForsage (32) Обливионный коннектор, минимальный размер 6
  t_ArtWeaponToSpeed (33) Сопланатор, минимальный размер 7
  t_ArtGiperJump (34) Гипергенератор, минимальный размер 5
  t_ArtBlackHole (35) Субпортал, минимальный размер 3
  t_ArtDefToArms1 (36) Протон, минимальный размер 8
  t_ArtDefToArms2 (37) Армс, минимальный размер 7
  t_ArtArtefactor (38) Артефактор, минимальный размер 3
  t_ArtBio (39) Биомир, минимальный размер 3
  t_ArtPDTurret (40) а'Эгис, минимальный размер 9
  t_ArtFastRacks (41) Ралс, минимальный размер ???
  t_Hull (42) корпус;
  t_FuelTanks (43) топливный бак;
  t_Engine (44) двигатель;
  t_Radar (45) радар;
  t_Scaner (46) сканер;
  t_RepairRobot (47) дроид;
  t_CargoHook (48) захват;
  t_DefGenerator (49) ГЗП;
Э   t_Weapon1 - Промышленный лазер (50), все расы;
О   t_Weapon2 - Осколочное орудие (51), все расы;
Э   t_Weapon3 - Лезка (52), все расы;
Р   t_Weapon4 - Ракетомет (53), все расы;
Э   t_Weapon5 - Третон (54), все расы;
Э   t_Weapon6 - Волновой фазер (55), все расы;
О   t_Weapon7 - Потоковый бластер (56), все расы;
Э   t_Weapon8 - Электронный резак (57), все расы;
О   t_Weapon9 - Мультирезонатор (58), все расы;
Э   t_Weapon10 - Атомный визион (59), все расы;
Э   t_Weapon11 - Дезинтегратор (60), все расы;
Э   t_Weapon12 - Турбогравир (61), все расы;
О   t_Weapon13 - ИМХО-9000 (62), только доминаторы;
Э   t_Weapon14 - Вертикс (63), только доминаторы;
Р   t_Weapon15 - Торпедный аппарат (64), только доминаторы;
О   t_Weapon16 - Эсодафер (65), только пиратский клан;
Э   t_Weapon17 - Кафаситор (66), только пиратский клан;
Р   t_Weapon18 - Лирекрон (67), только пиратский клан;
    t_CustomWeapon - любое кастомное оружие (68), проверять его строковый кастомный тип необходимо функцией CustomWeaponType();
  t_Protoplasm - ноды (69);
  t_UselessItem - квестовый (юзлесный) предмет (70);
  t_MicroModule - микромодуль (71);
  t_Cistern - цистерна (72) (в скриптовом коде может быть создана функцией CreateEquipment());
  t_Satellite - зонд (73);
  t_UselessCountableItem - кастомный сыпучий (74);

Бонусы для акринов и микромодулей (могут иметь отрицательные значения и выступать в качестве штрафов):
  bonHull (0) - бонус к броне корпуса;
  bonFuel (1) - бонус к объему топливного бака (работет только в качестве бонуса от ММ)****;
  bonSpeed (2) - бонус к скорости двигателя;
    Примечание: Все акриновые бонусы к скорости сперва плюсуются к текущей скорости двигателя, а расчёт фактической скорости корабля происходит позднее.
  bonJump (3) - бонус к дальности прыжка двигателя;
  bonRadar (4) - бонус к дальности радара;
  bonScan (5) - бонус к мощности сканера;
  bonDroid (6) - бонус к эффективности починки дроида;
  bonHook (7) - бонус к размеру захватываемых захватом предметов;
  bonDef (8) - бонус к мощности генератора защитного поля;
  bonWEnergy* (9) - бонус к силе энергетического оружия;
  bonWSplinter* (10) - бонус к силе осколочного оружия;
  bonWMissile* (11) - бонус к силе ракетного оружия;
  bonWRadius* (12) - бонус к дальности стрельбы оружия;
  bonSlotRadar (13) - открыть/закрыть слот радара;
  bonSlotScaner (14) - открыть/закрыть слот сканера;
  bonSlotDroid (15) - открыть/закрыть слот дроида;
  bonSlotHook (16) - открыть/закрыть слот захвата;
  bonSlotDef (17) - открыть/закрыть слот генератора защитного поля;
  bonSlotWeapon (18) - открыть/закрыть слоты оружия;
  bonSlotArt (19) - открыть/закрыть слоты артефактов;
  bonSlotForsage (20) - открыть/закрыть слот форсажа;
  bonHookRadius (21) - бонус к дальности действия захвата;
  bonSkill1 (22) - изменяет навык точности;
  bonSkill2 (23) - изменяет навык манёвренности;
  bonSkill3 (24) - изменяет навык техники;
  bonSkill4 (25) - изменяет навык торговли;
  bonSkill5 (26) - изменяет навык обаяния;
  bonSkill6 (27) - изменяет навык лидерства;
  bonMass (28) - изменяет процент массы корабля и установленного оборудования (работает только в качестве бонуса от корпусного акрина, либо от ММ);
  bonExtraAkrinEff (29) - изменяет мощность акрина, при значении 100 эффект акрина увеличивается в 2 раза (работет только в качестве бонуса от ММ);
  bonExtraAkrinPenalty (30) - изменяет мощность отрицательного акринового бонуса, при этом положительное не изменяется (работет только в качестве бонуса от ММ);
  bonAmmo* (31) - увеличение боезапаса ракетного оружия (применимо только для ракетного оружия, не работает из спецакрина);
  bonShots* (32) - добавляет ракеты к выстрелу, применимо только для ракетного оружия с типом выстрела Rocket или Missile (бонус работает только из акрина на оружие или ММ);
  bonMissileSpeed* (33) - увеличивает скорость выпускаемых ракет/торпед (применимо только для ракетного оружия);
  bonShotSpeed* (34) - изменение очерёдности выстрела (применимо только для оружия);
  bonHookMaxSpeed*** (35) - прибавка к скорости притяжения захвата на дальней дистанции;
  bonHookMinSpeed*** (36) - прибавка к скорости притяжения захвата на ближней дистанции;
  bonStimCapacity (37) - изменяет максимальное количество принимаемых игроком за раз стимуляторов (учтите, что на МЦ фактическое число стимуляторов для приема в установленном игрой и бонусами диапазоне определяется рандомом);
  bonZonds (38) - бонус к максимальному лимиту зондов под контролем игрока (при превышении лимита износ активных зондов ускоряется);
  bonAttacks* (39) - дополнительное число выстрелов за ход в конкретном орудии (бонус работает только из акрина или ММ на оружие, либо из ShipSpecialBonuses**);
  bonResistAsteroid (40) - снижает/увеличивает урон от попадания астероидов в процентном соотношении, где 0 - базовое для корабля значение (bonResistAsteroid=50 снизит урон от попадания астероида в два раза);
    *Примечание: Все оружейные (с приставкой W, а также бонусы bonShots, bonAttacks, bonShotSpeed, bonMissileSpeed и bonAmmo) бонусы, будучи записаны в оружейные акрины, применяются только на то орудие, в котором установлен соответствующий акрин. Все прочие бонусы на оружейных акринах работают по общим правилам.
    **Примечание: При использовании бонуса bonAttacks в ShipSpecialBonuses, в каждое орудие будут добавлены не дополнительные выстрелы, но полная итерация его залпа за ход. К примеру, если орудие должно выстрелить 3 раза за ход, то с ShipSpecialBonuses +2 оно сделает 9 выстрелов, а с ShipSpecialBonuses -1 ни одного. Скорость износа всех орудий, при наличии данного бонуса, снижается пропорционально числу дополнительных залпов.
    ***Примечание: Скорость притяжения предмета минимальна на пределе дистанции захвата и максимальна в нулевой точке, то есть в координатном центре самого корабля. Чем ближе предмет лежит к кораблю - тем выше скорость захвата. Минимальное значение скорости захвата составляет 0.1, так что полностью опуститься в ноль она не сможет ни при каких бонусах.
  ****Также бонус к объёму бака можно навесить в виде штрафа через ShipSpecialBonuses(), и хотя визуально никакой разницы в карточке корабля видно не будет, для NPC такая метка будет означать запрет на совершение прыжков (если поставить -1000, например), т.к. он будет считать, что топлива на прыжок ему никуда не хватает. Фактически, костыль на запрет совершения прыжков для NPC.

Список событий для интерфейсного кода:
OnPressCode - данный код срабатывает при левом щелчке мышью по объекту (только для GraphButton);
OnMouseRightClick - данный код срабатывает при правом щелчке мышью по объекту (не вызывает срабатывания анимации нажатия, только для GraphButton);
OnMouseEnterCode - данный код срабатывает при наведении курсора на объект;
OnMouseLeaveCode - данный код срабатывает при уводе курсора с объекта;

Дополнительная информация:
  Срабатывание тернкода в скриптах:
   TurnCode или тёрнкод, буквально означает "код хода", поэтому логично было бы ожидать, что он срабатывает каждый ход. Тем не менее, это не совсем так. Также данный ход срабатывает в моменты взлёта/посадки игрока, а также при влёте/вылете его из ЧД. Помимо этого, тернкод конкретного скрипта срабатывает при завершении игроком скриптового (запущенного из конкретного скрипта) текстового квеста, чтобы "поймать" и обработать результат его выполнения успех/провал.
   Данную особенность этого исполнителя важно понимать, чтобы не вешать в него "ежедневные" счётчики вида: x = x - 1 (такие возможно использовать только в событии t_OnStep в акткоде). Вместо них нужно пользоваться не прямыми счётчиками вида: x = x + CurTurn(), и далее проверять его срабатывание состояние через if(x <= CurTurn()).
  Принципы работы переменных в акт-/юз-/интерфейс- кодах:
     Все переменные в этих кодах являются временными локалками и не видны из других видов кода. Исключение составляют только предметы, к которым акткод был подвязан с помощью скриптового объекта, т.к. они могут видеть и менять локальные постоянные переменные из соответствующего скрипта.
   При объявлении новой переменный любом месте блока акткода (даже если участки кода разделены взаимоисключающими условиями) эта переменная будет доступна из любого места такого кода. Фактически, её объявление происходит в момент компиляции кода перед его исполнением, там же происходит и объявление всех обнаруженных переменных. По этой же причине нельзя объвлять в таких блоках кода одну и ту же переменную по нескольку раз - это приведёт к ошибке компиляции.
   Объявление переменной не обязательно должно сопровождаться её инициализацией. При любом обращении к неинициализированной переменной (а возможно даже, что ещё при компиляции), ей автоматически присваивается базовое значение, соответствующее её типу (0, 0.0,'' и т.д.). Однако следует помнить, что перечисленные блоки кода не перекомпилируются при каждом новом обращении. Поэтому, например, если ранее инфошка с акткодом на одном корабле уже отработала по запросу, а затем исполнение перешло к другому кораблю с точно таким же акткодом, все значения объявленных в таком блоке переменных обнулены не будут, и вы можете словить непонятный краш, если вручную не обнулите какой-нибудь важный маркер.
  Добавление кодов обработки нажатия клавиш с клавиатуры:
   В Main необходимо создать раздел OnKey, при этом месторасположение раздела значения не имеет (но должен хотя бы одной Panel). При каждом нажатии кнопки на клавиатуре в этом разделе будет срабатывать скриптовый код. Код нажатой клавиши в момент события записывается в переменную KEY (в пределах блока OnKey объявлять не нужно), для Z код клавиши будет 90, для Alt 18 и т.д. Также в переменную KEYMOD (объявлять также не надо) записаны все зажатые в данный момент "модификаторы" в виде сета, а именно Shift (1), Ctrl (2) и Alt (4). Если зажать клавишу на клавиатуре, то событие вызова кода будет спамиться до тех пор, пока зажата соответствующая клавиша.
  На какой планете выдают награду при освобождении системы:
   Награду за освобождение системы всегда выдают на первой (от звезды) заселённой планете.
  Добавление кастомных правительственных наград (медалей, орденов и т.д.):
     Все награды в КР размещены в разделе Reward в игровом Lang и могут быть, при желании, дополнены новыми. Для этого достаточно добавить новую награду на незанятый порядковый номер (перед этим убедившись, что его не используют другие моды) и увеличить общий счётчик Count в конце раздела с наградами. Максимальное число наград в игре ограничено и составляет 256 слотов (0-255), из которых оригинальная игра использует всего 48 (0-47). В моде ExpBlackMarket была добавлена скриптовая 49-я (номер 48 в Lang) награда, а в ShuRebellion 50-я (номер 49 в Lang).
   Если вам по какой-либо причине нужно добавить в список награду, которая не должна автоматически выдаваться в игре (например, вы хотите выдавать её скриптом), то необходимо "заблокировать" два параметра этой награды, а именно Race и Status, путём подстановки невалидного значения (пустое будет расценено игрой как "Any") в качестве которого отлично подойдёт, например "None". Параметр Type необходимо указывать корректно в любом случае, т.к. он игре необходим.
  Перебор расы при создании корпуса/оборудования/артефакта/предмета:
     Если нужно рандомно определить расу-производителя, но при этом вы хотите исключить из списка возможных рас, например, доминаторов, удобнее всего будет воспользоваться подобной командой: while(race == 5) race = Rnd(0, 7);
  Исключение Тортугаца и Нифигаца при переборе систем:
   Наиболее удобный способ (исключающий проверку по названиям систем), использовать проверку вида:
   if(StarToCon(star) == StarToCon(PlanetToStar(PlanetPirateClan())));
  Как выявить рейнджера со скином корпуса "Таухито":
   Скин "Таухито" намертво прописывается хардкодом на корабли при исполнении всех нижеперечисленных условий:
     - Корабль является рейнджером (ShipTypeN(ship) == t_Ranger);
       - Корабль имеет Id кратный шести;
     - Ход рождения корабля меньше 666;
     - Корабль имеет человеческую расу пилота;
     - Корабль не имеет женский портрет;
   Чтобы "снять" с корабля данный скин и "серию" (хотя на самом деле это не настоящая серия), необходимо либо сменить расу пилота, либо установить женский портрет. Также проверить наличие данного скина можно, запросив прямой адрес функцией Chameleon().
  Как проверить размер правительственной награды в коде текстового квеста:
     GRewardMoney - параметр внутри текстового квеста. При его наличии туда будет записан размер основной награды за квест, которую получит игрок. Может быть полезно для расчёта дополнительной награды в % от основной, а не по фиксированной быстроустаревающей (из-за инфляции) константе.
  Общие переменные в текстовых квестах и скриптах:
   При объявлении в скрипте переменной типа int (синхронизация с квестом возможна только для этого типа) с именем GQuestVarExt_VarName (в названии должна присутствовать приставка 'GQuestVarExt_'), и одновременном объявлении в текстовом квесте параметра ext_VarName (должна присутствовать приставка 'ext_', а также должно совпадать название самой переменной), их значения будут всегда синхронизированы. Сперва квест будет искать соответствия среди локальных переменных скрипта, а при их отсутствии - среди глобальных.
   Важно иметь ввиду, что синхронизация переменных происходит в момент старта квеста (значение переменной скрипта будет записано в переменную квеста), а также при любом изменении одной из синхронизированных переменных (действия в квесте будут влиять на значение скриптовой переменной и наоборот). То есть, если в квесте имеется некая ключевая переменная (например, численность населения в "Колонизации"), то на старте квеста её стартовое значение будет заменено на значение переменной из скрипта, что может привести к моментальному провалу, либо выполнению квеста.
  Базовые цветовые палитры RGB для текста, используемые игрой:
   Красный (везде): 255,0,0
   Красный для голубого фона (вроде нигде не используется): 169,62,65
   Зелёный в карточках: 0,255,0
   Темно-зелёный: 0,130,0
   Зелёный для голубого фона: 45,105,45 (в том числе используется для подсветки "Получено опыта: <Points> очков.")
   Светло-зелёный для бонуса (хз откуда именно): 8,255,80
   Диалоговый синий: 0,50,200
   Синий, непонятно откуда: 0,71,234
   Светло-жёлтый цвет в уведомлениях и карточках: 255,240,100
   Ярко-жёлтый для диалогов (вроде нигде не используется): 255,255,0
   Цвет названия акриновых предметов в карточках: 255,167,84
   Цвет названия акриновых предметов для диалогов (на голубом фоне): 255,166,0
   Пурпурный для номеров страниц в уведомлениях имущества на складе: 255,0,255
   Серый для заблокированных вариантов ответа: 127,127,127
   Оранжевый: 254,217,7
   Белый: 255,255,254
   Чёрный: 1,1,1
